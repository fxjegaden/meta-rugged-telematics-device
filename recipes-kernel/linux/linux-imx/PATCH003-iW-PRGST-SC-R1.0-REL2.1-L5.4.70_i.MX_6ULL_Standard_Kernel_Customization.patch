diff -Naur A/arch/arm/boot/dts/imx6ull-iwg26i.dts B/arch/arm/boot/dts/imx6ull-iwg26i.dts
--- A/arch/arm/boot/dts/imx6ull-iwg26i.dts	1970-01-01 05:30:00.000000000 +0530
+++ B/arch/arm/boot/dts/imx6ull-iwg26i.dts	2022-08-09 13:45:22.067742252 +0530
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "imx6ull-iwg26i.dtsi"
+
+&iomuxc {
+	pinctrl_gpmi_nand_1: gpmi-nand-1 {
+		fsl,pins = <
+			MX6UL_PAD_NAND_CLE__RAWNAND_CLE		0xb0b1
+			MX6UL_PAD_NAND_ALE__RAWNAND_ALE		0xb0b1
+			MX6UL_PAD_NAND_WP_B__RAWNAND_WP_B	0xb0b1
+			MX6UL_PAD_NAND_READY_B__RAWNAND_READY_B	0xb000
+			MX6UL_PAD_NAND_CE0_B__RAWNAND_CE0_B	0xb0b1
+			MX6UL_PAD_NAND_CE1_B__RAWNAND_CE1_B	0xb0b1
+			MX6UL_PAD_NAND_RE_B__RAWNAND_RE_B	0xb0b1
+			MX6UL_PAD_NAND_WE_B__RAWNAND_WE_B	0xb0b1
+			MX6UL_PAD_NAND_DATA00__RAWNAND_DATA00	0xb0b1
+			MX6UL_PAD_NAND_DATA01__RAWNAND_DATA01	0xb0b1
+			MX6UL_PAD_NAND_DATA02__RAWNAND_DATA02	0xb0b1
+			MX6UL_PAD_NAND_DATA03__RAWNAND_DATA03	0xb0b1
+			MX6UL_PAD_NAND_DATA04__RAWNAND_DATA04	0xb0b1
+			MX6UL_PAD_NAND_DATA05__RAWNAND_DATA05	0xb0b1
+			MX6UL_PAD_NAND_DATA06__RAWNAND_DATA06	0xb0b1
+			MX6UL_PAD_NAND_DATA07__RAWNAND_DATA07	0xb0b1
+		>;
+	};
+};
diff -Naur A/arch/arm/boot/dts/imx6ull-iwg26i.dtsi B/arch/arm/boot/dts/imx6ull-iwg26i.dtsi
--- A/arch/arm/boot/dts/imx6ull-iwg26i.dtsi	1970-01-01 05:30:00.000000000 +0530
+++ B/arch/arm/boot/dts/imx6ull-iwg26i.dtsi	2022-08-09 13:46:20.639180736 +0530
@@ -0,0 +1,737 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/dts-v1/;
+
+#include <dt-bindings/input/input.h>
+#include "imx6ull.dtsi"
+
+/ {
+	model = "Freescale i.MX6 ULL Board";
+	compatible = "iw,ull_iwg26i", "fsl,imx6ull";
+
+	aliases {
+		ethernet0 = &fec1;
+		ethernet1 = &fec2;
+	};
+
+	chosen {
+		stdout-path = &uart5;
+		bootargs = "console=ttymxc4,115200 loglevel=1";
+	};
+
+	memory {
+		reg = <0x80000000 0x20000000>;
+	};
+
+	reserved-memory {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		linux,cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0x14000000>;
+			linux,cma-default;
+		};
+	};
+
+	regulators {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		reg_can_3v3: regulator@0 {
+			compatible = "regulator-fixed";
+			reg = <0>;
+			regulator-name = "can-3v3";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+		};
+
+		reg_sd1_vmmc: regulator@1 {
+			compatible = "regulator-fixed";
+			regulator-name = "VSD_3V3";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+		};
+
+		reg_sd1_vmmc_wifi: regulator_wifi@1 {
+			compatible = "regulator-fixed";
+			regulator-name = "VSD_3V3_wifi";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+			enable-active-high;
+			regulator-always-on;
+
+		};
+	
+		reg_2p5v: 2p5v {
+			compatible = "regulator-fixed";
+			regulator-name = "2P5V";
+			regulator-min-microvolt = <2500000>;
+			regulator-max-microvolt = <2500000>;
+			regulator-always-on;
+		};
+
+		reg_3p3v: 3p3v {
+			compatible = "regulator-fixed";
+			regulator-name = "3P3V";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+			regulator-always-on;
+		};
+
+		reg_3p3v_wifi: 3p3v_wifi {
+			compatible = "regulator-fixed";
+			regulator-name = "3P3V_wifi";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+			regulator-always-on;
+		};
+
+		reg_0p0v: 0p0v {
+			compatible = "regulator-fixed";
+			regulator-name = "0P0V";
+			regulator-min-microvolt = <0000000>;
+			regulator-max-microvolt = <0000000>;
+			regulator-always-on;
+		};
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_gpio_keys>;
+
+		power {
+			label = "wakeup-gpio";
+			gpios = <&gpio3 3 0>;
+			keep-power-in-suspend;
+			gpio-key,wakeup;
+			wakeup-source;
+			linux,code = <29>;
+		};
+	};
+
+	gpio-keys1 {
+		compatible = "gpio-keys";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_gpio_keys1>;
+
+		mcu-wakeup {
+			label = "wakeup-gpio";
+			gpios = <&gpio1 6 0>;
+			keep-power-in-suspend;
+			gpio-key,wakeup;
+			wakeup-source;
+			linux,code = <29>;
+		};
+	};
+};
+
+&cpu0 {
+	arm-supply = <&reg_arm>;
+	soc-supply = <&reg_soc>;
+};
+
+&clks {
+	assigned-clocks = <&clks IMX6UL_CLK_PLL4_AUDIO_DIV>;
+	assigned-clock-rates = <786432000>;
+};
+
+&can1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan1>;
+	xceiver-supply = <&reg_can_3v3>;
+	status = "okay";
+};
+
+&can2 {
+	pinctrl-names = "default", "alternative";
+	pinctrl-0 = <&pinctrl_flexcan2>;
+	xceiver-supply = <&reg_can_3v3>;
+	status = "okay";
+};
+
+&gpc {
+	fsl,cpu_pupscr_sw2iso = <0xf>;
+	fsl,cpu_pupscr_sw = <0x0>;
+	fsl,cpu_pdnscr_iso2sw = <0x1>;
+	fsl,cpu_pdnscr_iso = <0x1>;
+	fsl,wdog-reset = <1>;
+	fsl,ldo-bypass = <0>;
+};
+
+&i2c1 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c1>;
+	status = "okay";
+
+	iis2mdc: iis2mdc@1e {
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_iis2mdc0>;
+		compatible = "st,iis2mdc_magn";
+		reg = <0x1e>;
+		interrupt-parent = <&gpio3>;
+		interrupts = <2 IRQ_TYPE_LEVEL_LOW>;
+	};
+
+};
+
+&i2c2 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c2>;
+	status = "okay";
+	
+	stism330dlc: stism330dlc@6a{
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_ism330dlc0>;
+		compatible = "st,lsm6dsl";
+		reg = <0x6a>;
+		interrupt-parent = <&gpio3>;
+		interrupts = <1 IRQ_TYPE_EDGE_RISING>;
+		st,drdy-int-pin = <1>;
+		wakeup-source;
+	};
+
+	bq25601: bq25601@6b {
+		compatible = "ti,bq25601";
+		reg = <0x6b>;
+	};
+
+	/*pcf85263: pcf85263@51 {
+		compatible = "nxp,pcf85363";
+		reg = <0x51>;
+	};*/
+};
+
+&ecspi1 {
+	fsl,spi-num-chipselects = <1>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ecspi1_1>;
+	cs-gpios = <&gpio4 26 GPIO_ACTIVE_HIGH>;
+	status = "okay";
+
+	hclk: clock@4 {
+		compatible = "fixed-clock";
+		reg = <4>;
+		#clock-cells = <0>;
+		clock-frequency = <40000000>;
+		clock-output-names = "hclk";
+	};
+
+	cclk: clock@5 {
+		compatible = "fixed-clock";
+		reg = <5>;
+		#clock-cells = <0>;
+		clock-frequency = <40000000>;
+		clock-output-names = "cclk";
+	};
+
+	tcan4x5x: tcan4x5x@0 {
+		compatible = "ti,tcan4x5x";
+		reg = <0>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		spi-max-frequency = <18000000>;
+		bosch,mram-cfg = <0x0 3 2 32 10 1 32 7>;
+		clocks = <&hclk>, <&cclk>;
+		clock-names = "hclk", "cclk";
+		interrupt-parent = <&gpio1>;
+		interrupts = <23 GPIO_ACTIVE_LOW>;
+		data-ready-gpios = <&gpio1 23 GPIO_ACTIVE_LOW>;
+		reset-gpios = <&gpio1 22 GPIO_ACTIVE_LOW>;
+		iw-tcan-prop;
+		status = "okay";
+	};
+};
+
+&iomuxc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hog_1>;
+	imx6ul-evk {
+		pinctrl_hog_1: hoggrp-1 {
+			fsl,pins = <
+				/* PCB Assembly Configuration */
+				MX6UL_PAD_JTAG_TRST_B__GPIO1_IO15	0x80000000
+				MX6UL_PAD_JTAG_MOD__GPIO1_IO10		0x80000000
+				MX6UL_PAD_JTAG_TDI__GPIO1_IO13		0x80000000
+				MX6UL_PAD_JTAG_TDO__GPIO1_IO12		0x80000000
+				MX6UL_PAD_JTAG_TMS__GPIO1_IO11		0x80000000
+				MX6UL_PAD_JTAG_TCK__GPIO1_IO14 		0x80000000
+
+				/* Tamper */
+				MX6UL_PAD_SNVS_TAMPER0__GPIO5_IO00	0x80000000
+				MX6UL_PAD_SNVS_TAMPER1__GPIO5_IO01	0x80000000
+				MX6UL_PAD_SNVS_TAMPER2__GPIO5_IO02	0x80000000
+				MX6UL_PAD_SNVS_TAMPER3__GPIO5_IO03	0x80000000
+				/* WL_REG_ON (GPIO5_IO04) | BT_REG_ON (GPIO5_IO05) */
+				MX6UL_PAD_SNVS_TAMPER4__GPIO5_IO04	0x80000000
+				MX6UL_PAD_SNVS_TAMPER5__GPIO5_IO05	0x80000000
+				MX6UL_PAD_SNVS_TAMPER6__GPIO5_IO06	0x80000000
+				MX6UL_PAD_SNVS_TAMPER7__GPIO5_IO07	0x80000000
+				/* Cellular Module Status Pin - GPIO5_IO08 */
+				MX6UL_PAD_SNVS_TAMPER8__GPIO5_IO08	0x80000000
+				MX6UL_PAD_SNVS_TAMPER9__GPIO5_IO09	0x80000000
+
+				/* External Interface */
+				MX6UL_PAD_ENET1_TX_CLK__GPIO2_IO06	0x80000000
+				MX6UL_PAD_ENET1_RX_ER__GPIO2_IO07	0x80000000
+				MX6UL_PAD_ENET1_RX_DATA0__GPIO2_IO00	0x80000000
+				MX6UL_PAD_GPIO1_IO04__GPIO1_IO04	0x80000000
+
+				/* Load Dump */
+				/* SHDN */
+				MX6UL_PAD_LCD_DATA01__GPIO3_IO06	0x80000000
+				/* FLAG VIN */
+				MX6UL_PAD_LCD_DATA07__GPIO3_IO12	0x80000000
+
+				/* LED */
+				MX6UL_PAD_LCD_DATA04__GPIO3_IO09	0x80000000
+
+				/* External Battery */
+				MX6UL_PAD_LCD_DATA15__GPIO3_IO20	0x80000000
+
+				/* Power Managament Switch */
+				MX6UL_PAD_LCD_DATA17__GPIO3_IO22	0x80000000
+				MX6UL_PAD_LCD_DATA21__GPIO3_IO26	0x80000000
+				MX6UL_PAD_LCD_DATA22__GPIO3_IO27	0x80000000
+
+				/* Internal Battery */
+				MX6UL_PAD_LCD_DATA18__GPIO3_IO23	0x80000000
+
+				/* Cellular Module STB */
+				MX6UL_PAD_GPIO1_IO07__GPIO1_IO07	0x80000000
+				MX6UL_PAD_LCD_DATA19__GPIO3_IO24	0x80000000
+				MX6UL_PAD_CSI_DATA00__GPIO4_IO21	0x80000000	
+				MX6UL_PAD_LCD_DATA09__GPIO3_IO14	0x80000000
+				MX6UL_PAD_LCD_DATA10__GPIO3_IO15	0x80000000
+				MX6UL_PAD_LCD_DATA11__GPIO3_IO16	0x80000000
+
+				/*BT Chipset & BT Module*/
+				MX6UL_PAD_GPIO1_IO09__GPIO1_IO09	0x80000000
+				MX6UL_PAD_LCD_DATA16__GPIO3_IO21	0x80000000
+
+				/*BT Chipset & BT Module & WIFI + BT Module */
+				MX6UL_PAD_LCD_DATA23__GPIO3_IO28	0x80000000
+				MX6UL_PAD_LCD_DATA08__GPIO3_IO13	0x80000000
+
+				/*Battery Charger + Power Management circuit*/	
+				MX6UL_PAD_LCD_CLK__GPIO3_IO00		0x80000000
+				MX6UL_PAD_CSI_DATA01__GPIO4_IO22	0x80000000
+				MX6UL_PAD_CSI_DATA02__GPIO4_IO23	0x80000000
+				MX6UL_PAD_CSI_DATA03__GPIO4_IO24	0x80000000
+			>;
+		};
+
+		pinctrl_enet1: enet1grp {
+			fsl,pins = <
+				MX6UL_PAD_ENET1_RX_EN__ENET1_RX_EN	0x1b0b0
+				MX6UL_PAD_ENET1_RX_ER__ENET1_RX_ER	0x1b0b0
+				MX6UL_PAD_ENET1_RX_DATA0__ENET1_RDATA00	0x1b0b0
+				MX6UL_PAD_ENET1_RX_DATA1__ENET1_RDATA01	0x1b0b0
+				MX6UL_PAD_ENET1_TX_EN__ENET1_TX_EN	0x1b0b0
+				MX6UL_PAD_ENET1_TX_DATA0__ENET1_TDATA00	0x1b0b0
+				MX6UL_PAD_ENET1_TX_DATA1__ENET1_TDATA01	0x1b0b0
+				MX6UL_PAD_ENET1_TX_CLK__ENET1_REF_CLK1	0x4001b031
+			>;
+		};
+
+		pinctrl_enet2: enet2grp {
+			fsl,pins = <
+				MX6UL_PAD_ENET1_TX_DATA1__ENET2_MDIO	0x1b0b0
+				MX6UL_PAD_ENET1_TX_EN__ENET2_MDC	0x1b0b0
+				MX6UL_PAD_ENET2_TX_DATA0__ENET2_TDATA00	0x1b0b0
+				MX6UL_PAD_ENET2_TX_DATA1__ENET2_TDATA01	0x1b0b0
+				MX6UL_PAD_ENET2_TX_EN__ENET2_TX_EN	0x1b0b0
+				MX6UL_PAD_ENET2_TX_CLK__ENET2_REF_CLK2	0x4001b031
+				MX6UL_PAD_ENET2_RX_DATA0__ENET2_RDATA00	0x1b0b0
+				MX6UL_PAD_ENET2_RX_DATA1__ENET2_RDATA01	0x1b0b0
+				MX6UL_PAD_ENET2_RX_ER__ENET2_RX_ER	0x1b0b0
+				MX6UL_PAD_ENET2_RX_EN__ENET2_RX_EN	0x1b0b0
+				MX6UL_PAD_LCD_DATA02__GPIO3_IO07	0x80000000
+				MX6UL_PAD_LCD_RESET__GPIO3_IO04		0x80000000
+			>;
+		};
+
+		pinctrl_flexcan1: flexcan1grp{
+			fsl,pins = <
+				MX6UL_PAD_UART3_RTS_B__FLEXCAN1_RX	0x1b020
+				MX6UL_PAD_UART3_CTS_B__FLEXCAN1_TX	0x1b020
+				MX6UL_PAD_LCD_DATA03__GPIO3_IO08	0x80000000
+				MX6UL_PAD_LCD_DATA20__GPIO3_IO25	0x80000000
+			>;
+		};
+
+		pinctrl_flexcan2: flexcan2grp{
+			fsl,pins = <
+				MX6UL_PAD_ENET1_RX_EN__FLEXCAN2_TX	0x1b020
+				MX6UL_PAD_ENET1_TX_DATA0__FLEXCAN2_RX	0x1b020
+				MX6UL_PAD_ENET1_RX_DATA1__GPIO2_IO01 	0x80000000
+				MX6UL_PAD_LCD_DATA06__GPIO3_IO11	0x80000000
+			>;
+		};
+
+		pinctrl_i2c1: i2c1grp {
+			fsl,pins = <
+				MX6UL_PAD_GPIO1_IO02__I2C1_SCL		0x4001b8b0
+				MX6UL_PAD_GPIO1_IO03__I2C1_SDA		0x4001b8b0
+			>;
+		};
+
+		pinctrl_iis2mdc0: iis2mdc0grp {
+			fsl,pins = <
+				MX6UL_PAD_LCD_HSYNC__GPIO3_IO02		0x80000000 /* interrupt */
+			>;
+		};
+
+		pinctrl_ism330dlc0: ism3330dlc0grp {
+			fsl,pins = <
+				MX6UL_PAD_LCD_ENABLE__GPIO3_IO01	0x80000000
+			>;
+		};
+
+		pinctrl_i2c2: i2c2grp {
+			fsl,pins = <
+				MX6UL_PAD_CSI_HSYNC__I2C2_SCL		0x4001b8b0
+				MX6UL_PAD_CSI_VSYNC__I2C2_SDA		0x4001b8b0
+			>;
+		};
+
+		pinctrl_qspi: qspigrp {
+			fsl,pins = <
+				MX6UL_PAD_NAND_WP_B__QSPI_A_SCLK	0x70a1
+				MX6UL_PAD_NAND_READY_B__QSPI_A_DATA00	0x70a1
+				MX6UL_PAD_NAND_CE0_B__QSPI_A_DATA01	0x70a1
+				MX6UL_PAD_NAND_CE1_B__QSPI_A_DATA02	0x70a1
+				MX6UL_PAD_NAND_CLE__QSPI_A_DATA03	0x70a1
+				MX6UL_PAD_NAND_DQS__QSPI_A_SS0_B	0x70a1
+			>;
+		};
+
+		pinctrl_sai2: sai2grp {
+			fsl,pins = <
+				MX6UL_PAD_JTAG_TDI__SAI2_TX_BCLK	0x17088
+				MX6UL_PAD_JTAG_TDO__SAI2_TX_SYNC	0x17088
+				MX6UL_PAD_JTAG_TRST_B__SAI2_TX_DATA	0x11088
+				MX6UL_PAD_JTAG_TCK__SAI2_RX_DATA	0x11088
+				MX6UL_PAD_JTAG_TMS__SAI2_MCLK		0x17088
+			>;
+		};
+
+		pinctrl_uart1: uart1grp {
+			fsl,pins = <
+				MX6UL_PAD_UART1_TX_DATA__UART1_DCE_TX	0x1b0b1
+				MX6UL_PAD_UART1_RX_DATA__UART1_DCE_RX	0x1b0b1
+				MX6UL_PAD_UART1_CTS_B__UART1_DCE_CTS	0x1b0b1
+				MX6UL_PAD_UART1_RTS_B__UART1_DCE_RTS	0x1b0b1
+			>;
+		};
+
+		pinctrl_uart2: uart2grp {
+			fsl,pins = <
+				MX6UL_PAD_UART2_RX_DATA__UART2_DCE_RX	0x1b0b1
+				MX6UL_PAD_UART2_TX_DATA__UART2_DCE_TX	0x1b0b1
+			>;
+		};
+
+		pinctrl_uart3: uart3grp {
+			fsl,pins = <
+				MX6UL_PAD_UART3_TX_DATA__UART3_DCE_TX	0x1b0b1
+				MX6UL_PAD_UART3_RX_DATA__UART3_DCE_RX	0x1b0b1
+				MX6UL_PAD_LCD_DATA00__GPIO3_IO05	0x80000000
+				MX6UL_PAD_LCD_DATA05__GPIO3_IO10	0x80000000
+			>;
+		};
+
+		pinctrl_uart4: uart4grp {
+			fsl,pins = <
+				MX6UL_PAD_UART4_TX_DATA__UART4_DCE_TX	0x1b0b1
+				MX6UL_PAD_UART4_RX_DATA__UART4_DCE_RX	0x1b0b1
+			>;
+		};
+
+		pinctrl_uart6: uart6grp {
+			fsl,pins = <
+				MX6UL_PAD_CSI_PIXCLK__UART6_DCE_RX	0x1b0b0
+				MX6UL_PAD_CSI_MCLK__UART6_DCE_TX	0x1b0b0
+			>;
+		};
+
+		pinctrl_gpio_keys: gpio_keysgrp {
+			fsl,pins = <
+				MX6UL_PAD_LCD_VSYNC__GPIO3_IO03		0x80000000
+			>;
+		};
+
+		pinctrl_gpio_keys1: gpio_keysgrp1 {
+			fsl,pins = <
+				/* MCU GPIO Interrupt */
+				MX6UL_PAD_GPIO1_IO06__GPIO1_IO06	0x80000000
+			>;
+		};
+
+		pinctrl_ecspi1_1: pinctrl_ecspi1_1 {
+			fsl,pins = <
+				MX6UL_PAD_CSI_DATA04__ECSPI1_SCLK	0x10b0
+				MX6UL_PAD_CSI_DATA05__GPIO4_IO26	0x80000000
+				MX6UL_PAD_CSI_DATA06__ECSPI1_MOSI	0x10b0
+				MX6UL_PAD_CSI_DATA07__ECSPI1_MISO	0x10b0
+				MX6UL_PAD_UART2_CTS_B__GPIO1_IO22	0x80000000
+				MX6UL_PAD_UART2_RTS_B__GPIO1_IO23	0x80000000
+			>;
+		};
+
+		pinctrl_ssi: pinctrl_ssi_1{
+			fsl,pins = <
+				MX6UL_PAD_LCD_DATA12__SAI3_TX_SYNC	0x80000000
+				MX6UL_PAD_LCD_DATA13__SAI3_TX_BCLK	0x80000000
+				MX6UL_PAD_LCD_DATA14__SAI3_RX_DATA	0x80000000
+			>;
+		};
+
+		pinctrl_usdhc1: usdhc1grp {
+			fsl,pins = <
+				MX6UL_PAD_SD1_DATA0__USDHC1_DATA0	0x1b030
+				MX6UL_PAD_SD1_DATA1__USDHC1_DATA1	0x1b030
+				MX6UL_PAD_SD1_DATA2__USDHC1_DATA2	0x1b030
+				MX6UL_PAD_SD1_DATA3__USDHC1_DATA3	0x1b030
+				MX6UL_PAD_SD1_CLK__USDHC1_CLK		0x1b030
+				MX6UL_PAD_SD1_CMD__USDHC1_CMD		0x1b030
+			>;
+		};
+
+		pinctrl_usdhc1_100mhz: usdhc1grp100mhz {
+			fsl,pins = <
+				MX6UL_PAD_SD1_CMD__USDHC1_CMD		0x170b9
+				MX6UL_PAD_SD1_CLK__USDHC1_CLK		0x100b9
+				MX6UL_PAD_SD1_DATA0__USDHC1_DATA0	0x170b9
+				MX6UL_PAD_SD1_DATA1__USDHC1_DATA1	0x170b9
+				MX6UL_PAD_SD1_DATA2__USDHC1_DATA2	0x170b9
+				MX6UL_PAD_SD1_DATA3__USDHC1_DATA3	0x170b9
+			>;
+		};
+
+		pinctrl_usdhc1_200mhz: usdhc1grp200mhz {
+			fsl,pins = <
+				MX6UL_PAD_SD1_CMD__USDHC1_CMD		0x170f9
+				MX6UL_PAD_SD1_CLK__USDHC1_CLK		0x100f9
+				MX6UL_PAD_SD1_DATA0__USDHC1_DATA0	0x170f9
+				MX6UL_PAD_SD1_DATA1__USDHC1_DATA1	0x170f9
+				MX6UL_PAD_SD1_DATA2__USDHC1_DATA2	0x170f9
+				MX6UL_PAD_SD1_DATA3__USDHC1_DATA3	0x170f9
+			>;
+		};
+
+		pinctrl_usdhc2: usdhc2grp {
+			fsl,pins = <
+				MX6UL_PAD_NAND_RE_B__USDHC2_CLK		0x10069
+				MX6UL_PAD_NAND_WE_B__USDHC2_CMD		0x17059
+				MX6UL_PAD_NAND_ALE__USDHC2_RESET_B	0x10069
+				MX6UL_PAD_NAND_DATA00__USDHC2_DATA0	0x17059
+				MX6UL_PAD_NAND_DATA01__USDHC2_DATA1	0x17059
+				MX6UL_PAD_NAND_DATA02__USDHC2_DATA2	0x17059
+				MX6UL_PAD_NAND_DATA03__USDHC2_DATA3	0x17059
+				MX6UL_PAD_NAND_DATA04__USDHC2_DATA4	0x17059
+				MX6UL_PAD_NAND_DATA05__USDHC2_DATA5	0x17059
+				MX6UL_PAD_NAND_DATA06__USDHC2_DATA6	0x17059
+				MX6UL_PAD_NAND_DATA07__USDHC2_DATA7	0x17059
+			>;
+		};
+
+		pinctrl_usdhc2_8bit: usdhc2grp_8bit {
+			fsl,pins = <
+				MX6UL_PAD_NAND_RE_B__USDHC2_CLK		0x10069
+				MX6UL_PAD_NAND_WE_B__USDHC2_CMD		0x17059
+				MX6UL_PAD_NAND_DATA00__USDHC2_DATA0	0x17059
+				MX6UL_PAD_NAND_DATA01__USDHC2_DATA1	0x17059
+				MX6UL_PAD_NAND_DATA02__USDHC2_DATA2	0x17059
+				MX6UL_PAD_NAND_DATA03__USDHC2_DATA3	0x17059
+				MX6UL_PAD_NAND_DATA04__USDHC2_DATA4	0x17059
+				MX6UL_PAD_NAND_DATA05__USDHC2_DATA5	0x17059
+				MX6UL_PAD_NAND_DATA06__USDHC2_DATA6	0x17059
+				MX6UL_PAD_NAND_DATA07__USDHC2_DATA7	0x17059
+			>;
+		};
+
+		pinctrl_usdhc2_8bit_100mhz: usdhc2grp_8bit_100mhz {
+			fsl,pins = <
+				MX6UL_PAD_NAND_RE_B__USDHC2_CLK		0x100b9
+				MX6UL_PAD_NAND_WE_B__USDHC2_CMD		0x170b9
+				MX6UL_PAD_NAND_DATA00__USDHC2_DATA0	0x170b9
+				MX6UL_PAD_NAND_DATA01__USDHC2_DATA1	0x170b9
+				MX6UL_PAD_NAND_DATA02__USDHC2_DATA2	0x170b9
+				MX6UL_PAD_NAND_DATA03__USDHC2_DATA3	0x170b9
+				MX6UL_PAD_NAND_DATA04__USDHC2_DATA4	0x170b9
+				MX6UL_PAD_NAND_DATA05__USDHC2_DATA5	0x170b9
+				MX6UL_PAD_NAND_DATA06__USDHC2_DATA6	0x170b9
+				MX6UL_PAD_NAND_DATA07__USDHC2_DATA7	0x170b9
+			>;
+		};
+
+		pinctrl_usdhc2_8bit_200mhz: usdhc2grp_8bit_200mhz {
+			fsl,pins = <
+				MX6UL_PAD_NAND_RE_B__USDHC2_CLK		0x100f9
+				MX6UL_PAD_NAND_WE_B__USDHC2_CMD		0x170f9
+				MX6UL_PAD_NAND_DATA00__USDHC2_DATA0	0x170f9
+				MX6UL_PAD_NAND_DATA01__USDHC2_DATA1	0x170f9
+				MX6UL_PAD_NAND_DATA02__USDHC2_DATA2	0x170f9
+				MX6UL_PAD_NAND_DATA03__USDHC2_DATA3	0x170f9
+				MX6UL_PAD_NAND_DATA04__USDHC2_DATA4	0x170f9
+				MX6UL_PAD_NAND_DATA05__USDHC2_DATA5	0x170f9
+				MX6UL_PAD_NAND_DATA06__USDHC2_DATA6	0x170f9
+				MX6UL_PAD_NAND_DATA07__USDHC2_DATA7	0x170f9
+			>;
+		};
+
+		pinctrl_wdog: pinctrl_wdog {
+			fsl,pins = <
+				MX6UL_PAD_GPIO1_IO08__WDOG1_WDOG_B	0x30b0
+			>;
+		};
+
+		pinctrl_adc1: adc1grp {
+			fsl,pins = <
+				MX6UL_PAD_GPIO1_IO01__GPIO1_IO01	0x000b0
+			>;
+		};
+	};
+};
+
+/* Cellular Module */
+&uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1>;
+	fsl,uart-has-rtscts;
+	cts-gpios = <&gpio1 18 GPIO_ACTIVE_LOW>;
+	rts-gpios = <&gpio1 19 GPIO_ACTIVE_LOW>;
+	status = "okay";
+};
+
+/* Debug interface of Cellular module */
+&uart2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart2>;
+	status = "okay";
+};
+
+/* GNSS Module */
+&uart3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart3>;
+	status = "okay";
+};
+
+&uart4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart4>;
+	status = "okay";
+};
+
+&uart5 {
+	pinctrl-names = "default";
+	status = "okay";
+};
+
+&uart6 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart6>;
+	status = "okay";
+};
+
+&usbotg1 {
+	dr_mode = "host";
+	disable-over-current;
+	status = "okay";
+};
+
+&usbotg2 {
+	dr_mode = "host";
+	disable-over-current;
+	status = "okay";
+};
+
+/* WiFi + BT Module */
+&usdhc1 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc1>;
+	non-removable;
+	no-1-8-v;
+	voltage-ranges = <3200 3400>;
+
+	vqmmc-supply = <&reg_3p3v_wifi>;
+	vmmc-supply = <&reg_sd1_vmmc_wifi>;
+	pm-ignore-notify;
+	wifi-host;
+
+	keep-power-in-suspend;
+	enable-sdio-wakeup;
+	iw-esdhc-prop;
+	status = "okay";
+
+	brcmf: bcrmf@1 {
+		reg = <1>;
+		compatible = "brcm,bcm4329-fmac";
+		interrupt-names = "host-wake";
+	};
+};
+
+/* eMMC */
+&usdhc2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc2>;
+	voltage-ranges = <3200 3400>;
+	vqmmc-supply = <&reg_3p3v>;
+	vmmc-supply = <&reg_sd1_vmmc>;
+	bus-width = <4>;
+	enable-sdio-wakeup;
+	keep-power-in-suspend;
+	no-1-8-v;
+	iw-esdhc-prop;
+	status = "okay";
+};
+
+&wdog1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_wdog>;
+	fsl,ext-reset-output;
+	iw-wdog-prop;
+	status = "okay";
+};
+
+&adc1 {
+	pinctrl-names = "default";
+	num-channels = <7>;
+	pinctrl-0 = <&pinctrl_adc1>;
+	status = "okay";
+};
+
+&fec2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_enet2>;
+	phy-mode = "rmii";
+	phy-handle = <&ethphy0>;
+	status = "okay";
+
+	mdio {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ethphy0: ethernet-phy@4 {
+			compatible = "ethernet-phy-ieee802.3-c22";
+			max-speed = <100>;
+			reg = <4>;
+		};
+	};
+};
diff -Naur A/arch/arm/boot/dts/Makefile B/arch/arm/boot/dts/Makefile
--- A/arch/arm/boot/dts/Makefile	2022-06-30 18:05:15.000000000 +0530
+++ B/arch/arm/boot/dts/Makefile	2022-08-09 13:36:04.266484110 +0530
@@ -653,6 +653,8 @@
 	imx6ulz-14x14-evk-btwifi.dtb \
 	imx6ulz-14x14-evk-gpmi-weim.dtb \
 	imx6ulz-14x14-evk-emmc.dtb
+dtb-$(CONFIG_SOC_IMX6ULL_IWG26I) += \
+	imx6ull-iwg26i.dtb
 dtb-$(CONFIG_SOC_IMX7D) += \
 	imx7d-cl-som-imx7.dtb \
 	imx7d-colibri-emmc-eval-v3.dtb \
diff -Naur A/arch/arm/configs/imx6ull_iwg26i_defconfig B/arch/arm/configs/imx6ull_iwg26i_defconfig
--- A/arch/arm/configs/imx6ull_iwg26i_defconfig	1970-01-01 05:30:00.000000000 +0530
+++ B/arch/arm/configs/imx6ull_iwg26i_defconfig	2022-08-09 13:36:04.266484110 +0530
@@ -0,0 +1,4974 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/arm 5.4.70 Kernel Configuration
+#
+
+#
+# Compiler: arm-poky-linux-gnueabi-gcc (GCC) 9.2.0
+#
+CONFIG_CC_IS_GCC=y
+CONFIG_GCC_VERSION=90200
+CONFIG_CLANG_VERSION=0
+CONFIG_CC_HAS_ASM_GOTO=y
+CONFIG_CC_HAS_ASM_INLINE=y
+CONFIG_IRQ_WORK=y
+CONFIG_BUILDTIME_EXTABLE_SORT=y
+
+#
+# General setup
+#
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+# CONFIG_COMPILE_TEST is not set
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_BUILD_SALT=""
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_HAVE_KERNEL_LZ4=y
+# CONFIG_KERNEL_GZIP is not set
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_XZ is not set
+CONFIG_KERNEL_LZO=y
+# CONFIG_KERNEL_LZ4 is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+CONFIG_CROSS_MEMORY_ATTACH=y
+# CONFIG_USELIB is not set
+# CONFIG_AUDIT is not set
+CONFIG_HAVE_ARCH_AUDITSYSCALL=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_IRQ_SHOW_LEVEL=y
+CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_CHIP=y
+CONFIG_IRQ_DOMAIN=y
+CONFIG_IRQ_DOMAIN_HIERARCHY=y
+CONFIG_HANDLE_DOMAIN_IRQ=y
+CONFIG_IRQ_FORCED_THREADING=y
+CONFIG_SPARSE_IRQ=y
+# CONFIG_GENERIC_IRQ_DEBUGFS is not set
+# end of IRQ subsystem
+
+CONFIG_GENERIC_IRQ_MULTI_HANDLER=y
+CONFIG_ARCH_CLOCKSOURCE_DATA=y
+CONFIG_GENERIC_TIME_VSYSCALL=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+
+#
+# Timers subsystem
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ_COMMON=y
+# CONFIG_HZ_PERIODIC is not set
+CONFIG_NO_HZ_IDLE=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+# end of Timers subsystem
+
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_PREEMPT_COUNT=y
+CONFIG_PREEMPTION=y
+
+#
+# CPU/Task time and stats accounting
+#
+CONFIG_TICK_CPU_ACCOUNTING=y
+# CONFIG_VIRT_CPU_ACCOUNTING_GEN is not set
+# CONFIG_IRQ_TIME_ACCOUNTING is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_PSI is not set
+# end of CPU/Task time and stats accounting
+
+#
+# RCU Subsystem
+#
+CONFIG_PREEMPT_RCU=y
+# CONFIG_RCU_EXPERT is not set
+CONFIG_SRCU=y
+CONFIG_TREE_SRCU=y
+CONFIG_TASKS_RCU=y
+CONFIG_RCU_STALL_COMMON=y
+CONFIG_RCU_NEED_SEGCBLIST=y
+# end of RCU Subsystem
+
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+# CONFIG_IKHEADERS is not set
+CONFIG_LOG_BUF_SHIFT=18
+CONFIG_PRINTK_SAFE_LOG_BUF_SHIFT=13
+CONFIG_GENERIC_SCHED_CLOCK=y
+
+#
+# Scheduler features
+#
+# end of Scheduler features
+
+CONFIG_CGROUPS=y
+CONFIG_PAGE_COUNTER=y
+CONFIG_MEMCG=y
+# CONFIG_MEMCG_SWAP is not set
+CONFIG_MEMCG_KMEM=y
+# CONFIG_BLK_CGROUP is not set
+# CONFIG_CGROUP_SCHED is not set
+# CONFIG_CGROUP_PIDS is not set
+# CONFIG_CGROUP_RDMA is not set
+# CONFIG_CGROUP_FREEZER is not set
+CONFIG_CGROUP_DEVICE=y
+# CONFIG_CGROUP_CPUACCT is not set
+# CONFIG_CGROUP_PERF is not set
+# CONFIG_CGROUP_DEBUG is not set
+CONFIG_NAMESPACES=y
+CONFIG_UTS_NS=y
+CONFIG_IPC_NS=y
+CONFIG_USER_NS=y
+CONFIG_PID_NS=y
+CONFIG_NET_NS=y
+# CONFIG_CHECKPOINT_RESTORE is not set
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_RD_LZ4 is not set
+CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_HAVE_UID16=y
+CONFIG_BPF=y
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+CONFIG_MULTIUSER=y
+# CONFIG_SGETMASK_SYSCALL is not set
+CONFIG_SYSFS_SYSCALL=y
+# CONFIG_SYSCTL_SYSCALL is not set
+CONFIG_FHANDLE=y
+CONFIG_POSIX_TIMERS=y
+CONFIG_PRINTK=y
+CONFIG_PRINTK_NMI=y
+CONFIG_BUG=y
+# CONFIG_ELF_CORE is not set
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_FUTEX_PI=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_IO_URING=y
+CONFIG_ADVISE_SYSCALLS=y
+CONFIG_MEMBARRIER=y
+# CONFIG_KALLSYMS is not set
+# CONFIG_BPF_SYSCALL is not set
+# CONFIG_USERFAULTFD is not set
+CONFIG_ARCH_HAS_MEMBARRIER_SYNC_CORE=y
+CONFIG_RSEQ=y
+# CONFIG_DEBUG_RSEQ is not set
+# CONFIG_EMBEDDED is not set
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+# CONFIG_PC104 is not set
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+# end of Kernel Performance Events And Counters
+
+CONFIG_VM_EVENT_COUNTERS=y
+# CONFIG_SLUB_DEBUG is not set
+# CONFIG_SLUB_MEMCG_SYSFS_ON is not set
+# CONFIG_COMPAT_BRK is not set
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+CONFIG_SLAB_MERGE_DEFAULT=y
+# CONFIG_SLAB_FREELIST_RANDOM is not set
+# CONFIG_SLAB_FREELIST_HARDENED is not set
+# CONFIG_SHUFFLE_PAGE_ALLOCATOR is not set
+CONFIG_SYSTEM_DATA_VERIFICATION=y
+# CONFIG_PROFILING is not set
+# end of General setup
+
+CONFIG_ARM=y
+CONFIG_ARM_HAS_SG_CHAIN=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ARCH_SUPPORTS_UPROBES=y
+CONFIG_ARM_PATCH_PHYS_VIRT=y
+CONFIG_GENERIC_BUG=y
+CONFIG_PGTABLE_LEVELS=2
+
+#
+# System Type
+#
+CONFIG_MMU=y
+CONFIG_ARCH_MMAP_RND_BITS_MIN=8
+CONFIG_ARCH_MMAP_RND_BITS_MAX=15
+CONFIG_ARCH_MULTIPLATFORM=y
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C24XX is not set
+# CONFIG_ARCH_OMAP1 is not set
+
+#
+# Multiple platform selection
+#
+
+#
+# CPU Core family selection
+#
+# CONFIG_ARCH_MULTI_V6 is not set
+CONFIG_ARCH_MULTI_V7=y
+CONFIG_ARCH_MULTI_V6_V7=y
+# end of Multiple platform selection
+
+# CONFIG_ARCH_VIRT is not set
+# CONFIG_ARCH_ACTIONS is not set
+# CONFIG_ARCH_ALPINE is not set
+# CONFIG_ARCH_ARTPEC is not set
+# CONFIG_ARCH_ASPEED is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_BCM is not set
+# CONFIG_ARCH_BERLIN is not set
+# CONFIG_ARCH_DIGICOLOR is not set
+# CONFIG_ARCH_EXYNOS is not set
+# CONFIG_ARCH_HIGHBANK is not set
+# CONFIG_ARCH_HISI is not set
+CONFIG_ARCH_MXC=y
+CONFIG_MXC_TZIC=y
+CONFIG_HAVE_IMX_ANATOP=y
+CONFIG_HAVE_IMX_GPC=y
+CONFIG_HAVE_IMX_GPCV2=y
+CONFIG_HAVE_IMX_MMDC=y
+CONFIG_HAVE_IMX_AMP=y
+CONFIG_HAVE_IMX_DDRC=y
+CONFIG_HAVE_IMX_BUSFREQ=y
+CONFIG_HAVE_IMX_MU=y
+CONFIG_HAVE_IMX_RPMSG=y
+CONFIG_HAVE_IMX_SRC=y
+
+#
+# Device tree only
+#
+
+#
+# Cortex-A platforms
+#
+CONFIG_SOC_IMX5=y
+CONFIG_SOC_IMX50=y
+# CONFIG_SOC_IMX51 is not set
+CONFIG_SOC_IMX53=y
+CONFIG_SOC_IMX6=y
+CONFIG_SOC_IMX6Q=y
+CONFIG_SOC_IMX6SL=y
+CONFIG_SOC_IMX6SLL=y
+CONFIG_SOC_IMX6SX=y
+CONFIG_SOC_IMX6UL=y
+CONFIG_SOC_IMX6ULL_IWG26I=y
+CONFIG_MX6ULL_IWG26I=y
+# CONFIG_SOC_LS1021A is not set
+
+#
+# Cortex-A/Cortex-M asymmetric multiprocessing platforms
+#
+CONFIG_SOC_IMX7D_CA7=y
+CONFIG_SOC_IMX7D=y
+CONFIG_SOC_IMX7ULP=y
+CONFIG_SOC_VF610=y
+CONFIG_VF_USE_ARM_GLOBAL_TIMER=y
+# CONFIG_VF_USE_PIT_TIMER is not set
+# CONFIG_ARCH_KEYSTONE is not set
+# CONFIG_ARCH_MEDIATEK is not set
+# CONFIG_ARCH_MESON is not set
+# CONFIG_ARCH_MILBEAUT is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_MVEBU is not set
+# CONFIG_ARCH_NPCM is not set
+
+#
+# TI OMAP/AM/DM/DRA Family
+#
+# CONFIG_ARCH_OMAP3 is not set
+# CONFIG_ARCH_OMAP4 is not set
+# CONFIG_SOC_OMAP5 is not set
+# CONFIG_SOC_AM33XX is not set
+# CONFIG_SOC_AM43XX is not set
+# CONFIG_SOC_DRA7XX is not set
+# end of TI OMAP/AM/DM/DRA Family
+
+# CONFIG_ARCH_SIRF is not set
+# CONFIG_ARCH_QCOM is not set
+# CONFIG_ARCH_RDA is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_ROCKCHIP is not set
+# CONFIG_ARCH_S5PV210 is not set
+# CONFIG_ARCH_RENESAS is not set
+# CONFIG_ARCH_SOCFPGA is not set
+# CONFIG_PLAT_SPEAR is not set
+# CONFIG_ARCH_STI is not set
+# CONFIG_ARCH_STM32 is not set
+# CONFIG_ARCH_SUNXI is not set
+# CONFIG_ARCH_TANGO is not set
+# CONFIG_ARCH_TEGRA is not set
+# CONFIG_ARCH_UNIPHIER is not set
+# CONFIG_ARCH_U8500 is not set
+# CONFIG_ARCH_VEXPRESS is not set
+# CONFIG_ARCH_WM8850 is not set
+# CONFIG_ARCH_ZX is not set
+# CONFIG_ARCH_ZYNQ is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_V7=y
+CONFIG_CPU_THUMB_CAPABLE=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_32v7=y
+CONFIG_CPU_ABRT_EV7=y
+CONFIG_CPU_PABRT_V7=y
+CONFIG_CPU_CACHE_V7=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V7=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_LPAE is not set
+CONFIG_ARM_THUMB=y
+# CONFIG_ARM_THUMBEE is not set
+CONFIG_ARM_VIRT_EXT=y
+# CONFIG_SWP_EMULATE is not set
+# CONFIG_CPU_BIG_ENDIAN is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_CPU_SPECTRE=y
+CONFIG_HARDEN_BRANCH_PREDICTOR=y
+CONFIG_KUSER_HELPERS=y
+CONFIG_VDSO=y
+CONFIG_OUTER_CACHE=y
+CONFIG_OUTER_CACHE_SYNC=y
+CONFIG_MIGHT_HAVE_CACHE_L2X0=y
+CONFIG_CACHE_L2X0=y
+# CONFIG_CACHE_L2X0_PMU is not set
+# CONFIG_PL310_ERRATA_588369 is not set
+# CONFIG_PL310_ERRATA_727915 is not set
+# CONFIG_PL310_ERRATA_753970 is not set
+CONFIG_PL310_ERRATA_769419=y
+CONFIG_ARM_L1_CACHE_SHIFT_6=y
+CONFIG_ARM_L1_CACHE_SHIFT=6
+CONFIG_ARM_DMA_MEM_BUFFERABLE=y
+CONFIG_ARM_HEAVY_MB=y
+CONFIG_ARCH_SUPPORTS_BIG_ENDIAN=y
+CONFIG_DEBUG_ALIGN_RODATA=y
+# CONFIG_ARM_ERRATA_430973 is not set
+# CONFIG_ARM_ERRATA_720789 is not set
+CONFIG_ARM_ERRATA_754322=y
+CONFIG_ARM_ERRATA_775420=y
+# CONFIG_ARM_ERRATA_773022 is not set
+# CONFIG_ARM_ERRATA_818325_852422 is not set
+# CONFIG_ARM_ERRATA_821420 is not set
+# CONFIG_ARM_ERRATA_825619 is not set
+# CONFIG_ARM_ERRATA_857271 is not set
+# CONFIG_ARM_ERRATA_852421 is not set
+# CONFIG_ARM_ERRATA_852423 is not set
+# CONFIG_ARM_ERRATA_857272 is not set
+# end of System Type
+
+#
+# Bus support
+#
+CONFIG_ARM_ERRATA_814220=y
+# end of Bus support
+
+#
+# Kernel Features
+#
+CONFIG_HAVE_SMP=y
+# CONFIG_SMP is not set
+CONFIG_HAVE_ARM_ARCH_TIMER=y
+CONFIG_HAVE_ARM_TWD=y
+# CONFIG_VMSPLIT_3G is not set
+# CONFIG_VMSPLIT_3G_OPT is not set
+CONFIG_VMSPLIT_2G=y
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0x80000000
+CONFIG_ARM_PSCI=y
+CONFIG_ARCH_NR_GPIO=0
+CONFIG_HZ_FIXED=0
+CONFIG_HZ_100=y
+# CONFIG_HZ_200 is not set
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_500 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=100
+CONFIG_SCHED_HRTICK=y
+# CONFIG_THUMB2_KERNEL is not set
+CONFIG_ARM_PATCH_IDIV=y
+CONFIG_AEABI=y
+# CONFIG_OABI_COMPAT is not set
+CONFIG_HAVE_ARCH_PFN_VALID=y
+CONFIG_HIGHMEM=y
+CONFIG_HIGHPTE=y
+CONFIG_CPU_SW_DOMAIN_PAN=y
+CONFIG_HW_PERF_EVENTS=y
+CONFIG_ARCH_WANT_GENERAL_HUGETLB=y
+# CONFIG_ARM_MODULE_PLTS is not set
+CONFIG_FORCE_MAX_ZONEORDER=14
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+CONFIG_SECCOMP=y
+# CONFIG_PARAVIRT is not set
+# CONFIG_PARAVIRT_TIME_ACCOUNTING is not set
+# CONFIG_XEN is not set
+# end of Kernel Features
+
+#
+# Boot options
+#
+CONFIG_USE_OF=y
+CONFIG_ATAGS=y
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+# CONFIG_ARM_APPENDED_DTB is not set
+CONFIG_CMDLINE="noinitrd console=ttymxc4,115200"
+CONFIG_CMDLINE_FROM_BOOTLOADER=y
+# CONFIG_CMDLINE_EXTEND is not set
+# CONFIG_CMDLINE_FORCE is not set
+# CONFIG_KEXEC is not set
+# CONFIG_CRASH_DUMP is not set
+CONFIG_AUTO_ZRELADDR=y
+# CONFIG_EFI is not set
+# end of Boot options
+
+#
+# CPU Power Management
+#
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_GOV_ATTR_SET=y
+CONFIG_CPU_FREQ_GOV_COMMON=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
+
+#
+# CPU frequency scaling drivers
+#
+# CONFIG_CPUFREQ_DT is not set
+CONFIG_ARM_IMX6Q_CPUFREQ=y
+CONFIG_ARM_IMX7ULP_CPUFREQ=y
+# CONFIG_QORIQ_CPUFREQ is not set
+# end of CPU Frequency scaling
+
+#
+# CPU Idle
+#
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+# CONFIG_CPU_IDLE_GOV_TEO is not set
+
+#
+# ARM CPU Idle Drivers
+#
+# CONFIG_ARM_CPUIDLE is not set
+# CONFIG_ARM_PSCI_CPUIDLE is not set
+# CONFIG_ARM_HIGHBANK_CPUIDLE is not set
+# end of ARM CPU Idle Drivers
+# end of CPU Idle
+# end of CPU Power Management
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_VFP=y
+CONFIG_VFPv3=y
+CONFIG_NEON=y
+# CONFIG_KERNEL_MODE_NEON is not set
+# end of Floating point emulation
+
+#
+# Power management options
+#
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+# CONFIG_SUSPEND_SKIP_SYNC is not set
+# CONFIG_HIBERNATION is not set
+CONFIG_PM_SLEEP=y
+# CONFIG_PM_AUTOSLEEP is not set
+CONFIG_PM_WAKELOCKS=y
+CONFIG_PM_WAKELOCKS_LIMIT=0
+CONFIG_PM_WAKELOCKS_GC=y
+CONFIG_PM=y
+CONFIG_PM_DEBUG=y
+# CONFIG_PM_ADVANCED_DEBUG is not set
+# CONFIG_PM_TEST_SUSPEND is not set
+CONFIG_PM_SLEEP_DEBUG=y
+# CONFIG_APM_EMULATION is not set
+CONFIG_PM_CLK=y
+CONFIG_PM_GENERIC_DOMAINS=y
+# CONFIG_WQ_POWER_EFFICIENT_DEFAULT is not set
+CONFIG_PM_GENERIC_DOMAINS_SLEEP=y
+CONFIG_PM_GENERIC_DOMAINS_OF=y
+CONFIG_CPU_PM=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ARM_CPU_SUSPEND=y
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+# end of Power management options
+
+#
+# Firmware Drivers
+#
+# CONFIG_FIRMWARE_MEMMAP is not set
+# CONFIG_FW_CFG_SYSFS is not set
+# CONFIG_TRUSTED_FOUNDATIONS is not set
+CONFIG_HAVE_ARM_SMCCC=y
+CONFIG_ARM_PSCI_FW=y
+# CONFIG_GOOGLE_FIRMWARE is not set
+
+#
+# Tegra firmware driver
+#
+# end of Tegra firmware driver
+# end of Firmware Drivers
+
+# CONFIG_ARM_CRYPTO is not set
+# CONFIG_VIRTUALIZATION is not set
+
+#
+# General architecture-dependent options
+#
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+# CONFIG_JUMP_LABEL is not set
+CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
+CONFIG_ARCH_USE_BUILTIN_BSWAP=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_OPTPROBES=y
+CONFIG_HAVE_NMI=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_GENERIC_IDLE_POLL_SETUP=y
+CONFIG_ARCH_HAS_FORTIFY_SOURCE=y
+CONFIG_ARCH_HAS_KEEPINITRD=y
+CONFIG_ARCH_HAS_SET_MEMORY=y
+CONFIG_HAVE_ARCH_THREAD_STRUCT_WHITELIST=y
+CONFIG_ARCH_32BIT_OFF_T=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_RSEQ=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_HW_BREAKPOINT=y
+CONFIG_HAVE_PERF_REGS=y
+CONFIG_HAVE_PERF_USER_STACK_DUMP=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_ARCH_WANT_IPC_PARSE_VERSION=y
+CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
+CONFIG_SECCOMP_FILTER=y
+CONFIG_HAVE_STACKPROTECTOR=y
+CONFIG_CC_HAS_STACKPROTECTOR_NONE=y
+CONFIG_STACKPROTECTOR=y
+CONFIG_STACKPROTECTOR_STRONG=y
+CONFIG_HAVE_CONTEXT_TRACKING=y
+CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN=y
+CONFIG_HAVE_IRQ_TIME_ACCOUNTING=y
+CONFIG_HAVE_MOD_ARCH_SPECIFIC=y
+CONFIG_MODULES_USE_ELF_REL=y
+CONFIG_ARCH_HAS_ELF_RANDOMIZE=y
+CONFIG_HAVE_ARCH_MMAP_RND_BITS=y
+CONFIG_HAVE_EXIT_THREAD=y
+CONFIG_ARCH_MMAP_RND_BITS=8
+CONFIG_ARCH_WANT_DEFAULT_TOPDOWN_MMAP_LAYOUT=y
+CONFIG_HAVE_COPY_THREAD_TLS=y
+CONFIG_CLONE_BACKWARDS=y
+CONFIG_OLD_SIGSUSPEND3=y
+CONFIG_OLD_SIGACTION=y
+CONFIG_64BIT_TIME=y
+CONFIG_COMPAT_32BIT_TIME=y
+CONFIG_ARCH_OPTIONAL_KERNEL_RWX=y
+CONFIG_ARCH_OPTIONAL_KERNEL_RWX_DEFAULT=y
+CONFIG_ARCH_HAS_STRICT_KERNEL_RWX=y
+CONFIG_STRICT_KERNEL_RWX=y
+CONFIG_ARCH_HAS_STRICT_MODULE_RWX=y
+CONFIG_STRICT_MODULE_RWX=y
+CONFIG_ARCH_HAS_PHYS_TO_DMA=y
+CONFIG_REFCOUNT_FULL=y
+# CONFIG_LOCK_EVENT_COUNTS is not set
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_ARCH_HAS_GCOV_PROFILE_ALL=y
+# end of GCOV-based kernel profiling
+
+CONFIG_PLUGIN_HOSTCC=""
+CONFIG_HAVE_GCC_PLUGINS=y
+# end of General architecture-dependent options
+
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+# CONFIG_MODULE_SIG is not set
+# CONFIG_MODULE_COMPRESS is not set
+# CONFIG_MODULE_ALLOW_MISSING_NAMESPACE_IMPORTS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_TRIM_UNUSED_KSYMS is not set
+CONFIG_MODULES_TREE_LOOKUP=y
+CONFIG_BLOCK=y
+CONFIG_BLK_SCSI_REQUEST=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_BSGLIB is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+# CONFIG_BLK_DEV_ZONED is not set
+# CONFIG_BLK_CMDLINE_PARSER is not set
+# CONFIG_BLK_WBT is not set
+CONFIG_BLK_DEBUG_FS=y
+# CONFIG_BLK_SED_OPAL is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_EFI_PARTITION=y
+# end of Partition Types
+
+CONFIG_BLK_PM=y
+
+#
+# IO Schedulers
+#
+CONFIG_MQ_IOSCHED_DEADLINE=y
+CONFIG_MQ_IOSCHED_KYBER=y
+# CONFIG_IOSCHED_BFQ is not set
+# end of IO Schedulers
+
+CONFIG_ASN1=y
+CONFIG_UNINLINE_SPIN_UNLOCK=y
+CONFIG_ARCH_SUPPORTS_ATOMIC_RMW=y
+CONFIG_FREEZER=y
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_ELF_FDPIC is not set
+CONFIG_ELFCORE=y
+CONFIG_BINFMT_SCRIPT=y
+CONFIG_ARCH_HAS_BINFMT_FLAT=y
+# CONFIG_BINFMT_FLAT is not set
+CONFIG_BINFMT_FLAT_ARGVP_ENVP_ON_STACK=y
+CONFIG_BINFMT_MISC=m
+CONFIG_COREDUMP=y
+# end of Executable file formats
+
+#
+# Memory Management options
+#
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_ARCH_KEEP_MEMBLOCK=y
+CONFIG_MEMORY_ISOLATION=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_COMPACTION=y
+CONFIG_MIGRATION=y
+CONFIG_CONTIG_ALLOC=y
+CONFIG_BOUNCE=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_NEED_PER_CPU_KM=y
+# CONFIG_CLEANCACHE is not set
+# CONFIG_FRONTSWAP is not set
+CONFIG_CMA=y
+# CONFIG_CMA_DEBUG is not set
+# CONFIG_CMA_DEBUGFS is not set
+CONFIG_CMA_AREAS=7
+# CONFIG_ZPOOL is not set
+# CONFIG_ZBUD is not set
+# CONFIG_ZSMALLOC is not set
+CONFIG_GENERIC_EARLY_IOREMAP=y
+# CONFIG_IDLE_PAGE_TRACKING is not set
+# CONFIG_PERCPU_STATS is not set
+# CONFIG_GUP_BENCHMARK is not set
+# end of Memory Management options
+
+CONFIG_NET=y
+CONFIG_NET_INGRESS=y
+CONFIG_SKB_EXTENSIONS=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_DIAG is not set
+CONFIG_UNIX=y
+CONFIG_UNIX_SCM=y
+# CONFIG_UNIX_DIAG is not set
+# CONFIG_TLS is not set
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_INTERFACE is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+CONFIG_NET_IP_TUNNEL=y
+CONFIG_SYN_COOKIES=y
+# CONFIG_NET_IPVTI is not set
+# CONFIG_NET_FOU is not set
+# CONFIG_NET_FOU_IP_TUNNELS is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+CONFIG_INET_TUNNEL=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_INET_UDP_DIAG is not set
+# CONFIG_INET_RAW_DIAG is not set
+# CONFIG_INET_DIAG_DESTROY is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IPV6=y
+# CONFIG_IPV6_ROUTER_PREF is not set
+# CONFIG_IPV6_OPTIMISTIC_DAD is not set
+# CONFIG_INET6_AH is not set
+# CONFIG_INET6_ESP is not set
+# CONFIG_INET6_IPCOMP is not set
+# CONFIG_IPV6_MIP6 is not set
+# CONFIG_IPV6_ILA is not set
+CONFIG_INET6_TUNNEL=y
+CONFIG_IPV6_VTI=y
+CONFIG_IPV6_SIT=y
+CONFIG_IPV6_SIT_6RD=y
+CONFIG_IPV6_NDISC_NODETYPE=y
+CONFIG_IPV6_TUNNEL=y
+# CONFIG_IPV6_MULTIPLE_TABLES is not set
+# CONFIG_IPV6_MROUTE is not set
+# CONFIG_IPV6_SEG6_LWTUNNEL is not set
+# CONFIG_IPV6_SEG6_HMAC is not set
+# CONFIG_NETWORK_SECMARK is not set
+CONFIG_NET_PTP_CLASSIFY=y
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+CONFIG_NETFILTER=y
+CONFIG_NETFILTER_ADVANCED=y
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_INGRESS=y
+CONFIG_NETFILTER_NETLINK=y
+CONFIG_NETFILTER_FAMILY_ARP=y
+# CONFIG_NETFILTER_NETLINK_ACCT is not set
+# CONFIG_NETFILTER_NETLINK_QUEUE is not set
+# CONFIG_NETFILTER_NETLINK_LOG is not set
+# CONFIG_NETFILTER_NETLINK_OSF is not set
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_LOG_COMMON=y
+# CONFIG_NF_LOG_NETDEV is not set
+CONFIG_NF_CONNTRACK_MARK=y
+# CONFIG_NF_CONNTRACK_ZONES is not set
+CONFIG_NF_CONNTRACK_PROCFS=y
+# CONFIG_NF_CONNTRACK_EVENTS is not set
+# CONFIG_NF_CONNTRACK_TIMEOUT is not set
+# CONFIG_NF_CONNTRACK_TIMESTAMP is not set
+# CONFIG_NF_CONNTRACK_LABELS is not set
+CONFIG_NF_CT_PROTO_DCCP=y
+CONFIG_NF_CT_PROTO_SCTP=y
+CONFIG_NF_CT_PROTO_UDPLITE=y
+# CONFIG_NF_CONNTRACK_AMANDA is not set
+# CONFIG_NF_CONNTRACK_FTP is not set
+# CONFIG_NF_CONNTRACK_H323 is not set
+# CONFIG_NF_CONNTRACK_IRC is not set
+# CONFIG_NF_CONNTRACK_NETBIOS_NS is not set
+# CONFIG_NF_CONNTRACK_SNMP is not set
+# CONFIG_NF_CONNTRACK_PPTP is not set
+# CONFIG_NF_CONNTRACK_SANE is not set
+# CONFIG_NF_CONNTRACK_SIP is not set
+# CONFIG_NF_CONNTRACK_TFTP is not set
+# CONFIG_NF_CT_NETLINK is not set
+CONFIG_NF_NAT=y
+CONFIG_NF_NAT_REDIRECT=y
+CONFIG_NF_NAT_MASQUERADE=y
+CONFIG_NETFILTER_SYNPROXY=y
+CONFIG_NF_TABLES=y
+# CONFIG_NF_TABLES_SET is not set
+CONFIG_NF_TABLES_INET=y
+# CONFIG_NF_TABLES_NETDEV is not set
+# CONFIG_NFT_NUMGEN is not set
+# CONFIG_NFT_CT is not set
+# CONFIG_NFT_COUNTER is not set
+# CONFIG_NFT_CONNLIMIT is not set
+# CONFIG_NFT_LOG is not set
+# CONFIG_NFT_LIMIT is not set
+# CONFIG_NFT_MASQ is not set
+# CONFIG_NFT_REDIR is not set
+# CONFIG_NFT_NAT is not set
+# CONFIG_NFT_TUNNEL is not set
+# CONFIG_NFT_OBJREF is not set
+# CONFIG_NFT_QUOTA is not set
+# CONFIG_NFT_REJECT is not set
+# CONFIG_NFT_COMPAT is not set
+# CONFIG_NFT_HASH is not set
+# CONFIG_NFT_XFRM is not set
+# CONFIG_NFT_SOCKET is not set
+# CONFIG_NFT_OSF is not set
+# CONFIG_NFT_TPROXY is not set
+# CONFIG_NFT_SYNPROXY is not set
+# CONFIG_NF_FLOW_TABLE is not set
+CONFIG_NETFILTER_XTABLES=y
+
+#
+# Xtables combined modules
+#
+# CONFIG_NETFILTER_XT_MARK is not set
+# CONFIG_NETFILTER_XT_CONNMARK is not set
+
+#
+# Xtables targets
+#
+# CONFIG_NETFILTER_XT_TARGET_CHECKSUM is not set
+# CONFIG_NETFILTER_XT_TARGET_CLASSIFY is not set
+# CONFIG_NETFILTER_XT_TARGET_CONNMARK is not set
+# CONFIG_NETFILTER_XT_TARGET_CT is not set
+# CONFIG_NETFILTER_XT_TARGET_DSCP is not set
+CONFIG_NETFILTER_XT_TARGET_HL=y
+# CONFIG_NETFILTER_XT_TARGET_HMARK is not set
+# CONFIG_NETFILTER_XT_TARGET_IDLETIMER is not set
+# CONFIG_NETFILTER_XT_TARGET_LED is not set
+# CONFIG_NETFILTER_XT_TARGET_LOG is not set
+# CONFIG_NETFILTER_XT_TARGET_MARK is not set
+CONFIG_NETFILTER_XT_NAT=y
+CONFIG_NETFILTER_XT_TARGET_NETMAP=y
+# CONFIG_NETFILTER_XT_TARGET_NFLOG is not set
+# CONFIG_NETFILTER_XT_TARGET_NFQUEUE is not set
+# CONFIG_NETFILTER_XT_TARGET_NOTRACK is not set
+# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
+CONFIG_NETFILTER_XT_TARGET_REDIRECT=y
+CONFIG_NETFILTER_XT_TARGET_MASQUERADE=y
+# CONFIG_NETFILTER_XT_TARGET_TEE is not set
+# CONFIG_NETFILTER_XT_TARGET_TPROXY is not set
+# CONFIG_NETFILTER_XT_TARGET_TRACE is not set
+# CONFIG_NETFILTER_XT_TARGET_TCPMSS is not set
+# CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
+
+#
+# Xtables matches
+#
+# CONFIG_NETFILTER_XT_MATCH_ADDRTYPE is not set
+# CONFIG_NETFILTER_XT_MATCH_BPF is not set
+# CONFIG_NETFILTER_XT_MATCH_CGROUP is not set
+# CONFIG_NETFILTER_XT_MATCH_CLUSTER is not set
+# CONFIG_NETFILTER_XT_MATCH_COMMENT is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNBYTES is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNLABEL is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNLIMIT is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNMARK is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNTRACK is not set
+# CONFIG_NETFILTER_XT_MATCH_CPU is not set
+# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
+# CONFIG_NETFILTER_XT_MATCH_DEVGROUP is not set
+# CONFIG_NETFILTER_XT_MATCH_DSCP is not set
+CONFIG_NETFILTER_XT_MATCH_ECN=y
+# CONFIG_NETFILTER_XT_MATCH_ESP is not set
+# CONFIG_NETFILTER_XT_MATCH_HASHLIMIT is not set
+# CONFIG_NETFILTER_XT_MATCH_HELPER is not set
+CONFIG_NETFILTER_XT_MATCH_HL=y
+# CONFIG_NETFILTER_XT_MATCH_IPCOMP is not set
+# CONFIG_NETFILTER_XT_MATCH_IPRANGE is not set
+# CONFIG_NETFILTER_XT_MATCH_L2TP is not set
+# CONFIG_NETFILTER_XT_MATCH_LENGTH is not set
+# CONFIG_NETFILTER_XT_MATCH_LIMIT is not set
+# CONFIG_NETFILTER_XT_MATCH_MAC is not set
+# CONFIG_NETFILTER_XT_MATCH_MARK is not set
+# CONFIG_NETFILTER_XT_MATCH_MULTIPORT is not set
+# CONFIG_NETFILTER_XT_MATCH_NFACCT is not set
+# CONFIG_NETFILTER_XT_MATCH_OSF is not set
+# CONFIG_NETFILTER_XT_MATCH_OWNER is not set
+# CONFIG_NETFILTER_XT_MATCH_POLICY is not set
+# CONFIG_NETFILTER_XT_MATCH_PKTTYPE is not set
+# CONFIG_NETFILTER_XT_MATCH_QUOTA is not set
+# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
+# CONFIG_NETFILTER_XT_MATCH_REALM is not set
+# CONFIG_NETFILTER_XT_MATCH_RECENT is not set
+# CONFIG_NETFILTER_XT_MATCH_SCTP is not set
+# CONFIG_NETFILTER_XT_MATCH_SOCKET is not set
+# CONFIG_NETFILTER_XT_MATCH_STATE is not set
+# CONFIG_NETFILTER_XT_MATCH_STATISTIC is not set
+# CONFIG_NETFILTER_XT_MATCH_STRING is not set
+# CONFIG_NETFILTER_XT_MATCH_TCPMSS is not set
+# CONFIG_NETFILTER_XT_MATCH_TIME is not set
+# CONFIG_NETFILTER_XT_MATCH_U32 is not set
+# end of Core Netfilter Configuration
+
+# CONFIG_IP_SET is not set
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV4=y
+# CONFIG_NF_SOCKET_IPV4 is not set
+# CONFIG_NF_TPROXY_IPV4 is not set
+CONFIG_NF_TABLES_IPV4=y
+CONFIG_NFT_DUP_IPV4=y
+# CONFIG_NFT_FIB_IPV4 is not set
+# CONFIG_NF_TABLES_ARP is not set
+CONFIG_NF_DUP_IPV4=y
+# CONFIG_NF_LOG_ARP is not set
+CONFIG_NF_LOG_IPV4=y
+CONFIG_NF_REJECT_IPV4=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_AH=y
+CONFIG_IP_NF_MATCH_ECN=y
+# CONFIG_IP_NF_MATCH_RPFILTER is not set
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_TARGET_SYNPROXY=y
+CONFIG_IP_NF_NAT=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_NETMAP=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_IP_NF_MANGLE=y
+CONFIG_IP_NF_TARGET_CLUSTERIP=y
+CONFIG_IP_NF_TARGET_ECN=y
+CONFIG_IP_NF_TARGET_TTL=y
+CONFIG_IP_NF_RAW=y
+# CONFIG_IP_NF_ARPTABLES is not set
+# end of IP: Netfilter Configuration
+
+#
+# IPv6: Netfilter Configuration
+#
+# CONFIG_NF_SOCKET_IPV6 is not set
+# CONFIG_NF_TPROXY_IPV6 is not set
+CONFIG_NF_TABLES_IPV6=y
+# CONFIG_NFT_DUP_IPV6 is not set
+# CONFIG_NFT_FIB_IPV6 is not set
+# CONFIG_NF_DUP_IPV6 is not set
+# CONFIG_NF_REJECT_IPV6 is not set
+# CONFIG_NF_LOG_IPV6 is not set
+# CONFIG_IP6_NF_IPTABLES is not set
+# end of IPv6: Netfilter Configuration
+
+CONFIG_NF_DEFRAG_IPV6=y
+# CONFIG_NF_CONNTRACK_BRIDGE is not set
+# CONFIG_BPFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+CONFIG_HAVE_NET_DSA=y
+# CONFIG_NET_DSA is not set
+CONFIG_VLAN_8021Q=y
+# CONFIG_VLAN_8021Q_GVRP is not set
+# CONFIG_VLAN_8021Q_MVRP is not set
+# CONFIG_DECNET is not set
+CONFIG_LLC=y
+CONFIG_LLC2=y
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_PHONET is not set
+# CONFIG_6LOWPAN is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+# CONFIG_TSN is not set
+CONFIG_DNS_RESOLVER=y
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+# CONFIG_VSOCKETS is not set
+# CONFIG_NETLINK_DIAG is not set
+# CONFIG_MPLS is not set
+# CONFIG_NET_NSH is not set
+# CONFIG_HSR is not set
+# CONFIG_NET_SWITCHDEV is not set
+# CONFIG_NET_L3_MASTER_DEV is not set
+# CONFIG_NET_NCSI is not set
+# CONFIG_CGROUP_NET_PRIO is not set
+# CONFIG_CGROUP_NET_CLASSID is not set
+CONFIG_NET_RX_BUSY_POLL=y
+CONFIG_BQL=y
+# CONFIG_BPF_JIT is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# end of Network testing
+# end of Networking options
+
+# CONFIG_HAMRADIO is not set
+CONFIG_CAN=y
+CONFIG_CAN_RAW=y
+CONFIG_CAN_BCM=y
+CONFIG_CAN_GW=y
+CONFIG_CAN_J1939=m
+
+#
+# CAN Device Drivers
+#
+# CONFIG_CAN_VCAN is not set
+# CONFIG_CAN_VXCAN is not set
+# CONFIG_CAN_SLCAN is not set
+CONFIG_CAN_DEV=y
+CONFIG_CAN_CALC_BITTIMING=y
+CONFIG_CAN_FLEXCAN=y
+# CONFIG_CAN_GRCAN is not set
+# CONFIG_CAN_TI_HECC is not set
+# CONFIG_CAN_C_CAN is not set
+# CONFIG_CAN_CC770 is not set
+# CONFIG_CAN_IFI_CANFD is not set
+CONFIG_CAN_M_CAN=y
+# CONFIG_CAN_M_CAN_PLATFORM is not set
+CONFIG_CAN_M_CAN_TCAN4X5X=m
+# CONFIG_CAN_RCAR is not set
+# CONFIG_CAN_RCAR_CANFD is not set
+# CONFIG_CAN_SJA1000 is not set
+# CONFIG_CAN_SOFTING is not set
+
+#
+# CAN SPI interfaces
+#
+# CONFIG_CAN_HI311X is not set
+# CONFIG_CAN_MCP251X is not set
+# end of CAN SPI interfaces
+
+#
+# CAN USB interfaces
+#
+# CONFIG_CAN_8DEV_USB is not set
+# CONFIG_CAN_EMS_USB is not set
+# CONFIG_CAN_ESD_USB2 is not set
+# CONFIG_CAN_GS_USB is not set
+# CONFIG_CAN_KVASER_USB is not set
+# CONFIG_CAN_MCBA_USB is not set
+# CONFIG_CAN_PEAK_USB is not set
+# CONFIG_CAN_UCAN is not set
+# end of CAN USB interfaces
+
+# CONFIG_CAN_DEBUG_DEVICES is not set
+# end of CAN Device Drivers
+
+CONFIG_BT=y
+CONFIG_BT_BREDR=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=y
+CONFIG_BT_BNEP_MC_FILTER=y
+CONFIG_BT_BNEP_PROTO_FILTER=y
+CONFIG_BT_HIDP=y
+CONFIG_BT_HS=y
+CONFIG_BT_LE=y
+# CONFIG_BT_LEDS is not set
+# CONFIG_BT_SELFTEST is not set
+CONFIG_BT_DEBUGFS=y
+
+#
+# Bluetooth device drivers
+#
+CONFIG_BT_INTEL=y
+CONFIG_BT_BCM=y
+CONFIG_BT_RTL=y
+CONFIG_BT_HCIBTUSB=y
+# CONFIG_BT_HCIBTUSB_AUTOSUSPEND is not set
+CONFIG_BT_HCIBTUSB_BCM=y
+# CONFIG_BT_HCIBTUSB_MTK is not set
+CONFIG_BT_HCIBTUSB_RTL=y
+# CONFIG_BT_HCIBTSDIO is not set
+CONFIG_BT_HCIUART=y
+CONFIG_BT_HCIUART_H4=y
+CONFIG_BT_HCIUART_BCSP=y
+CONFIG_BT_HCIUART_ATH3K=y
+# CONFIG_BT_HCIUART_INTEL is not set
+# CONFIG_BT_HCIUART_AG6XX is not set
+CONFIG_BT_HCIBCM203X=y
+# CONFIG_BT_HCIBPA10X is not set
+# CONFIG_BT_HCIBFUSB is not set
+CONFIG_BT_HCIVHCI=y
+# CONFIG_BT_MRVL is not set
+CONFIG_BT_ATH3K=y
+# CONFIG_BT_MTKSDIO is not set
+# end of Bluetooth device drivers
+
+# CONFIG_AF_RXRPC is not set
+# CONFIG_AF_KCM is not set
+CONFIG_WIRELESS=y
+CONFIG_WIRELESS_EXT=y
+CONFIG_WEXT_CORE=y
+CONFIG_WEXT_PROC=y
+CONFIG_WEXT_SPY=y
+CONFIG_WEXT_PRIV=y
+CONFIG_CFG80211=m
+CONFIG_NL80211_TESTMODE=y
+# CONFIG_CFG80211_DEVELOPER_WARNINGS is not set
+# CONFIG_CFG80211_CERTIFICATION_ONUS is not set
+CONFIG_CFG80211_REQUIRE_SIGNED_REGDB=y
+CONFIG_CFG80211_USE_KERNEL_REGDB_KEYS=y
+CONFIG_CFG80211_DEFAULT_PS=y
+# CONFIG_CFG80211_DEBUGFS is not set
+CONFIG_CFG80211_CRDA_SUPPORT=y
+# CONFIG_CFG80211_WEXT is not set
+CONFIG_LIB80211=y
+CONFIG_LIB80211_CRYPT_WEP=y
+CONFIG_LIB80211_CRYPT_CCMP=y
+CONFIG_LIB80211_CRYPT_TKIP=y
+# CONFIG_LIB80211_DEBUG is not set
+CONFIG_MAC80211=m
+CONFIG_MAC80211_HAS_RC=y
+CONFIG_MAC80211_RC_MINSTREL=y
+CONFIG_MAC80211_RC_DEFAULT_MINSTREL=y
+CONFIG_MAC80211_RC_DEFAULT="minstrel_ht"
+# CONFIG_MAC80211_MESH is not set
+# CONFIG_MAC80211_LEDS is not set
+# CONFIG_MAC80211_DEBUGFS is not set
+# CONFIG_MAC80211_MESSAGE_TRACING is not set
+# CONFIG_MAC80211_DEBUG_MENU is not set
+CONFIG_MAC80211_STA_HASH_MAX_SIZE=0
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+# CONFIG_PSAMPLE is not set
+# CONFIG_NET_IFE is not set
+# CONFIG_LWTUNNEL is not set
+CONFIG_DST_CACHE=y
+CONFIG_GRO_CELLS=y
+# CONFIG_FAILOVER is not set
+CONFIG_HAVE_EBPF_JIT=y
+
+#
+# Device Drivers
+#
+CONFIG_HAVE_PCI=y
+# CONFIG_PCI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER=y
+CONFIG_UEVENT_HELPER_PATH=""
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_STANDALONE is not set
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+
+#
+# Firmware loader
+#
+CONFIG_FW_LOADER=y
+CONFIG_FW_LOADER_PAGED_BUF=y
+CONFIG_EXTRA_FIRMWARE="imx/sdma/sdma-imx6q.bin"
+CONFIG_EXTRA_FIRMWARE_DIR="firmware"
+CONFIG_FW_LOADER_USER_HELPER=y
+CONFIG_FW_LOADER_USER_HELPER_FALLBACK=y
+# CONFIG_FW_LOADER_COMPRESS is not set
+# end of Firmware loader
+
+CONFIG_ALLOW_DEV_COREDUMP=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_DEBUG_TEST_DRIVER_REMOVE is not set
+# CONFIG_TEST_ASYNC_DRIVER_PROBE is not set
+CONFIG_GENERIC_CPU_AUTOPROBE=y
+CONFIG_SOC_BUS=y
+CONFIG_REGMAP=y
+CONFIG_REGMAP_I2C=y
+CONFIG_REGMAP_SPI=y
+CONFIG_REGMAP_MMIO=y
+CONFIG_REGMAP_IRQ=y
+CONFIG_DMA_SHARED_BUFFER=y
+# CONFIG_DMA_FENCE_TRACE is not set
+# end of Generic Driver Options
+
+#
+# Bus devices
+#
+CONFIG_ARM_CCI=y
+CONFIG_ARM_CCI400_COMMON=y
+# CONFIG_BRCMSTB_GISB_ARB is not set
+# CONFIG_MOXTET is not set
+CONFIG_IMX_WEIM=y
+# CONFIG_SIMPLE_PM_BUS is not set
+# CONFIG_VEXPRESS_CONFIG is not set
+# end of Bus devices
+
+CONFIG_CONNECTOR=y
+CONFIG_PROC_EVENTS=y
+# CONFIG_GNSS is not set
+CONFIG_MTD=y
+# CONFIG_MTD_TESTS is not set
+
+#
+# Partition parsers
+#
+# CONFIG_MTD_AR7_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+CONFIG_MTD_OF_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# end of Partition parsers
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_SM_FTL is not set
+# CONFIG_MTD_OOPS is not set
+# CONFIG_MTD_SWAP is not set
+# CONFIG_MTD_PARTITIONED_MASTER is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+CONFIG_MTD_JEDECPROBE=y
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_STAA=y
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# end of RAM/ROM/Flash chip drivers
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_IMPA7 is not set
+# CONFIG_MTD_PLATRAM is not set
+# end of Mapping drivers for chip access
+
+#
+# Self-contained MTD device drivers
+#
+CONFIG_MTD_DATAFLASH=y
+# CONFIG_MTD_DATAFLASH_WRITE_VERIFY is not set
+# CONFIG_MTD_DATAFLASH_OTP is not set
+# CONFIG_MTD_MCHP23K256 is not set
+CONFIG_MTD_SST25L=y
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOCG3 is not set
+# end of Self-contained MTD device drivers
+
+# CONFIG_MTD_ONENAND is not set
+# CONFIG_MTD_RAW_NAND is not set
+# CONFIG_MTD_SPI_NAND is not set
+
+#
+# LPDDR & LPDDR2 PCM memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+# CONFIG_MTD_LPDDR2_NVM is not set
+# end of LPDDR & LPDDR2 PCM memory drivers
+
+CONFIG_MTD_SPI_NOR=y
+CONFIG_MTD_SPI_NOR_USE_4K_SECTORS=y
+# CONFIG_SPI_CADENCE_QUADSPI is not set
+# CONFIG_SPI_MTK_QUADSPI is not set
+CONFIG_MTD_UBI=y
+CONFIG_MTD_UBI_WL_THRESHOLD=4096
+CONFIG_MTD_UBI_BEB_LIMIT=20
+# CONFIG_MTD_UBI_FASTMAP is not set
+# CONFIG_MTD_UBI_GLUEBI is not set
+# CONFIG_MTD_UBI_BLOCK is not set
+# CONFIG_MTD_HYPERBUS is not set
+CONFIG_DTC=y
+CONFIG_OF=y
+# CONFIG_OF_UNITTEST is not set
+CONFIG_OF_FLATTREE=y
+CONFIG_OF_EARLY_FLATTREE=y
+CONFIG_OF_KOBJ=y
+CONFIG_OF_ADDRESS=y
+CONFIG_OF_IRQ=y
+CONFIG_OF_NET=y
+CONFIG_OF_MDIO=y
+CONFIG_OF_RESERVED_MEM=y
+# CONFIG_OF_OVERLAY is not set
+CONFIG_ARCH_MIGHT_HAVE_PC_PARPORT=y
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_NULL_BLK is not set
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_DRBD is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=65536
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_BLK_DEV_RBD is not set
+
+#
+# NVME Support
+#
+# CONFIG_NVME_FC is not set
+# CONFIG_NVME_TARGET is not set
+# end of NVME Support
+
+#
+# Misc devices
+#
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_DUMMY_IRQ is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_FXOS8700 is not set
+# CONFIG_SENSORS_FXAS2100X is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_LATTICE_ECP3_CONFIG is not set
+CONFIG_SRAM=y
+CONFIG_SRAM_EXEC=y
+# CONFIG_XILINX_SDFEC is not set
+# CONFIG_PVPANIC is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+CONFIG_EEPROM_AT24=y
+CONFIG_EEPROM_AT25=y
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_EEPROM_93XX46 is not set
+# CONFIG_EEPROM_IDT_89HPESX is not set
+# CONFIG_EEPROM_EE1004 is not set
+# end of EEPROM support
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_TI_ST is not set
+# end of Texas Instruments shared transport line discipline
+
+# CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
+# CONFIG_ALTERA_STAPL is not set
+
+#
+# Intel/IMX MIC & related support
+#
+
+#
+# Intel MIC Bus Driver
+#
+
+#
+# SCIF Bus Driver
+#
+
+#
+# VOP Bus Driver
+#
+# CONFIG_VOP_BUS is not set
+
+#
+# Intel MIC Host Driver
+#
+
+#
+# Intel MIC Card Driver
+#
+
+#
+# IMX MIC Host Driver
+#
+
+#
+# IMX MIC Card Driver
+#
+
+#
+# SCIF Driver
+#
+
+#
+# Intel MIC Coprocessor State Management (COSM) Drivers
+#
+
+#
+# VOP Driver
+#
+# end of Intel/IMX MIC & related support
+
+# CONFIG_ECHO is not set
+# CONFIG_MISC_RTSX_USB is not set
+# end of Misc devices
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_PROC_FS is not set
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+CONFIG_SCSI_CONSTANTS=y
+CONFIG_SCSI_LOGGING=y
+CONFIG_SCSI_SCAN_ASYNC=y
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+# end of SCSI Transports
+
+# CONFIG_SCSI_LOWLEVEL is not set
+# CONFIG_SCSI_DH is not set
+# end of SCSI device support
+
+CONFIG_ATA=y
+CONFIG_ATA_VERBOSE_ERROR=y
+CONFIG_SATA_PMP=y
+
+#
+# Controllers with non-SFF native interface
+#
+CONFIG_SATA_AHCI_PLATFORM=y
+CONFIG_AHCI_IMX=y
+# CONFIG_AHCI_CEVA is not set
+# CONFIG_AHCI_QORIQ is not set
+CONFIG_ATA_SFF=y
+
+#
+# SFF controllers with custom DMA interface
+#
+CONFIG_ATA_BMDMA=y
+
+#
+# SATA SFF controllers with BMDMA
+#
+# CONFIG_SATA_DWC is not set
+
+#
+# PATA SFF controllers with BMDMA
+#
+CONFIG_PATA_IMX=y
+
+#
+# PIO-only SFF controllers
+#
+# CONFIG_PATA_PLATFORM is not set
+
+#
+# Generic fallback / legacy drivers
+#
+# CONFIG_MD is not set
+# CONFIG_TARGET_CORE is not set
+CONFIG_NETDEVICES=y
+CONFIG_MII=y
+CONFIG_NET_CORE=y
+# CONFIG_BONDING is not set
+# CONFIG_DUMMY is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_NET_TEAM is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_IPVLAN is not set
+# CONFIG_VXLAN is not set
+# CONFIG_GENEVE is not set
+# CONFIG_GTP is not set
+# CONFIG_MACSEC is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_TUN is not set
+# CONFIG_TUN_VNET_CROSS_LE is not set
+# CONFIG_VETH is not set
+# CONFIG_NLMON is not set
+
+#
+# CAIF transport drivers
+#
+
+#
+# Distributed Switch Architecture drivers
+#
+# end of Distributed Switch Architecture drivers
+
+CONFIG_ETHERNET=y
+CONFIG_NET_VENDOR_ALACRITECH=y
+# CONFIG_ALTERA_TSE is not set
+CONFIG_NET_VENDOR_AMAZON=y
+CONFIG_NET_VENDOR_AQUANTIA=y
+CONFIG_NET_VENDOR_ARC=y
+# CONFIG_NET_VENDOR_AURORA is not set
+CONFIG_NET_VENDOR_BROADCOM=y
+# CONFIG_B44 is not set
+# CONFIG_BCMGENET is not set
+# CONFIG_SYSTEMPORT is not set
+CONFIG_NET_VENDOR_CADENCE=y
+# CONFIG_MACB is not set
+# CONFIG_NET_VENDOR_CAVIUM is not set
+CONFIG_NET_VENDOR_CIRRUS=y
+CONFIG_CS89x0=y
+CONFIG_CS89x0_PLATFORM=y
+CONFIG_NET_VENDOR_CORTINA=y
+# CONFIG_GEMINI_ETHERNET is not set
+# CONFIG_DM9000 is not set
+# CONFIG_DNET is not set
+CONFIG_NET_VENDOR_EZCHIP=y
+# CONFIG_EZCHIP_NPS_MANAGEMENT_ENET is not set
+# CONFIG_NET_VENDOR_FARADAY is not set
+CONFIG_NET_VENDOR_FREESCALE=y
+CONFIG_FEC=y
+# CONFIG_FSL_PQ_MDIO is not set
+# CONFIG_FSL_XGMAC_MDIO is not set
+# CONFIG_GIANFAR is not set
+
+#
+# Frame Manager support
+#
+# end of Frame Manager support
+
+CONFIG_NET_VENDOR_GOOGLE=y
+CONFIG_NET_VENDOR_HISILICON=y
+# CONFIG_HIX5HD2_GMAC is not set
+# CONFIG_HISI_FEMAC is not set
+# CONFIG_HIP04_ETH is not set
+# CONFIG_HNS is not set
+# CONFIG_HNS_DSAF is not set
+# CONFIG_HNS_ENET is not set
+CONFIG_NET_VENDOR_HUAWEI=y
+CONFIG_NET_VENDOR_I825XX=y
+CONFIG_NET_VENDOR_INTEL=y
+CONFIG_NET_VENDOR_MARVELL=y
+# CONFIG_MVMDIO is not set
+CONFIG_NET_VENDOR_MELLANOX=y
+# CONFIG_MLXSW_CORE is not set
+# CONFIG_MLXFW is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+CONFIG_NET_VENDOR_MICROCHIP=y
+# CONFIG_ENC28J60 is not set
+# CONFIG_ENCX24J600 is not set
+CONFIG_NET_VENDOR_MICROSEMI=y
+CONFIG_NET_VENDOR_NATSEMI=y
+CONFIG_NET_VENDOR_NETRONOME=y
+CONFIG_NET_VENDOR_NI=y
+# CONFIG_NI_XGE_MANAGEMENT_ENET is not set
+CONFIG_NET_VENDOR_8390=y
+# CONFIG_AX88796 is not set
+# CONFIG_ETHOC is not set
+CONFIG_NET_VENDOR_PENSANDO=y
+CONFIG_NET_VENDOR_QUALCOMM=y
+# CONFIG_QCA7000_SPI is not set
+# CONFIG_QCOM_EMAC is not set
+# CONFIG_RMNET is not set
+CONFIG_NET_VENDOR_RENESAS=y
+CONFIG_NET_VENDOR_ROCKER=y
+CONFIG_NET_VENDOR_SAMSUNG=y
+# CONFIG_SXGBE_ETH is not set
+CONFIG_NET_VENDOR_SEEQ=y
+CONFIG_NET_VENDOR_SOLARFLARE=y
+CONFIG_NET_VENDOR_SMSC=y
+# CONFIG_SMC91X is not set
+# CONFIG_SMC911X is not set
+# CONFIG_SMSC911X is not set
+CONFIG_NET_VENDOR_SOCIONEXT=y
+CONFIG_NET_VENDOR_STMICRO=y
+# CONFIG_STMMAC_ETH is not set
+CONFIG_NET_VENDOR_SYNOPSYS=y
+# CONFIG_DWC_XLGMAC is not set
+CONFIG_NET_VENDOR_VIA=y
+# CONFIG_VIA_RHINE is not set
+# CONFIG_VIA_VELOCITY is not set
+CONFIG_NET_VENDOR_WIZNET=y
+# CONFIG_WIZNET_W5100 is not set
+# CONFIG_WIZNET_W5300 is not set
+CONFIG_NET_VENDOR_XILINX=y
+# CONFIG_XILINX_AXI_EMAC is not set
+CONFIG_MDIO_DEVICE=y
+CONFIG_MDIO_BUS=y
+# CONFIG_MDIO_BCM_UNIMAC is not set
+# CONFIG_MDIO_BITBANG is not set
+# CONFIG_MDIO_BUS_MUX_GPIO is not set
+# CONFIG_MDIO_BUS_MUX_MMIOREG is not set
+# CONFIG_MDIO_BUS_MUX_MULTIPLEXER is not set
+# CONFIG_MDIO_HISI_FEMAC is not set
+# CONFIG_MDIO_MSCC_MIIM is not set
+CONFIG_PHYLIB=y
+CONFIG_SWPHY=y
+# CONFIG_LED_TRIGGER_PHY is not set
+
+#
+# MII PHY device drivers
+#
+# CONFIG_ADIN_PHY is not set
+# CONFIG_AMD_PHY is not set
+# CONFIG_AQUANTIA_PHY is not set
+# CONFIG_AX88796B_PHY is not set
+# CONFIG_AT803X_PHY is not set
+# CONFIG_BCM7XXX_PHY is not set
+# CONFIG_BCM87XX_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_CORTINA_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_DP83822_PHY is not set
+# CONFIG_DP83TC811_PHY is not set
+# CONFIG_DP83848_PHY is not set
+# CONFIG_DP83867_PHY is not set
+CONFIG_FIXED_PHY=y
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_INPHI_PHY is not set
+# CONFIG_INTEL_XWAY_PHY is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_MARVELL_10G_PHY is not set
+# CONFIG_MICREL_PHY is not set
+# CONFIG_MICROCHIP_PHY is not set
+# CONFIG_MICROCHIP_T1_PHY is not set
+# CONFIG_MICROSEMI_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_NXP_TJA11XX_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_RENESAS_PHY is not set
+# CONFIG_ROCKCHIP_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_TERANETICS_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_XILINX_GMII2RGMII is not set
+# CONFIG_TI_PHY_DP83848 is not set
+# CONFIG_MICREL_KS8995MA is not set
+CONFIG_PPP=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_MPPE=y
+CONFIG_PPP_MULTILINK=y
+CONFIG_PPPOE=y
+CONFIG_PPP_ASYNC=y
+CONFIG_PPP_SYNC_TTY=y
+CONFIG_SLIP=m
+CONFIG_SLHC=y
+# CONFIG_SLIP_COMPRESSED is not set
+# CONFIG_SLIP_SMART is not set
+# CONFIG_SLIP_MODE_SLIP6 is not set
+CONFIG_USB_NET_DRIVERS=y
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+CONFIG_USB_PEGASUS=m
+CONFIG_USB_RTL8150=m
+CONFIG_USB_RTL8152=m
+# CONFIG_USB_LAN78XX is not set
+CONFIG_USB_USBNET=y
+CONFIG_USB_NET_AX8817X=y
+CONFIG_USB_NET_AX88179_178A=y
+CONFIG_USB_NET_CDCETHER=y
+CONFIG_USB_NET_CDC_EEM=y
+CONFIG_USB_NET_CDC_NCM=y
+# CONFIG_USB_NET_HUAWEI_CDC_NCM is not set
+# CONFIG_USB_NET_CDC_MBIM is not set
+# CONFIG_USB_NET_DM9601 is not set
+# CONFIG_USB_NET_SR9700 is not set
+# CONFIG_USB_NET_SR9800 is not set
+# CONFIG_USB_NET_SMSC75XX is not set
+# CONFIG_USB_NET_SMSC95XX is not set
+# CONFIG_USB_NET_GL620A is not set
+CONFIG_USB_NET_NET1080=m
+# CONFIG_USB_NET_PLUSB is not set
+# CONFIG_USB_NET_MCS7830 is not set
+# CONFIG_USB_NET_RNDIS_HOST is not set
+CONFIG_USB_NET_CDC_SUBSET_ENABLE=m
+CONFIG_USB_NET_CDC_SUBSET=m
+# CONFIG_USB_ALI_M5632 is not set
+# CONFIG_USB_AN2720 is not set
+CONFIG_USB_BELKIN=y
+CONFIG_USB_ARMLINUX=y
+# CONFIG_USB_EPSON2888 is not set
+# CONFIG_USB_KC2190 is not set
+CONFIG_USB_NET_ZAURUS=m
+# CONFIG_USB_NET_CX82310_ETH is not set
+# CONFIG_USB_NET_KALMIA is not set
+CONFIG_USB_NET_QMI_WWAN=y
+# CONFIG_USB_NET_INT51X1 is not set
+# CONFIG_USB_IPHETH is not set
+# CONFIG_USB_SIERRA_NET is not set
+# CONFIG_USB_VL600 is not set
+# CONFIG_USB_NET_CH9200 is not set
+# CONFIG_USB_NET_AQC111 is not set
+CONFIG_WLAN=y
+# CONFIG_WIRELESS_WDS is not set
+CONFIG_WLAN_VENDOR_ADMTEK=y
+CONFIG_WLAN_VENDOR_ATH=y
+# CONFIG_ATH_DEBUG is not set
+# CONFIG_ATH9K is not set
+# CONFIG_ATH9K_HTC is not set
+# CONFIG_CARL9170 is not set
+CONFIG_ATH6KL=m
+# CONFIG_ATH6KL_SDIO is not set
+# CONFIG_ATH6KL_USB is not set
+# CONFIG_ATH6KL_DEBUG is not set
+# CONFIG_AR5523 is not set
+# CONFIG_ATH10K is not set
+# CONFIG_WCN36XX is not set
+CONFIG_WLAN_VENDOR_ATMEL=y
+# CONFIG_AT76C50X_USB is not set
+CONFIG_WLAN_VENDOR_BROADCOM=y
+# CONFIG_B43 is not set
+# CONFIG_B43LEGACY is not set
+CONFIG_BRCMUTIL=m
+# CONFIG_BRCMSMAC is not set
+CONFIG_BRCMFMAC=m
+CONFIG_BRCMFMAC_PROTO_BCDC=y
+CONFIG_BRCMFMAC_SDIO=y
+# CONFIG_BRCMFMAC_USB is not set
+# CONFIG_BRCM_TRACING is not set
+# CONFIG_BRCMDBG is not set
+CONFIG_WLAN_VENDOR_CISCO=y
+CONFIG_WLAN_VENDOR_INTEL=y
+CONFIG_WLAN_VENDOR_INTERSIL=y
+CONFIG_HOSTAP=y
+# CONFIG_HOSTAP_FIRMWARE is not set
+# CONFIG_P54_COMMON is not set
+CONFIG_WLAN_VENDOR_MARVELL=y
+# CONFIG_LIBERTAS is not set
+# CONFIG_LIBERTAS_THINFIRM is not set
+# CONFIG_MWIFIEX is not set
+CONFIG_WLAN_VENDOR_MEDIATEK=y
+# CONFIG_MT7601U is not set
+# CONFIG_MT76x0U is not set
+# CONFIG_MT76x2U is not set
+CONFIG_WLAN_VENDOR_NXP=y
+# CONFIG_MXMWIFIEX is not set
+CONFIG_WLAN_VENDOR_RALINK=y
+CONFIG_RT2X00=m
+# CONFIG_RT2500USB is not set
+# CONFIG_RT73USB is not set
+CONFIG_RT2800USB=m
+CONFIG_RT2800USB_RT33XX=y
+CONFIG_RT2800USB_RT35XX=y
+CONFIG_RT2800USB_RT3573=y
+CONFIG_RT2800USB_RT53XX=y
+CONFIG_RT2800USB_RT55XX=y
+CONFIG_RT2800USB_UNKNOWN=y
+CONFIG_RT2800_LIB=m
+CONFIG_RT2X00_LIB_USB=m
+CONFIG_RT2X00_LIB=m
+CONFIG_RT2X00_LIB_FIRMWARE=y
+CONFIG_RT2X00_LIB_CRYPTO=y
+CONFIG_RT2X00_LIB_LEDS=y
+# CONFIG_RT2X00_DEBUG is not set
+CONFIG_WLAN_VENDOR_REALTEK=y
+# CONFIG_RTL8187 is not set
+CONFIG_RTL_CARDS=m
+# CONFIG_RTL8192CU is not set
+# CONFIG_RTL8XXXU is not set
+# CONFIG_RTW88 is not set
+CONFIG_WLAN_VENDOR_RSI=y
+# CONFIG_RSI_91X is not set
+CONFIG_WLAN_VENDOR_ST=y
+# CONFIG_CW1200 is not set
+CONFIG_WLAN_VENDOR_TI=y
+# CONFIG_WL1251 is not set
+# CONFIG_WL12XX is not set
+# CONFIG_WL18XX is not set
+# CONFIG_WLCORE is not set
+CONFIG_WLAN_VENDOR_ZYDAS=y
+# CONFIG_USB_ZD1201 is not set
+# CONFIG_ZD1211RW is not set
+CONFIG_WLAN_VENDOR_QUANTENNA=y
+# CONFIG_MAC80211_HWSIM is not set
+# CONFIG_USB_NET_RNDIS_WLAN is not set
+# CONFIG_VIRT_WIFI is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_NETDEVSIM is not set
+# CONFIG_NET_FAILOVER is not set
+# CONFIG_ISDN is not set
+# CONFIG_NVM is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+CONFIG_INPUT_LEDS=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+CONFIG_INPUT_POLLDEV=y
+# CONFIG_INPUT_SPARSEKMAP is not set
+CONFIG_INPUT_MATRIXKMAP=y
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+CONFIG_INPUT_EVBUG=m
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ADC is not set
+# CONFIG_KEYBOARD_ADP5588 is not set
+# CONFIG_KEYBOARD_ADP5589 is not set
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_QT1050 is not set
+# CONFIG_KEYBOARD_QT1070 is not set
+# CONFIG_KEYBOARD_QT2160 is not set
+# CONFIG_KEYBOARD_DLINK_DIR685 is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+CONFIG_KEYBOARD_GPIO=y
+# CONFIG_KEYBOARD_GPIO_POLLED is not set
+# CONFIG_KEYBOARD_TCA6416 is not set
+# CONFIG_KEYBOARD_TCA8418 is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_LM8323 is not set
+# CONFIG_KEYBOARD_LM8333 is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_MCS is not set
+# CONFIG_KEYBOARD_MPR121 is not set
+CONFIG_KEYBOARD_SNVS_PWRKEY=y
+CONFIG_KEYBOARD_IMX=y
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_SAMSUNG is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_OMAP4 is not set
+# CONFIG_KEYBOARD_TM2_TOUCHKEY is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_CAP11XX is not set
+# CONFIG_KEYBOARD_BCM is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_TOUCHSCREEN_FTS is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_AD714X is not set
+# CONFIG_INPUT_ATMEL_CAPTOUCH is not set
+# CONFIG_INPUT_BMA150 is not set
+# CONFIG_INPUT_E3X0_BUTTON is not set
+# CONFIG_INPUT_MSM_VIBRATOR is not set
+# CONFIG_INPUT_MC13783_PWRBUTTON is not set
+# CONFIG_INPUT_MMA8450 is not set
+# CONFIG_INPUT_GP2A is not set
+# CONFIG_INPUT_GPIO_BEEPER is not set
+# CONFIG_INPUT_GPIO_DECODER is not set
+# CONFIG_INPUT_GPIO_VIBRA is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_KXTJ9 is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INPUT_CM109 is not set
+# CONFIG_INPUT_REGULATOR_HAPTIC is not set
+# CONFIG_INPUT_UINPUT is not set
+# CONFIG_INPUT_PCF8574 is not set
+# CONFIG_INPUT_PWM_BEEPER is not set
+# CONFIG_INPUT_PWM_VIBRA is not set
+# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
+# CONFIG_INPUT_DA9052_ONKEY is not set
+# CONFIG_INPUT_ADXL34X is not set
+# CONFIG_INPUT_IMS_PCU is not set
+# CONFIG_INPUT_CMA3000 is not set
+# CONFIG_INPUT_DRV260X_HAPTICS is not set
+# CONFIG_INPUT_DRV2665_HAPTICS is not set
+# CONFIG_INPUT_DRV2667_HAPTICS is not set
+CONFIG_INPUT_MPL3115=y
+CONFIG_SENSOR_FXLS8471=y
+CONFIG_INPUT_ISL29023=y
+# CONFIG_RMI4_CORE is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=m
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_SERIO_ARC_PS2 is not set
+# CONFIG_SERIO_APBPS2 is not set
+# CONFIG_SERIO_GPIO_PS2 is not set
+# CONFIG_USERIO is not set
+# CONFIG_GAMEPORT is not set
+# end of Hardware I/O ports
+# end of Input device support
+
+#
+# Character devices
+#
+CONFIG_TTY=y
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_VT_CONSOLE_SLEEP=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+# CONFIG_NULL_TTY is not set
+CONFIG_LDISC_AUTOLOAD=y
+CONFIG_DEVMEM=y
+# CONFIG_DEVKMEM is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_EARLYCON=y
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_EARLYCON_ARM_SEMIHOST is not set
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_MAX310X is not set
+CONFIG_SERIAL_IMX=y
+CONFIG_SERIAL_IMX_CONSOLE=y
+# CONFIG_SERIAL_UARTLITE is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_SIFIVE is not set
+# CONFIG_SERIAL_SCCNXP is not set
+# CONFIG_SERIAL_SC16IS7XX is not set
+# CONFIG_SERIAL_BCM63XX is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_IFX6X60 is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+# CONFIG_SERIAL_ARC is not set
+CONFIG_SERIAL_FSL_LPUART=y
+CONFIG_SERIAL_FSL_LPUART_CONSOLE=y
+# CONFIG_SERIAL_FSL_LINFLEXUART is not set
+# CONFIG_SERIAL_CONEXANT_DIGICOLOR is not set
+# CONFIG_SERIAL_ST_ASC is not set
+# end of Serial drivers
+
+CONFIG_SERIAL_MCTRL_GPIO=y
+# CONFIG_SERIAL_DEV_BUS is not set
+# CONFIG_TTY_PRINTK is not set
+# CONFIG_HVC_DCC is not set
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+CONFIG_HW_RANDOM_IMX_RNGC=y
+CONFIG_HW_RANDOM_OPTEE=y
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_XILLYBUS is not set
+CONFIG_IMX_SEMA4=y
+# end of Character devices
+
+# CONFIG_RANDOM_TRUST_BOOTLOADER is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+# CONFIG_I2C_COMPAT is not set
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_MUX=y
+
+#
+# Multiplexer I2C Chip support
+#
+# CONFIG_I2C_ARB_GPIO_CHALLENGE is not set
+# CONFIG_I2C_MUX_GPIO is not set
+# CONFIG_I2C_MUX_GPMUX is not set
+# CONFIG_I2C_MUX_LTC4306 is not set
+# CONFIG_I2C_MUX_PCA9541 is not set
+# CONFIG_I2C_MUX_PCA954x is not set
+# CONFIG_I2C_MUX_PINCTRL is not set
+# CONFIG_I2C_MUX_REG is not set
+# CONFIG_I2C_DEMUX_PINCTRL is not set
+# CONFIG_I2C_MUX_MLXCPLD is not set
+# end of Multiplexer I2C Chip support
+
+# CONFIG_I2C_HELPER_AUTO is not set
+# CONFIG_I2C_SMBUS is not set
+
+#
+# I2C Algorithms
+#
+CONFIG_I2C_ALGOBIT=y
+CONFIG_I2C_ALGOPCF=m
+CONFIG_I2C_ALGOPCA=m
+# end of I2C Algorithms
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_CBUS_GPIO is not set
+# CONFIG_I2C_DESIGNWARE_PLATFORM is not set
+# CONFIG_I2C_EMEV2 is not set
+# CONFIG_I2C_GPIO is not set
+CONFIG_I2C_IMX=y
+# CONFIG_I2C_IMX_LPI2C is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_RK3X is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_DIOLAN_U2C is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_ROBOTFUZZ_OSIF is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# end of I2C Hardware Bus support
+
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_SLAVE is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# end of I2C support
+
+# CONFIG_I3C is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+CONFIG_SPI_MEM=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_ALTERA is not set
+# CONFIG_SPI_AXI_SPI_ENGINE is not set
+CONFIG_SPI_BITBANG=y
+# CONFIG_SPI_CADENCE is not set
+# CONFIG_SPI_DESIGNWARE is not set
+CONFIG_SPI_FSL_LPSPI=y
+CONFIG_SPI_FSL_QUADSPI=y
+# CONFIG_SPI_NXP_FLEXSPI is not set
+CONFIG_SPI_GPIO=y
+CONFIG_SPI_IMX=y
+# CONFIG_SPI_FSL_SPI is not set
+# CONFIG_SPI_FSL_DSPI is not set
+# CONFIG_SPI_OC_TINY is not set
+# CONFIG_SPI_ROCKCHIP is not set
+# CONFIG_SPI_SC18IS602 is not set
+# CONFIG_SPI_SIFIVE is not set
+# CONFIG_SPI_MXIC is not set
+# CONFIG_SPI_XCOMM is not set
+# CONFIG_SPI_XILINX is not set
+# CONFIG_SPI_ZYNQMP_GQSPI is not set
+
+#
+# SPI Protocol Masters
+#
+CONFIG_SPI_SPIDEV=y
+# CONFIG_SPI_LOOPBACK_TEST is not set
+# CONFIG_SPI_TLE62X0 is not set
+CONFIG_SPI_SLAVE=y
+CONFIG_SPI_SLAVE_TIME=y
+CONFIG_SPI_SLAVE_SYSTEM_CONTROL=y
+CONFIG_SPI_DYNAMIC=y
+# CONFIG_SPMI is not set
+# CONFIG_HSI is not set
+CONFIG_PPS=y
+# CONFIG_PPS_DEBUG is not set
+
+#
+# PPS clients support
+#
+# CONFIG_PPS_CLIENT_KTIMER is not set
+# CONFIG_PPS_CLIENT_LDISC is not set
+# CONFIG_PPS_CLIENT_GPIO is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+CONFIG_PTP_1588_CLOCK=y
+
+#
+# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
+#
+# end of PTP clock support
+
+CONFIG_PINCTRL=y
+CONFIG_GENERIC_PINCTRL_GROUPS=y
+CONFIG_PINMUX=y
+CONFIG_GENERIC_PINMUX_FUNCTIONS=y
+CONFIG_PINCONF=y
+CONFIG_GENERIC_PINCONF=y
+# CONFIG_DEBUG_PINCTRL is not set
+# CONFIG_PINCTRL_AMD is not set
+# CONFIG_PINCTRL_MCP23S08 is not set
+# CONFIG_PINCTRL_SINGLE is not set
+# CONFIG_PINCTRL_SX150X is not set
+# CONFIG_PINCTRL_STMFX is not set
+# CONFIG_PINCTRL_OCELOT is not set
+CONFIG_PINCTRL_IMX=y
+CONFIG_PINCTRL_IMX50=y
+CONFIG_PINCTRL_IMX53=y
+CONFIG_PINCTRL_IMX6Q=y
+CONFIG_PINCTRL_IMX6SL=y
+CONFIG_PINCTRL_IMX6SLL=y
+CONFIG_PINCTRL_IMX6SX=y
+CONFIG_PINCTRL_IMX6UL=y
+CONFIG_PINCTRL_IMX7D=y
+CONFIG_PINCTRL_IMX7ULP=y
+CONFIG_PINCTRL_VF610=y
+# CONFIG_PINCTRL_S32V_CORE is not set
+CONFIG_ARCH_HAVE_CUSTOM_GPIO_H=y
+CONFIG_GPIOLIB=y
+CONFIG_GPIOLIB_FASTPATH_LIMIT=512
+CONFIG_OF_GPIO=y
+CONFIG_GPIOLIB_IRQCHIP=y
+# CONFIG_DEBUG_GPIO is not set
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_GENERIC=y
+
+#
+# Memory mapped GPIO drivers
+#
+# CONFIG_GPIO_74XX_MMIO is not set
+# CONFIG_GPIO_ALTERA is not set
+# CONFIG_GPIO_CADENCE is not set
+# CONFIG_GPIO_DWAPB is not set
+# CONFIG_GPIO_FTGPIO010 is not set
+# CONFIG_GPIO_GENERIC_PLATFORM is not set
+# CONFIG_GPIO_GRGPIO is not set
+# CONFIG_GPIO_HLWD is not set
+# CONFIG_GPIO_MB86S7X is not set
+# CONFIG_GPIO_MPC8XXX is not set
+CONFIG_GPIO_MXC=y
+# CONFIG_GPIO_SAMA5D2_PIOBU is not set
+# CONFIG_GPIO_SYSCON is not set
+CONFIG_GPIO_VF610=y
+# CONFIG_GPIO_XILINX is not set
+# CONFIG_GPIO_ZEVIO is not set
+# CONFIG_GPIO_AMD_FCH is not set
+# end of Memory mapped GPIO drivers
+
+#
+# I2C GPIO expanders
+#
+# CONFIG_GPIO_ADP5588 is not set
+# CONFIG_GPIO_ADNP is not set
+# CONFIG_GPIO_GW_PLD is not set
+# CONFIG_GPIO_MAX7300 is not set
+CONFIG_GPIO_MAX732X=y
+# CONFIG_GPIO_MAX732X_IRQ is not set
+CONFIG_GPIO_PCA953X=y
+# CONFIG_GPIO_PCA953X_IRQ is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_TPIC2810 is not set
+# CONFIG_GPIO_TS4900 is not set
+# end of I2C GPIO expanders
+
+#
+# MFD GPIO expanders
+#
+# CONFIG_GPIO_DA9052 is not set
+# CONFIG_HTC_EGPIO is not set
+# end of MFD GPIO expanders
+
+#
+# SPI GPIO expanders
+#
+CONFIG_GPIO_74X164=y
+# CONFIG_GPIO_MAX3191X is not set
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MC33880 is not set
+# CONFIG_GPIO_PISOSR is not set
+# CONFIG_GPIO_XRA1403 is not set
+# end of SPI GPIO expanders
+
+#
+# USB GPIO expanders
+#
+# end of USB GPIO expanders
+
+# CONFIG_GPIO_MOCKUP is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_AVS is not set
+# CONFIG_POWER_RESET is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+CONFIG_POWER_SUPPLY_HWMON=y
+# CONFIG_PDA_POWER is not set
+# CONFIG_GENERIC_ADC_BATTERY is not set
+# CONFIG_TEST_POWER is not set
+# CONFIG_CHARGER_ADP5061 is not set
+# CONFIG_BATTERY_DS2780 is not set
+# CONFIG_BATTERY_DS2781 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_LEGO_EV3 is not set
+# CONFIG_BATTERY_SBS is not set
+# CONFIG_CHARGER_SBS is not set
+# CONFIG_MANAGER_SBS is not set
+# CONFIG_BATTERY_BQ27XXX is not set
+CONFIG_CHARGER_BQ2560X=y
+# CONFIG_BATTERY_DA9052 is not set
+# CONFIG_BATTERY_MAX17040 is not set
+# CONFIG_BATTERY_MAX17042 is not set
+# CONFIG_CHARGER_ISP1704 is not set
+# CONFIG_CHARGER_MAX8903 is not set
+# CONFIG_CHARGER_LP8727 is not set
+# CONFIG_CHARGER_GPIO is not set
+# CONFIG_CHARGER_MANAGER is not set
+# CONFIG_CHARGER_LT3651 is not set
+# CONFIG_CHARGER_DETECTOR_MAX14656 is not set
+# CONFIG_CHARGER_BQ2415X is not set
+# CONFIG_CHARGER_BQ24190 is not set
+# CONFIG_CHARGER_BQ24257 is not set
+# CONFIG_CHARGER_BQ24735 is not set
+# CONFIG_CHARGER_BQ25890 is not set
+# CONFIG_CHARGER_SMB347 is not set
+# CONFIG_BATTERY_GAUGE_LTC2941 is not set
+# CONFIG_CHARGER_RT9455 is not set
+# CONFIG_CHARGER_UCS1002 is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Native drivers
+#
+# CONFIG_SENSORS_AD7314 is not set
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7310 is not set
+# CONFIG_SENSORS_ADT7410 is not set
+# CONFIG_SENSORS_ADT7411 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7475 is not set
+# CONFIG_SENSORS_AS370 is not set
+# CONFIG_SENSORS_ASC7621 is not set
+# CONFIG_SENSORS_ASPEED is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS620 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_DA9052_ADC is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_MC13783_ADC is not set
+# CONFIG_SENSORS_FTSTEUTATES is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_G760A is not set
+# CONFIG_SENSORS_G762 is not set
+# CONFIG_SENSORS_GPIO_FAN is not set
+# CONFIG_SENSORS_HIH6130 is not set
+# CONFIG_SENSORS_IIO_HWMON is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_JC42 is not set
+# CONFIG_SENSORS_POWR1220 is not set
+# CONFIG_SENSORS_LINEAGE is not set
+# CONFIG_SENSORS_LTC2945 is not set
+# CONFIG_SENSORS_LTC2990 is not set
+# CONFIG_SENSORS_LTC4151 is not set
+# CONFIG_SENSORS_LTC4215 is not set
+# CONFIG_SENSORS_LTC4222 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LTC4260 is not set
+# CONFIG_SENSORS_LTC4261 is not set
+# CONFIG_SENSORS_MAX1111 is not set
+# CONFIG_SENSORS_MAX16065 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX1668 is not set
+CONFIG_SENSORS_MAX17135=y
+# CONFIG_SENSORS_MAX197 is not set
+# CONFIG_SENSORS_MAX31722 is not set
+# CONFIG_SENSORS_MAX6621 is not set
+# CONFIG_SENSORS_MAX6639 is not set
+# CONFIG_SENSORS_MAX6642 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_MAX6697 is not set
+# CONFIG_SENSORS_MAX31790 is not set
+# CONFIG_SENSORS_MCP3021 is not set
+# CONFIG_SENSORS_TC654 is not set
+# CONFIG_SENSORS_ADCXX is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM70 is not set
+# CONFIG_SENSORS_LM73 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LM95234 is not set
+# CONFIG_SENSORS_LM95241 is not set
+# CONFIG_SENSORS_LM95245 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_NTC_THERMISTOR is not set
+# CONFIG_SENSORS_NCT6683 is not set
+# CONFIG_SENSORS_NCT6775 is not set
+# CONFIG_SENSORS_NCT7802 is not set
+# CONFIG_SENSORS_NCT7904 is not set
+# CONFIG_SENSORS_NPCM7XX is not set
+# CONFIG_SENSORS_OCC_P8_I2C is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_PMBUS is not set
+# CONFIG_SENSORS_PWM_FAN is not set
+# CONFIG_SENSORS_SHT15 is not set
+# CONFIG_SENSORS_SHT21 is not set
+# CONFIG_SENSORS_SHT3x is not set
+# CONFIG_SENSORS_SHTC1 is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_EMC1403 is not set
+# CONFIG_SENSORS_EMC2103 is not set
+# CONFIG_SENSORS_EMC6W201 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SCH5627 is not set
+# CONFIG_SENSORS_SCH5636 is not set
+# CONFIG_SENSORS_STTS751 is not set
+# CONFIG_SENSORS_SMM665 is not set
+# CONFIG_SENSORS_ADC128D818 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_ADS7871 is not set
+# CONFIG_SENSORS_AMC6821 is not set
+# CONFIG_SENSORS_INA209 is not set
+# CONFIG_SENSORS_INA2XX is not set
+# CONFIG_SENSORS_INA3221 is not set
+# CONFIG_SENSORS_TC74 is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_TMP102 is not set
+# CONFIG_SENSORS_TMP103 is not set
+# CONFIG_SENSORS_TMP108 is not set
+# CONFIG_SENSORS_TMP401 is not set
+# CONFIG_SENSORS_TMP421 is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_W83773G is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83795 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+CONFIG_SENSORS_MAG3110=y
+# CONFIG_MXC_MMA8451 is not set
+CONFIG_THERMAL=y
+# CONFIG_THERMAL_STATISTICS is not set
+CONFIG_THERMAL_EMERGENCY_POWEROFF_DELAY_MS=0
+CONFIG_THERMAL_HWMON=y
+CONFIG_THERMAL_OF=y
+CONFIG_THERMAL_WRITABLE_TRIPS=y
+CONFIG_THERMAL_DEFAULT_GOV_STEP_WISE=y
+# CONFIG_THERMAL_DEFAULT_GOV_FAIR_SHARE is not set
+# CONFIG_THERMAL_DEFAULT_GOV_USER_SPACE is not set
+# CONFIG_THERMAL_DEFAULT_GOV_POWER_ALLOCATOR is not set
+# CONFIG_THERMAL_GOV_FAIR_SHARE is not set
+CONFIG_THERMAL_GOV_STEP_WISE=y
+# CONFIG_THERMAL_GOV_BANG_BANG is not set
+# CONFIG_THERMAL_GOV_USER_SPACE is not set
+# CONFIG_THERMAL_GOV_POWER_ALLOCATOR is not set
+CONFIG_CPU_THERMAL=y
+# CONFIG_CLOCK_THERMAL is not set
+# CONFIG_THERMAL_EMULATION is not set
+# CONFIG_THERMAL_MMIO is not set
+CONFIG_IMX_THERMAL=y
+CONFIG_DEVICE_THERMAL=y
+# CONFIG_IMX8MM_THERMAL is not set
+# CONFIG_QORIQ_THERMAL is not set
+# CONFIG_GENERIC_ADC_THERMAL is not set
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_CORE=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+CONFIG_WATCHDOG_HANDLE_BOOT_ENABLED=y
+CONFIG_WATCHDOG_OPEN_TIMEOUT=0
+# CONFIG_WATCHDOG_SYSFS is not set
+
+#
+# Watchdog Pretimeout Governors
+#
+# CONFIG_WATCHDOG_PRETIMEOUT_GOV is not set
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+# CONFIG_DA9052_WATCHDOG is not set
+# CONFIG_GPIO_WATCHDOG is not set
+# CONFIG_XILINX_WATCHDOG is not set
+# CONFIG_ZIIRAVE_WATCHDOG is not set
+# CONFIG_CADENCE_WATCHDOG is not set
+# CONFIG_FTWDT010_WATCHDOG is not set
+# CONFIG_DW_WATCHDOG is not set
+# CONFIG_MAX63XX_WATCHDOG is not set
+CONFIG_IMX2_WDT=y
+# CONFIG_IMX7ULP_WDT is not set
+# CONFIG_MEN_A21_WDT is not set
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+CONFIG_MFD_CORE=y
+# CONFIG_MFD_ACT8945A is not set
+# CONFIG_MFD_AS3711 is not set
+# CONFIG_MFD_AS3722 is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_AAT2870_CORE is not set
+# CONFIG_MFD_ATMEL_FLEXCOM is not set
+# CONFIG_MFD_ATMEL_HLCDC is not set
+# CONFIG_MFD_BCM590XX is not set
+# CONFIG_MFD_BD9571MWV is not set
+# CONFIG_MFD_AXP20X_I2C is not set
+# CONFIG_MFD_MADERA is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_PMIC_DA903X is not set
+CONFIG_PMIC_DA9052=y
+# CONFIG_MFD_DA9052_SPI is not set
+CONFIG_MFD_DA9052_I2C=y
+# CONFIG_MFD_DA9055 is not set
+# CONFIG_MFD_DA9062 is not set
+# CONFIG_MFD_DA9063 is not set
+# CONFIG_MFD_DA9150 is not set
+# CONFIG_MFD_DLN2 is not set
+CONFIG_MFD_MC13XXX=y
+CONFIG_MFD_MC13XXX_SPI=y
+CONFIG_MFD_MC13XXX_I2C=y
+# CONFIG_MFD_MXC_HDMI is not set
+# CONFIG_MFD_IMX_AUDIOMIX is not set
+# CONFIG_MFD_HI6421_PMIC is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_HTC_I2CPLD is not set
+# CONFIG_MFD_KEMPLD is not set
+# CONFIG_MFD_88PM800 is not set
+# CONFIG_MFD_88PM805 is not set
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_MAX14577 is not set
+CONFIG_MFD_MAX17135=y
+# CONFIG_MFD_MAX77620 is not set
+# CONFIG_MFD_MAX77650 is not set
+# CONFIG_MFD_MAX77686 is not set
+# CONFIG_MFD_MAX77693 is not set
+# CONFIG_MFD_MAX77843 is not set
+# CONFIG_MFD_MAX8907 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_MFD_MT6397 is not set
+# CONFIG_MFD_MENF21BMC is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_MFD_CPCAP is not set
+# CONFIG_MFD_VIPERBOARD is not set
+# CONFIG_MFD_RETU is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_PM8XXX is not set
+# CONFIG_MFD_RT5033 is not set
+# CONFIG_MFD_RC5T583 is not set
+# CONFIG_MFD_RK808 is not set
+# CONFIG_MFD_RN5T618 is not set
+# CONFIG_MFD_SEC_CORE is not set
+# CONFIG_MFD_SI476X_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_SKY81452 is not set
+# CONFIG_MFD_SMSC is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_MFD_STMPE is not set
+CONFIG_MFD_SYSCON=y
+# CONFIG_MFD_TI_AM335X_TSCADC is not set
+# CONFIG_MFD_LP3943 is not set
+# CONFIG_MFD_LP8788 is not set
+# CONFIG_MFD_TI_LMU is not set
+# CONFIG_MFD_PALMAS is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS65086 is not set
+# CONFIG_MFD_TPS65090 is not set
+# CONFIG_MFD_TPS65217 is not set
+# CONFIG_MFD_TI_LP873X is not set
+# CONFIG_MFD_TI_LP87565 is not set
+# CONFIG_MFD_TPS65218 is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_MFD_TPS65910 is not set
+# CONFIG_MFD_TPS65912_I2C is not set
+# CONFIG_MFD_TPS65912_SPI is not set
+# CONFIG_MFD_TPS80031 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_TWL6040_CORE is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_LM3533 is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_MFD_TQMX86 is not set
+# CONFIG_MFD_LOCHNAGAR is not set
+# CONFIG_MFD_ARIZONA_I2C is not set
+# CONFIG_MFD_ARIZONA_SPI is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM831X_SPI is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_MFD_ROHM_BD718XX is not set
+# CONFIG_MFD_ROHM_BD70528 is not set
+# CONFIG_MFD_STPMIC1 is not set
+# CONFIG_MFD_STMFX is not set
+# CONFIG_MFD_PCA9450 is not set
+# end of Multifunction device drivers
+
+CONFIG_REGULATOR=y
+# CONFIG_REGULATOR_DEBUG is not set
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
+# CONFIG_REGULATOR_USERSPACE_CONSUMER is not set
+# CONFIG_REGULATOR_88PG86X is not set
+# CONFIG_REGULATOR_ACT8865 is not set
+# CONFIG_REGULATOR_AD5398 is not set
+CONFIG_REGULATOR_ANATOP=y
+CONFIG_REGULATOR_DA9052=y
+# CONFIG_REGULATOR_DA9210 is not set
+# CONFIG_REGULATOR_DA9211 is not set
+# CONFIG_REGULATOR_FAN53555 is not set
+# CONFIG_REGULATOR_GPIO is not set
+# CONFIG_REGULATOR_ISL9305 is not set
+# CONFIG_REGULATOR_ISL6271A is not set
+# CONFIG_REGULATOR_LP3971 is not set
+# CONFIG_REGULATOR_LP3972 is not set
+# CONFIG_REGULATOR_LP872X is not set
+# CONFIG_REGULATOR_LP8755 is not set
+# CONFIG_REGULATOR_LTC3589 is not set
+# CONFIG_REGULATOR_LTC3676 is not set
+# CONFIG_REGULATOR_MAX1586 is not set
+CONFIG_REGULATOR_MAX17135=y
+# CONFIG_REGULATOR_MAX8649 is not set
+# CONFIG_REGULATOR_MAX8660 is not set
+# CONFIG_REGULATOR_MAX8952 is not set
+# CONFIG_REGULATOR_MAX8973 is not set
+CONFIG_REGULATOR_MC13XXX_CORE=y
+CONFIG_REGULATOR_MC13783=y
+CONFIG_REGULATOR_MC13892=y
+# CONFIG_REGULATOR_MCP16502 is not set
+# CONFIG_REGULATOR_MT6311 is not set
+CONFIG_REGULATOR_PFUZE100=y
+# CONFIG_REGULATOR_PV88060 is not set
+# CONFIG_REGULATOR_PV88080 is not set
+# CONFIG_REGULATOR_PV88090 is not set
+# CONFIG_REGULATOR_PWM is not set
+# CONFIG_REGULATOR_SLG51000 is not set
+# CONFIG_REGULATOR_SY8106A is not set
+# CONFIG_REGULATOR_SY8824X is not set
+# CONFIG_REGULATOR_TPS51632 is not set
+# CONFIG_REGULATOR_TPS62360 is not set
+# CONFIG_REGULATOR_TPS65023 is not set
+# CONFIG_REGULATOR_TPS6507X is not set
+# CONFIG_REGULATOR_TPS65132 is not set
+# CONFIG_REGULATOR_TPS6524X is not set
+# CONFIG_REGULATOR_VCTRL is not set
+CONFIG_RC_CORE=y
+CONFIG_RC_MAP=y
+# CONFIG_LIRC is not set
+CONFIG_RC_DECODERS=y
+CONFIG_IR_NEC_DECODER=y
+CONFIG_IR_RC5_DECODER=y
+CONFIG_IR_RC6_DECODER=y
+CONFIG_IR_JVC_DECODER=y
+CONFIG_IR_SONY_DECODER=y
+CONFIG_IR_SANYO_DECODER=y
+CONFIG_IR_SHARP_DECODER=y
+CONFIG_IR_MCE_KBD_DECODER=y
+CONFIG_IR_XMP_DECODER=y
+# CONFIG_IR_IMON_DECODER is not set
+# CONFIG_IR_RCMM_DECODER is not set
+# CONFIG_RC_DEVICES is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_IMX_IPUV3_CORE is not set
+# CONFIG_IMX_DPU_CORE is not set
+# CONFIG_IMX_LCDIF_CORE is not set
+# CONFIG_IMX_LCDIFV3_CORE is not set
+# CONFIG_DRM is not set
+# CONFIG_DRM_DP_CEC is not set
+
+#
+# ARM devices
+#
+# end of ARM devices
+
+#
+# ACP (Audio CoProcessor) Configuration
+#
+# end of ACP (Audio CoProcessor) Configuration
+
+# CONFIG_IMX8MP_HDMI_PAVI is not set
+# CONFIG_DRM_IMX_DCSS is not set
+
+#
+# Frame buffer Devices
+#
+# CONFIG_FB is not set
+# CONFIG_FB_MXC_DISP_FRAMEWORK is not set
+# end of Frame buffer Devices
+
+#
+# Backlight & LCD device support
+#
+# CONFIG_LCD_CLASS_DEVICE is not set
+# CONFIG_BACKLIGHT_CLASS_DEVICE is not set
+# end of Backlight & LCD device support
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+# end of Console display driver support
+# end of Graphics support
+
+# CONFIG_SOUND is not set
+
+#
+# HID support
+#
+CONFIG_HID=y
+# CONFIG_HID_BATTERY_STRENGTH is not set
+# CONFIG_HIDRAW is not set
+# CONFIG_UHID is not set
+CONFIG_HID_GENERIC=y
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_ACCUTOUCH is not set
+# CONFIG_HID_ACRUX is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_APPLEIR is not set
+# CONFIG_HID_ASUS is not set
+# CONFIG_HID_AUREAL is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_BETOP_FF is not set
+# CONFIG_HID_BIGBEN_FF is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_CORSAIR is not set
+# CONFIG_HID_COUGAR is not set
+# CONFIG_HID_MACALLY is not set
+# CONFIG_HID_CMEDIA is not set
+# CONFIG_HID_CREATIVE_SB0540 is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EMS_FF is not set
+# CONFIG_HID_ELAN is not set
+# CONFIG_HID_ELECOM is not set
+# CONFIG_HID_ELO is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_GEMBIRD is not set
+# CONFIG_HID_GFRM is not set
+# CONFIG_HID_HOLTEK is not set
+# CONFIG_HID_GT683R is not set
+# CONFIG_HID_KEYTOUCH is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_UCLOGIC is not set
+# CONFIG_HID_WALTOP is not set
+# CONFIG_HID_VIEWSONIC is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_ICADE is not set
+# CONFIG_HID_ITE is not set
+# CONFIG_HID_JABRA is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LCPOWER is not set
+# CONFIG_HID_LED is not set
+# CONFIG_HID_LENOVO is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MAGICMOUSE is not set
+# CONFIG_HID_MALTRON is not set
+# CONFIG_HID_MAYFLASH is not set
+# CONFIG_HID_REDRAGON is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_MULTITOUCH is not set
+# CONFIG_HID_NTI is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PENMOUNT is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_PLANTRONICS is not set
+# CONFIG_HID_PRIMAX is not set
+# CONFIG_HID_RETRODE is not set
+# CONFIG_HID_ROCCAT is not set
+# CONFIG_HID_SAITEK is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SONY is not set
+# CONFIG_HID_SPEEDLINK is not set
+# CONFIG_HID_STEAM is not set
+# CONFIG_HID_STEELSERIES is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_RMI is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TIVO is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THINGM is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_UDRAW_PS3 is not set
+# CONFIG_HID_U2FZERO is not set
+# CONFIG_HID_WACOM is not set
+# CONFIG_HID_WIIMOTE is not set
+# CONFIG_HID_XINMO is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+# CONFIG_HID_SENSOR_HUB is not set
+# CONFIG_HID_ALPS is not set
+# end of Special HID drivers
+
+#
+# USB HID support
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+# end of USB HID support
+
+#
+# I2C HID support
+#
+# CONFIG_I2C_HID is not set
+# end of I2C HID support
+# end of HID support
+
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_COMMON=y
+# CONFIG_USB_LED_TRIG is not set
+CONFIG_USB_ULPI_BUS=y
+# CONFIG_USB_CONN_GPIO is not set
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB=y
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEFAULT_PERSIST=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_LEDS_TRIGGER_USBPORT is not set
+CONFIG_USB_AUTOSUSPEND_DELAY=2
+# CONFIG_USB_MON is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_XHCI_HCD is not set
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+# CONFIG_USB_EHCI_FSL is not set
+CONFIG_USB_EHCI_MXC=y
+# CONFIG_USB_EHCI_HCD_PLATFORM is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_FOTG210_HCD is not set
+# CONFIG_USB_MAX3421_HCD is not set
+# CONFIG_USB_OHCI_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_IMX21_HCD is not set
+# CONFIG_USB_HCD_TEST_MODE is not set
+
+#
+# USB Device Class drivers
+#
+CONFIG_USB_ACM=m
+# CONFIG_USB_PRINTER is not set
+CONFIG_USB_WDM=y
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_REALTEK is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_STORAGE_ENE_UB6250 is not set
+# CONFIG_USB_UAS is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USBIP_CORE is not set
+# CONFIG_USB_CDNS3 is not set
+# CONFIG_USB_MUSB_HDRC is not set
+# CONFIG_USB_DWC3 is not set
+# CONFIG_USB_DWC2 is not set
+CONFIG_USB_CHIPIDEA=m
+CONFIG_USB_CHIPIDEA_OF=m
+CONFIG_USB_CHIPIDEA_UDC=y
+CONFIG_USB_CHIPIDEA_HOST=y
+# CONFIG_USB_ISP1760 is not set
+
+#
+# USB port drivers
+#
+CONFIG_USB_SERIAL=y
+# CONFIG_USB_SERIAL_CONSOLE is not set
+CONFIG_USB_SERIAL_GENERIC=y
+# CONFIG_USB_SERIAL_SIMPLE is not set
+# CONFIG_USB_SERIAL_AIRCABLE is not set
+# CONFIG_USB_SERIAL_ARK3116 is not set
+# CONFIG_USB_SERIAL_BELKIN is not set
+# CONFIG_USB_SERIAL_CH341 is not set
+# CONFIG_USB_SERIAL_WHITEHEAT is not set
+# CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
+# CONFIG_USB_SERIAL_CP210X is not set
+# CONFIG_USB_SERIAL_CYPRESS_M8 is not set
+# CONFIG_USB_SERIAL_EMPEG is not set
+# CONFIG_USB_SERIAL_FTDI_SIO is not set
+# CONFIG_USB_SERIAL_VISOR is not set
+# CONFIG_USB_SERIAL_IPAQ is not set
+# CONFIG_USB_SERIAL_IR is not set
+# CONFIG_USB_SERIAL_EDGEPORT is not set
+# CONFIG_USB_SERIAL_EDGEPORT_TI is not set
+# CONFIG_USB_SERIAL_F81232 is not set
+# CONFIG_USB_SERIAL_F8153X is not set
+# CONFIG_USB_SERIAL_GARMIN is not set
+# CONFIG_USB_SERIAL_IPW is not set
+# CONFIG_USB_SERIAL_IUU is not set
+# CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
+# CONFIG_USB_SERIAL_KEYSPAN is not set
+# CONFIG_USB_SERIAL_KLSI is not set
+# CONFIG_USB_SERIAL_KOBIL_SCT is not set
+# CONFIG_USB_SERIAL_MCT_U232 is not set
+# CONFIG_USB_SERIAL_METRO is not set
+# CONFIG_USB_SERIAL_MOS7720 is not set
+# CONFIG_USB_SERIAL_MOS7840 is not set
+# CONFIG_USB_SERIAL_MXUPORT is not set
+# CONFIG_USB_SERIAL_NAVMAN is not set
+# CONFIG_USB_SERIAL_PL2303 is not set
+# CONFIG_USB_SERIAL_OTI6858 is not set
+# CONFIG_USB_SERIAL_QCAUX is not set
+# CONFIG_USB_SERIAL_QUALCOMM is not set
+# CONFIG_USB_SERIAL_SPCP8X5 is not set
+# CONFIG_USB_SERIAL_SAFE is not set
+# CONFIG_USB_SERIAL_SIERRAWIRELESS is not set
+# CONFIG_USB_SERIAL_SYMBOL is not set
+# CONFIG_USB_SERIAL_TI is not set
+# CONFIG_USB_SERIAL_CYBERJACK is not set
+# CONFIG_USB_SERIAL_XIRCOM is not set
+CONFIG_USB_SERIAL_WWAN=y
+CONFIG_USB_SERIAL_OPTION=y
+# CONFIG_USB_SERIAL_OMNINET is not set
+# CONFIG_USB_SERIAL_OPTICON is not set
+# CONFIG_USB_SERIAL_XSENS_MT is not set
+# CONFIG_USB_SERIAL_WISHBONE is not set
+# CONFIG_USB_SERIAL_SSU100 is not set
+# CONFIG_USB_SERIAL_QT2 is not set
+# CONFIG_USB_SERIAL_UPD78F0730 is not set
+# CONFIG_USB_SERIAL_DEBUG is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+CONFIG_USB_EHSET_TEST_FIXTURE=m
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+# CONFIG_USB_EZUSB_FX2 is not set
+# CONFIG_USB_HUB_USB251XB is not set
+# CONFIG_USB_HSIC_USB3503 is not set
+# CONFIG_USB_HSIC_USB4604 is not set
+# CONFIG_USB_LINK_LAYER_TEST is not set
+# CONFIG_USB_CHAOSKEY is not set
+
+#
+# USB Physical Layer drivers
+#
+CONFIG_USB_PHY=y
+CONFIG_NOP_USB_XCEIV=m
+# CONFIG_AM335X_PHY_USB is not set
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_USB_ISP1301 is not set
+CONFIG_USB_MXS_PHY=y
+# CONFIG_USB_ULPI is not set
+# end of USB Physical Layer drivers
+
+CONFIG_USB_GADGET=m
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS=2
+# CONFIG_U_SERIAL_CONSOLE is not set
+
+#
+# USB Peripheral Controller
+#
+# CONFIG_USB_FSL_USB2 is not set
+# CONFIG_USB_FUSB300 is not set
+# CONFIG_USB_FOTG210_UDC is not set
+# CONFIG_USB_GR_UDC is not set
+# CONFIG_USB_R8A66597 is not set
+# CONFIG_USB_PXA27X is not set
+# CONFIG_USB_MV_UDC is not set
+# CONFIG_USB_MV_U3D is not set
+# CONFIG_USB_SNP_UDC_PLAT is not set
+# CONFIG_USB_M66592 is not set
+# CONFIG_USB_BDC_UDC is not set
+# CONFIG_USB_NET2272 is not set
+# CONFIG_USB_GADGET_XILINX is not set
+# CONFIG_USB_DUMMY_HCD is not set
+# end of USB Peripheral Controller
+
+CONFIG_USB_LIBCOMPOSITE=m
+CONFIG_USB_F_ACM=m
+CONFIG_USB_F_SS_LB=m
+CONFIG_USB_U_SERIAL=m
+CONFIG_USB_U_ETHER=m
+CONFIG_USB_F_SERIAL=m
+CONFIG_USB_F_OBEX=m
+CONFIG_USB_F_NCM=m
+CONFIG_USB_F_ECM=m
+CONFIG_USB_F_EEM=m
+CONFIG_USB_F_SUBSET=m
+CONFIG_USB_F_RNDIS=m
+CONFIG_USB_F_MASS_STORAGE=m
+CONFIG_USB_F_FS=m
+CONFIG_USB_CONFIGFS=m
+CONFIG_USB_CONFIGFS_SERIAL=y
+CONFIG_USB_CONFIGFS_ACM=y
+CONFIG_USB_CONFIGFS_OBEX=y
+CONFIG_USB_CONFIGFS_NCM=y
+CONFIG_USB_CONFIGFS_ECM=y
+CONFIG_USB_CONFIGFS_ECM_SUBSET=y
+CONFIG_USB_CONFIGFS_RNDIS=y
+CONFIG_USB_CONFIGFS_EEM=y
+CONFIG_USB_CONFIGFS_MASS_STORAGE=y
+CONFIG_USB_CONFIGFS_F_LB_SS=y
+CONFIG_USB_CONFIGFS_F_FS=y
+# CONFIG_USB_CONFIGFS_F_HID is not set
+# CONFIG_USB_CONFIGFS_F_PRINTER is not set
+CONFIG_USB_ZERO=m
+CONFIG_USB_ETH=m
+CONFIG_USB_ETH_RNDIS=y
+# CONFIG_USB_ETH_EEM is not set
+CONFIG_USB_G_NCM=m
+CONFIG_USB_GADGETFS=m
+# CONFIG_USB_FUNCTIONFS is not set
+CONFIG_USB_MASS_STORAGE=m
+CONFIG_USB_G_SERIAL=m
+# CONFIG_USB_G_PRINTER is not set
+# CONFIG_USB_CDC_COMPOSITE is not set
+# CONFIG_USB_G_ACM_MS is not set
+# CONFIG_USB_G_MULTI is not set
+# CONFIG_USB_G_HID is not set
+# CONFIG_USB_G_DBGP is not set
+# CONFIG_TYPEC is not set
+CONFIG_USB_ROLE_SWITCH=y
+CONFIG_MMC=y
+CONFIG_PWRSEQ_EMMC=y
+CONFIG_PWRSEQ_SIMPLE=y
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_MINORS=8
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_DEBUG is not set
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_IO_ACCESSORS=y
+CONFIG_MMC_SDHCI_PLTFM=y
+# CONFIG_MMC_SDHCI_OF_ARASAN is not set
+# CONFIG_MMC_SDHCI_OF_ASPEED is not set
+# CONFIG_MMC_SDHCI_OF_AT91 is not set
+# CONFIG_MMC_SDHCI_OF_ESDHC is not set
+# CONFIG_MMC_SDHCI_OF_DWCMSHC is not set
+# CONFIG_MMC_SDHCI_CADENCE is not set
+CONFIG_MMC_SDHCI_ESDHC_IMX=y
+# CONFIG_MMC_SDHCI_F_SDH30 is not set
+# CONFIG_MMC_MXC is not set
+# CONFIG_MMC_SPI is not set
+# CONFIG_MMC_DW is not set
+# CONFIG_MMC_VUB300 is not set
+# CONFIG_MMC_USHC is not set
+# CONFIG_MMC_USDHI6ROL0 is not set
+CONFIG_MMC_CQHCI=y
+# CONFIG_MMC_MTK is not set
+# CONFIG_MMC_SDHCI_XENON is not set
+# CONFIG_MMC_SDHCI_OMAP is not set
+# CONFIG_MMC_SDHCI_AM654 is not set
+# CONFIG_MEMSTICK is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+# CONFIG_LEDS_CLASS_FLASH is not set
+# CONFIG_LEDS_BRIGHTNESS_HW_CHANGED is not set
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_AN30259A is not set
+# CONFIG_LEDS_BCM6328 is not set
+# CONFIG_LEDS_BCM6358 is not set
+# CONFIG_LEDS_CR0014114 is not set
+# CONFIG_LEDS_LM3530 is not set
+# CONFIG_LEDS_LM3532 is not set
+# CONFIG_LEDS_LM3642 is not set
+# CONFIG_LEDS_LM3692X is not set
+# CONFIG_LEDS_PCA9532 is not set
+CONFIG_LEDS_GPIO=y
+# CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_LP3952 is not set
+# CONFIG_LEDS_LP5521 is not set
+# CONFIG_LEDS_LP5523 is not set
+# CONFIG_LEDS_LP5562 is not set
+# CONFIG_LEDS_LP8501 is not set
+# CONFIG_LEDS_LP8860 is not set
+# CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_PCA963X is not set
+# CONFIG_LEDS_DA9052 is not set
+# CONFIG_LEDS_DAC124S085 is not set
+# CONFIG_LEDS_PWM is not set
+# CONFIG_LEDS_REGULATOR is not set
+# CONFIG_LEDS_BD2802 is not set
+# CONFIG_LEDS_LT3593 is not set
+# CONFIG_LEDS_MC13783 is not set
+# CONFIG_LEDS_TCA6507 is not set
+# CONFIG_LEDS_TLC591XX is not set
+# CONFIG_LEDS_LM355x is not set
+# CONFIG_LEDS_IS31FL319X is not set
+# CONFIG_LEDS_IS31FL32XX is not set
+
+#
+# LED driver for blink(1) USB RGB LED is under Special HID drivers (HID_THINGM)
+#
+# CONFIG_LEDS_BLINKM is not set
+# CONFIG_LEDS_SYSCON is not set
+# CONFIG_LEDS_MLXREG is not set
+# CONFIG_LEDS_USER is not set
+# CONFIG_LEDS_SPI_BYTE is not set
+# CONFIG_LEDS_TI_LMU_COMMON is not set
+
+#
+# LED Triggers
+#
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_LEDS_TRIGGER_ONESHOT=y
+# CONFIG_LEDS_TRIGGER_DISK is not set
+# CONFIG_LEDS_TRIGGER_MTD is not set
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+CONFIG_LEDS_TRIGGER_BACKLIGHT=y
+# CONFIG_LEDS_TRIGGER_CPU is not set
+# CONFIG_LEDS_TRIGGER_ACTIVITY is not set
+CONFIG_LEDS_TRIGGER_GPIO=y
+# CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
+
+#
+# iptables trigger is under Netfilter config (LED target)
+#
+# CONFIG_LEDS_TRIGGER_TRANSIENT is not set
+# CONFIG_LEDS_TRIGGER_CAMERA is not set
+# CONFIG_LEDS_TRIGGER_PANIC is not set
+# CONFIG_LEDS_TRIGGER_NETDEV is not set
+# CONFIG_LEDS_TRIGGER_PATTERN is not set
+# CONFIG_LEDS_TRIGGER_AUDIO is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_INFINIBAND is not set
+CONFIG_EDAC_ATOMIC_SCRUB=y
+CONFIG_EDAC_SUPPORT=y
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+CONFIG_RTC_SYSTOHC=y
+CONFIG_RTC_SYSTOHC_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+CONFIG_RTC_NVMEM=y
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+CONFIG_RTC_INTF_DEV_UIE_EMUL=y
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_ABB5ZES3 is not set
+# CONFIG_RTC_DRV_ABEOZ9 is not set
+# CONFIG_RTC_DRV_ABX80X is not set
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_HYM8563 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_ISL12026 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8523 is not set
+# CONFIG_RTC_DRV_PCF85063 is not set
+CONFIG_RTC_DRV_PCF85363=y
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8010 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_RV3028 is not set
+# CONFIG_RTC_DRV_RV8803 is not set
+# CONFIG_RTC_DRV_SD3078 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T93 is not set
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1302 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1343 is not set
+# CONFIG_RTC_DRV_DS1347 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6916 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RX4581 is not set
+# CONFIG_RTC_DRV_RX6110 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_PCF2123 is not set
+# CONFIG_RTC_DRV_MCP795 is not set
+CONFIG_RTC_I2C_AND_SPI=y
+
+#
+# SPI and I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_PCF2127 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1685_FAMILY is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_DS2404 is not set
+# CONFIG_RTC_DRV_DA9052 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+# CONFIG_RTC_DRV_ZYNQMP is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_IMXDI is not set
+# CONFIG_RTC_DRV_CADENCE is not set
+# CONFIG_RTC_DRV_FTRTC010 is not set
+CONFIG_RTC_DRV_MC13XXX=y
+CONFIG_RTC_DRV_MXC=y
+# CONFIG_RTC_DRV_MXC_V2 is not set
+CONFIG_RTC_DRV_SNVS=y
+# CONFIG_RTC_DRV_IMX_RPMSG is not set
+# CONFIG_RTC_DRV_R7301 is not set
+
+#
+# HID Sensor RTC drivers
+#
+CONFIG_DMADEVICES=y
+# CONFIG_DMADEVICES_DEBUG is not set
+
+#
+# DMA Devices
+#
+CONFIG_DMA_ENGINE=y
+CONFIG_DMA_VIRTUAL_CHANNELS=y
+CONFIG_DMA_OF=y
+# CONFIG_ALTERA_MSGDMA is not set
+# CONFIG_DW_AXI_DMAC is not set
+CONFIG_FSL_EDMA=y
+# CONFIG_FSL_QDMA is not set
+# CONFIG_FSL_EDMA_V3 is not set
+# CONFIG_IMX_DMA is not set
+CONFIG_IMX_SDMA=y
+# CONFIG_INTEL_IDMA64 is not set
+CONFIG_MXS_DMA=y
+CONFIG_MXC_PXP_V2=y
+CONFIG_MXC_PXP_V3=y
+CONFIG_MXC_PXP_CLIENT_DEVICE=y
+CONFIG_MX3_IPU=y
+CONFIG_MX3_IPU_IRQS=4
+# CONFIG_NBPFAXI_DMA is not set
+# CONFIG_QCOM_HIDMA_MGMT is not set
+# CONFIG_QCOM_HIDMA is not set
+# CONFIG_DW_DMAC is not set
+
+#
+# DMA Clients
+#
+# CONFIG_ASYNC_TX_DMA is not set
+# CONFIG_DMATEST is not set
+
+#
+# DMABUF options
+#
+# CONFIG_SYNC_FILE is not set
+# CONFIG_UDMABUF is not set
+# CONFIG_DMABUF_SELFTESTS is not set
+# end of DMABUF options
+
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+# CONFIG_VIRT_DRIVERS is not set
+CONFIG_VIRTIO_MENU=y
+# CONFIG_VIRTIO_MMIO is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+# end of Microsoft Hyper-V guest support
+
+# CONFIG_GREYBUS is not set
+CONFIG_STAGING=y
+# CONFIG_PRISM2_USB is not set
+# CONFIG_COMEDI is not set
+# CONFIG_RTLLIB is not set
+# CONFIG_RTL8723BS is not set
+# CONFIG_R8712U is not set
+# CONFIG_R8188EU is not set
+# CONFIG_VT6656 is not set
+
+#
+# IIO staging drivers
+#
+
+#
+# Accelerometers
+#
+# CONFIG_ADIS16203 is not set
+# CONFIG_ADIS16240 is not set
+# end of Accelerometers
+
+#
+# Analog to digital converters
+#
+# CONFIG_AD7816 is not set
+# CONFIG_AD7192 is not set
+# CONFIG_AD7280 is not set
+# end of Analog to digital converters
+
+#
+# Analog digital bi-direction converters
+#
+# CONFIG_ADT7316 is not set
+# end of Analog digital bi-direction converters
+
+#
+# Capacitance to digital converters
+#
+# CONFIG_AD7150 is not set
+# CONFIG_AD7746 is not set
+# end of Capacitance to digital converters
+
+#
+# Direct Digital Synthesis
+#
+# CONFIG_AD9832 is not set
+# CONFIG_AD9834 is not set
+# end of Direct Digital Synthesis
+
+#
+# Network Analyzer, Impedance Converters
+#
+# CONFIG_AD5933 is not set
+# end of Network Analyzer, Impedance Converters
+
+#
+# Active energy metering IC
+#
+# CONFIG_ADE7854 is not set
+# end of Active energy metering IC
+
+#
+# Resolver to digital converters
+#
+# CONFIG_AD2S1210 is not set
+# end of Resolver to digital converters
+# end of IIO staging drivers
+
+#
+# Speakup console speech
+#
+# CONFIG_SPEAKUP is not set
+# end of Speakup console speech
+
+CONFIG_STAGING_MEDIA=y
+
+#
+# Android
+#
+# CONFIG_ION is not set
+# end of Android
+
+# CONFIG_STAGING_BOARD is not set
+# CONFIG_LTE_GDM724X is not set
+# CONFIG_GS_FPGABOOT is not set
+# CONFIG_UNISYSSPAR is not set
+# CONFIG_COMMON_CLK_XLNX_CLKWZRD is not set
+# CONFIG_WILC1000_SDIO is not set
+# CONFIG_WILC1000_SPI is not set
+# CONFIG_MOST is not set
+# CONFIG_KS7010 is not set
+# CONFIG_PI433 is not set
+
+#
+# Gasket devices
+#
+# end of Gasket devices
+
+# CONFIG_XIL_AXIS_FIFO is not set
+# CONFIG_FIELDBUS_DEV is not set
+# CONFIG_USB_WUSB_CBAF is not set
+# CONFIG_UWB is not set
+# CONFIG_EXFAT_FS is not set
+# CONFIG_FSL_SDK_DPA is not set
+# CONFIG_FSL_PPFE is not set
+# CONFIG_GOLDFISH is not set
+# CONFIG_MFD_CROS_EC is not set
+# CONFIG_CHROME_PLATFORMS is not set
+# CONFIG_MELLANOX_PLATFORM is not set
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_HAVE_CLK_PREPARE=y
+CONFIG_COMMON_CLK=y
+
+#
+# Common Clock Framework
+#
+# CONFIG_CLK_HSDK is not set
+# CONFIG_COMMON_CLK_MAX9485 is not set
+# CONFIG_COMMON_CLK_SI5341 is not set
+# CONFIG_COMMON_CLK_SI5351 is not set
+# CONFIG_COMMON_CLK_SI514 is not set
+# CONFIG_COMMON_CLK_SI544 is not set
+# CONFIG_COMMON_CLK_SI570 is not set
+# CONFIG_COMMON_CLK_CDCE706 is not set
+# CONFIG_COMMON_CLK_CDCE925 is not set
+# CONFIG_COMMON_CLK_CS2000_CP is not set
+# CONFIG_CLK_QORIQ is not set
+# CONFIG_COMMON_CLK_PWM is not set
+# CONFIG_COMMON_CLK_VC5 is not set
+# CONFIG_COMMON_CLK_FIXED_MMIO is not set
+CONFIG_MXC_CLK=y
+# CONFIG_ARCH_S32_CLK is not set
+# end of Common Clock Framework
+
+# CONFIG_HWSPINLOCK is not set
+
+#
+# Clock Source drivers
+#
+CONFIG_TIMER_OF=y
+CONFIG_TIMER_PROBE=y
+CONFIG_CLKSRC_MMIO=y
+CONFIG_ARM_ARCH_TIMER=y
+CONFIG_ARM_ARCH_TIMER_EVTSTREAM=y
+CONFIG_ARM_GLOBAL_TIMER=y
+CONFIG_CLKSRC_ARM_GLOBAL_TIMER_SCHED_CLOCK=y
+CONFIG_CLKSRC_IMX_GPT=y
+CONFIG_CLKSRC_IMX_TPM=y
+# end of Clock Source drivers
+
+# CONFIG_MAILBOX is not set
+# CONFIG_IOMMU_SUPPORT is not set
+
+#
+# Remoteproc drivers
+#
+# CONFIG_REMOTEPROC is not set
+# end of Remoteproc drivers
+
+#
+# Rpmsg drivers
+#
+# CONFIG_RPMSG_VIRTIO is not set
+# CONFIG_IMX_RPMSG_PINGPONG is not set
+# CONFIG_IMX_RPMSG_TTY is not set
+# end of Rpmsg drivers
+
+# CONFIG_SOUNDWIRE is not set
+
+#
+# SOC (System On Chip) specific Drivers
+#
+
+#
+# Amlogic SoC drivers
+#
+# end of Amlogic SoC drivers
+
+#
+# Aspeed SoC drivers
+#
+# end of Aspeed SoC drivers
+
+#
+# Broadcom SoC drivers
+#
+# CONFIG_SOC_BRCMSTB is not set
+# end of Broadcom SoC drivers
+
+#
+# NXP/Freescale QorIQ SoC drivers
+#
+# CONFIG_QUICC_ENGINE is not set
+# CONFIG_FSL_QIXIS is not set
+# CONFIG_FSL_RCPM is not set
+# end of NXP/Freescale QorIQ SoC drivers
+
+#
+# i.MX SoC drivers
+#
+CONFIG_IMX_GPCV2_PM_DOMAINS=y
+# CONFIG_IMX8M_PM_DOMAINS is not set
+# end of i.MX SoC drivers
+
+#
+# Qualcomm SoC drivers
+#
+# end of Qualcomm SoC drivers
+
+# CONFIG_SOC_TI is not set
+
+#
+# Xilinx SoC drivers
+#
+# CONFIG_XILINX_VCU is not set
+# end of Xilinx SoC drivers
+# end of SOC (System On Chip) specific Drivers
+
+# CONFIG_PM_DEVFREQ is not set
+CONFIG_EXTCON=y
+
+#
+# Extcon Device Drivers
+#
+# CONFIG_EXTCON_ADC_JACK is not set
+# CONFIG_EXTCON_FSA9480 is not set
+# CONFIG_EXTCON_GPIO is not set
+# CONFIG_EXTCON_MAX3355 is not set
+# CONFIG_EXTCON_PTN5150 is not set
+# CONFIG_EXTCON_RT8973A is not set
+# CONFIG_EXTCON_SM5502 is not set
+CONFIG_EXTCON_USB_GPIO=y
+# CONFIG_MEMORY is not set
+CONFIG_IIO=y
+CONFIG_IIO_BUFFER=y
+# CONFIG_IIO_BUFFER_CB is not set
+# CONFIG_IIO_BUFFER_HW_CONSUMER is not set
+CONFIG_IIO_KFIFO_BUF=y
+CONFIG_IIO_TRIGGERED_BUFFER=y
+# CONFIG_IIO_CONFIGFS is not set
+CONFIG_IIO_TRIGGER=y
+CONFIG_IIO_CONSUMERS_PER_TRIGGER=2
+# CONFIG_IIO_SW_DEVICE is not set
+# CONFIG_IIO_SW_TRIGGER is not set
+
+#
+# Accelerometers
+#
+# CONFIG_ADIS16201 is not set
+# CONFIG_ADIS16209 is not set
+# CONFIG_ADXL345_I2C is not set
+# CONFIG_ADXL345_SPI is not set
+# CONFIG_ADXL372_SPI is not set
+# CONFIG_ADXL372_I2C is not set
+# CONFIG_BMA180 is not set
+# CONFIG_BMA220 is not set
+# CONFIG_BMC150_ACCEL is not set
+# CONFIG_DA280 is not set
+# CONFIG_DA311 is not set
+# CONFIG_DMARD06 is not set
+# CONFIG_DMARD09 is not set
+# CONFIG_DMARD10 is not set
+# CONFIG_IIO_ST_ACCEL_3AXIS is not set
+# CONFIG_KXSD9 is not set
+# CONFIG_KXCJK1013 is not set
+# CONFIG_MC3230 is not set
+# CONFIG_MMA7455_I2C is not set
+# CONFIG_MMA7455_SPI is not set
+# CONFIG_MMA7660 is not set
+# CONFIG_MMA8452 is not set
+# CONFIG_MMA9551 is not set
+# CONFIG_MMA9553 is not set
+# CONFIG_MXC4005 is not set
+# CONFIG_MXC6255 is not set
+# CONFIG_SCA3000 is not set
+# CONFIG_STK8312 is not set
+# CONFIG_STK8BA50 is not set
+# end of Accelerometers
+
+#
+# Analog to digital converters
+#
+# CONFIG_AD7124 is not set
+# CONFIG_AD7266 is not set
+# CONFIG_AD7291 is not set
+# CONFIG_AD7298 is not set
+# CONFIG_AD7476 is not set
+# CONFIG_AD7606_IFACE_PARALLEL is not set
+# CONFIG_AD7606_IFACE_SPI is not set
+# CONFIG_AD7766 is not set
+# CONFIG_AD7768_1 is not set
+# CONFIG_AD7780 is not set
+# CONFIG_AD7791 is not set
+# CONFIG_AD7793 is not set
+# CONFIG_AD7887 is not set
+# CONFIG_AD7923 is not set
+# CONFIG_AD7949 is not set
+# CONFIG_AD799X is not set
+# CONFIG_CC10001_ADC is not set
+# CONFIG_ENVELOPE_DETECTOR is not set
+# CONFIG_HI8435 is not set
+# CONFIG_HX711 is not set
+# CONFIG_INA2XX_ADC is not set
+CONFIG_IMX7D_ADC=y
+# CONFIG_IMX8QXP_ADC is not set
+# CONFIG_LTC2471 is not set
+# CONFIG_LTC2485 is not set
+# CONFIG_LTC2497 is not set
+# CONFIG_MAX1027 is not set
+# CONFIG_MAX11100 is not set
+# CONFIG_MAX1118 is not set
+# CONFIG_MAX1363 is not set
+# CONFIG_MAX9611 is not set
+# CONFIG_MCP320X is not set
+# CONFIG_MCP3422 is not set
+# CONFIG_MCP3911 is not set
+# CONFIG_NAU7802 is not set
+# CONFIG_SD_ADC_MODULATOR is not set
+# CONFIG_TI_ADC081C is not set
+# CONFIG_TI_ADC0832 is not set
+# CONFIG_TI_ADC084S021 is not set
+# CONFIG_TI_ADC12138 is not set
+# CONFIG_TI_ADC108S102 is not set
+# CONFIG_TI_ADC128S052 is not set
+# CONFIG_TI_ADC161S626 is not set
+# CONFIG_TI_ADS1015 is not set
+# CONFIG_TI_ADS7950 is not set
+# CONFIG_TI_ADS8344 is not set
+# CONFIG_TI_ADS8688 is not set
+# CONFIG_TI_ADS124S08 is not set
+# CONFIG_TI_TLC4541 is not set
+CONFIG_VF610_ADC=y
+# CONFIG_XILINX_XADC is not set
+# end of Analog to digital converters
+
+#
+# Analog Front Ends
+#
+# CONFIG_IIO_RESCALE is not set
+# end of Analog Front Ends
+
+#
+# Amplifiers
+#
+# CONFIG_AD8366 is not set
+# end of Amplifiers
+
+#
+# Chemical Sensors
+#
+# CONFIG_ATLAS_PH_SENSOR is not set
+# CONFIG_BME680 is not set
+# CONFIG_CCS811 is not set
+# CONFIG_IAQCORE is not set
+# CONFIG_SENSIRION_SGP30 is not set
+# CONFIG_SPS30 is not set
+# CONFIG_VZ89X is not set
+# end of Chemical Sensors
+
+#
+# Hid Sensor IIO Common
+#
+# end of Hid Sensor IIO Common
+
+#
+# SSP Sensor Common
+#
+# CONFIG_IIO_SSP_SENSORHUB is not set
+# end of SSP Sensor Common
+
+CONFIG_IIO_ST_SENSORS_I2C=y
+CONFIG_IIO_ST_SENSORS_SPI=y
+CONFIG_IIO_ST_SENSORS_CORE=y
+
+#
+# Digital to analog converters
+#
+# CONFIG_AD5064 is not set
+# CONFIG_AD5360 is not set
+# CONFIG_AD5380 is not set
+# CONFIG_AD5421 is not set
+# CONFIG_AD5446 is not set
+# CONFIG_AD5449 is not set
+# CONFIG_AD5592R is not set
+# CONFIG_AD5593R is not set
+# CONFIG_AD5504 is not set
+# CONFIG_AD5624R_SPI is not set
+# CONFIG_LTC1660 is not set
+# CONFIG_LTC2632 is not set
+# CONFIG_AD5686_SPI is not set
+# CONFIG_AD5696_I2C is not set
+# CONFIG_AD5755 is not set
+# CONFIG_AD5758 is not set
+# CONFIG_AD5761 is not set
+# CONFIG_AD5764 is not set
+# CONFIG_AD5791 is not set
+# CONFIG_AD7303 is not set
+# CONFIG_AD8801 is not set
+# CONFIG_DPOT_DAC is not set
+# CONFIG_DS4424 is not set
+# CONFIG_M62332 is not set
+# CONFIG_MAX517 is not set
+# CONFIG_MAX5821 is not set
+# CONFIG_MCP4725 is not set
+# CONFIG_MCP4922 is not set
+# CONFIG_TI_DAC082S085 is not set
+# CONFIG_TI_DAC5571 is not set
+# CONFIG_TI_DAC7311 is not set
+# CONFIG_TI_DAC7612 is not set
+# CONFIG_VF610_DAC is not set
+# end of Digital to analog converters
+
+#
+# IIO dummy driver
+#
+# end of IIO dummy driver
+
+#
+# Frequency Synthesizers DDS/PLL
+#
+
+#
+# Clock Generator/Distribution
+#
+# CONFIG_AD9523 is not set
+# end of Clock Generator/Distribution
+
+#
+# Phase-Locked Loop (PLL) frequency synthesizers
+#
+# CONFIG_ADF4350 is not set
+# CONFIG_ADF4371 is not set
+# end of Phase-Locked Loop (PLL) frequency synthesizers
+# end of Frequency Synthesizers DDS/PLL
+
+#
+# Digital gyroscope sensors
+#
+# CONFIG_ADIS16080 is not set
+# CONFIG_ADIS16130 is not set
+# CONFIG_ADIS16136 is not set
+# CONFIG_ADIS16260 is not set
+# CONFIG_ADXRS450 is not set
+# CONFIG_BMG160 is not set
+# CONFIG_FXAS21002C is not set
+# CONFIG_MPU3050_I2C is not set
+# CONFIG_IIO_ST_GYRO_3AXIS is not set
+# CONFIG_ITG3200 is not set
+# end of Digital gyroscope sensors
+
+#
+# Health Sensors
+#
+
+#
+# Heart Rate Monitors
+#
+# CONFIG_AFE4403 is not set
+# CONFIG_AFE4404 is not set
+# CONFIG_MAX30100 is not set
+# CONFIG_MAX30102 is not set
+# end of Heart Rate Monitors
+# end of Health Sensors
+
+#
+# Humidity sensors
+#
+# CONFIG_AM2315 is not set
+# CONFIG_DHT11 is not set
+# CONFIG_HDC100X is not set
+# CONFIG_HTS221 is not set
+# CONFIG_HTU21 is not set
+# CONFIG_SI7005 is not set
+# CONFIG_SI7020 is not set
+# end of Humidity sensors
+
+#
+# Inertial measurement units
+#
+# CONFIG_ADIS16400 is not set
+# CONFIG_ADIS16460 is not set
+# CONFIG_ADIS16480 is not set
+# CONFIG_BMI160_I2C is not set
+# CONFIG_BMI160_SPI is not set
+# CONFIG_KMX61 is not set
+# CONFIG_INV_MPU6050_I2C is not set
+# CONFIG_INV_MPU6050_SPI is not set
+# CONFIG_IIO_ST_LSM6DSX is not set
+CONFIG_ST_LSM6DSM_IIO=y
+CONFIG_ST_LSM6DSM_I2C_IIO=y
+CONFIG_ST_LSM6DSM_SPI_IIO=y
+CONFIG_ST_LSM6DSM_IIO_LIMIT_FIFO=0
+# CONFIG_ST_LSM6DSM_STEP_COUNTER_ON_DURING_SUSPEND is not set
+# CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT is not set
+# CONFIG_ST_LSM6DSM_XL_DATA_INJECTION is not set
+# end of Inertial measurement units
+
+#
+# Light sensors
+#
+# CONFIG_ADJD_S311 is not set
+# CONFIG_AL3320A is not set
+# CONFIG_APDS9300 is not set
+# CONFIG_APDS9960 is not set
+# CONFIG_BH1750 is not set
+# CONFIG_BH1780 is not set
+# CONFIG_CM32181 is not set
+# CONFIG_CM3232 is not set
+# CONFIG_CM3323 is not set
+# CONFIG_CM3605 is not set
+# CONFIG_CM36651 is not set
+# CONFIG_GP2AP020A00F is not set
+# CONFIG_SENSORS_ISL29018 is not set
+# CONFIG_SENSORS_ISL29028 is not set
+# CONFIG_ISL29125 is not set
+# CONFIG_JSA1212 is not set
+# CONFIG_RPR0521 is not set
+# CONFIG_LTR501 is not set
+# CONFIG_LV0104CS is not set
+# CONFIG_MAX44000 is not set
+# CONFIG_MAX44009 is not set
+# CONFIG_NOA1305 is not set
+# CONFIG_OPT3001 is not set
+# CONFIG_PA12203001 is not set
+# CONFIG_SI1133 is not set
+# CONFIG_SI1145 is not set
+# CONFIG_STK3310 is not set
+# CONFIG_ST_UVIS25 is not set
+# CONFIG_TCS3414 is not set
+# CONFIG_TCS3472 is not set
+# CONFIG_SENSORS_TSL2563 is not set
+# CONFIG_TSL2583 is not set
+# CONFIG_TSL2772 is not set
+# CONFIG_TSL4531 is not set
+# CONFIG_US5182D is not set
+# CONFIG_VCNL4000 is not set
+# CONFIG_VCNL4035 is not set
+# CONFIG_VEML6070 is not set
+# CONFIG_VL6180 is not set
+# CONFIG_ZOPT2201 is not set
+# end of Light sensors
+
+#
+# Magnetometer sensors
+#
+# CONFIG_AK8974 is not set
+# CONFIG_AK8975 is not set
+# CONFIG_AK09911 is not set
+# CONFIG_BMC150_MAGN_I2C is not set
+# CONFIG_BMC150_MAGN_SPI is not set
+CONFIG_MAG3110=y
+CONFIG_ST_MAG40_IIO=y
+CONFIG_ST_MAG40_I2C_IIO=y
+CONFIG_ST_MAG40_SPI_IIO=y
+# CONFIG_MMC35240 is not set
+CONFIG_IIO_ST_MAGN_3AXIS=y
+CONFIG_IIO_ST_MAGN_I2C_3AXIS=y
+CONFIG_IIO_ST_MAGN_SPI_3AXIS=y
+# CONFIG_SENSORS_HMC5843_I2C is not set
+# CONFIG_SENSORS_HMC5843_SPI is not set
+# CONFIG_SENSORS_RM3100_I2C is not set
+# CONFIG_SENSORS_RM3100_SPI is not set
+# end of Magnetometer sensors
+
+#
+# Multiplexers
+#
+# CONFIG_IIO_MUX is not set
+# end of Multiplexers
+
+#
+# Inclinometer sensors
+#
+# end of Inclinometer sensors
+
+#
+# Triggers - standalone
+#
+# CONFIG_IIO_INTERRUPT_TRIGGER is not set
+# CONFIG_IIO_SYSFS_TRIGGER is not set
+# end of Triggers - standalone
+
+#
+# Digital potentiometers
+#
+# CONFIG_AD5272 is not set
+# CONFIG_DS1803 is not set
+# CONFIG_MAX5432 is not set
+# CONFIG_MAX5481 is not set
+# CONFIG_MAX5487 is not set
+# CONFIG_MCP4018 is not set
+# CONFIG_MCP4131 is not set
+# CONFIG_MCP4531 is not set
+# CONFIG_MCP41010 is not set
+# CONFIG_TPL0102 is not set
+# end of Digital potentiometers
+
+#
+# Digital potentiostats
+#
+# CONFIG_LMP91000 is not set
+# end of Digital potentiostats
+
+#
+# Pressure sensors
+#
+# CONFIG_ABP060MG is not set
+# CONFIG_BMP280 is not set
+# CONFIG_DPS310 is not set
+# CONFIG_HP03 is not set
+# CONFIG_MPL115_I2C is not set
+# CONFIG_MPL115_SPI is not set
+# CONFIG_MPL3115 is not set
+# CONFIG_MS5611 is not set
+# CONFIG_MS5637 is not set
+# CONFIG_IIO_ST_PRESS is not set
+# CONFIG_T5403 is not set
+# CONFIG_HP206C is not set
+# CONFIG_ZPA2326 is not set
+# end of Pressure sensors
+
+#
+# Lightning sensors
+#
+# CONFIG_AS3935 is not set
+# end of Lightning sensors
+
+#
+# Proximity and distance sensors
+#
+# CONFIG_ISL29501 is not set
+# CONFIG_LIDAR_LITE_V2 is not set
+# CONFIG_MB1232 is not set
+# CONFIG_RFD77402 is not set
+# CONFIG_SRF04 is not set
+# CONFIG_SX9500 is not set
+# CONFIG_SRF08 is not set
+# CONFIG_VL53L0X_I2C is not set
+# end of Proximity and distance sensors
+
+#
+# Resolver to digital converters
+#
+# CONFIG_AD2S90 is not set
+# CONFIG_AD2S1200 is not set
+# end of Resolver to digital converters
+
+#
+# Temperature sensors
+#
+# CONFIG_MAXIM_THERMOCOUPLE is not set
+# CONFIG_MLX90614 is not set
+# CONFIG_MLX90632 is not set
+# CONFIG_TMP006 is not set
+# CONFIG_TMP007 is not set
+# CONFIG_TSYS01 is not set
+# CONFIG_TSYS02D is not set
+# CONFIG_MAX31856 is not set
+# end of Temperature sensors
+
+CONFIG_PWM=y
+CONFIG_PWM_SYSFS=y
+# CONFIG_PWM_FSL_FTM is not set
+# CONFIG_PWM_IMX1 is not set
+# CONFIG_PWM_IMX27 is not set
+# CONFIG_PWM_IMX_TPM is not set
+# CONFIG_PWM_PCA9685 is not set
+
+#
+# IRQ chip support
+#
+CONFIG_IRQCHIP=y
+CONFIG_ARM_GIC=y
+CONFIG_ARM_GIC_MAX_NR=1
+# CONFIG_AL_FIC is not set
+CONFIG_IMX_GPCV2=y
+CONFIG_IMX_IRQSTEER=y
+CONFIG_IMX_INTMUX=y
+# end of IRQ chip support
+
+# CONFIG_IPACK_BUS is not set
+CONFIG_ARCH_HAS_RESET_CONTROLLER=y
+CONFIG_RESET_CONTROLLER=y
+CONFIG_RESET_DISPMIX=y
+CONFIG_RESET_IMX7=y
+CONFIG_RESET_IMX_HDMIMIX=y
+CONFIG_RESET_IMX_AUDIOMIX=y
+CONFIG_RESET_GPIO=y
+# CONFIG_RESET_TI_SYSCON is not set
+
+#
+# PHY Subsystem
+#
+# CONFIG_GENERIC_PHY is not set
+# CONFIG_PHY_MIXEL_LVDS is not set
+# CONFIG_PHY_MIXEL_LVDS_COMBO is not set
+# CONFIG_BCM_KONA_USB2_PHY is not set
+# CONFIG_PHY_CADENCE_DP is not set
+# CONFIG_PHY_CADENCE_DPHY is not set
+# CONFIG_PHY_CADENCE_SIERRA is not set
+# CONFIG_PHY_FSL_IMX8MP_LVDS is not set
+# CONFIG_PHY_FSL_IMX8MQ_USB is not set
+# CONFIG_PHY_MIXEL_MIPI_DPHY is not set
+# CONFIG_PHY_SAMSUNG_HDMI_PHY is not set
+# CONFIG_PHY_FSL_IMX_PCIE is not set
+# CONFIG_PHY_PXA_28NM_HSIC is not set
+# CONFIG_PHY_PXA_28NM_USB2 is not set
+# CONFIG_PHY_CPCAP_USB is not set
+# CONFIG_PHY_MAPPHONE_MDM6600 is not set
+# CONFIG_PHY_OCELOT_SERDES is not set
+# CONFIG_PHY_QCOM_USB_HS is not set
+# CONFIG_PHY_QCOM_USB_HSIC is not set
+# CONFIG_PHY_TUSB1210 is not set
+# end of PHY Subsystem
+
+# CONFIG_POWERCAP is not set
+# CONFIG_MCB is not set
+
+#
+# Performance monitor support
+#
+CONFIG_ARM_CCI_PMU=y
+CONFIG_ARM_CCI400_PMU=y
+# CONFIG_ARM_CCI5xx_PMU is not set
+# CONFIG_ARM_CCN is not set
+CONFIG_ARM_PMU=y
+# CONFIG_FSL_IMX8_DDR_PMU is not set
+# end of Performance monitor support
+
+# CONFIG_RAS is not set
+
+#
+# Android
+#
+# CONFIG_ANDROID is not set
+# end of Android
+
+# CONFIG_DAX is not set
+CONFIG_NVMEM=y
+CONFIG_NVMEM_SYSFS=y
+# CONFIG_NVMEM_IMX_IIM is not set
+CONFIG_NVMEM_IMX_OCOTP=y
+# CONFIG_NVMEM_VF610_OCOTP is not set
+# CONFIG_NVMEM_SNVS_LPGPR is not set
+
+#
+# HW tracing support
+#
+# CONFIG_STM is not set
+# CONFIG_INTEL_TH is not set
+# end of HW tracing support
+
+# CONFIG_FPGA is not set
+# CONFIG_FSI is not set
+CONFIG_TEE=y
+
+#
+# TEE drivers
+#
+CONFIG_OPTEE=y
+CONFIG_OPTEE_SHM_NUM_PRIV_PAGES=1
+# end of TEE drivers
+
+CONFIG_PM_OPP=y
+# CONFIG_SIOX is not set
+# CONFIG_SLIMBUS is not set
+# CONFIG_INTERCONNECT is not set
+# CONFIG_COUNTER is not set
+
+#
+# MXC support drivers
+#
+# CONFIG_MXC_SIM is not set
+# CONFIG_MXC_IPU is not set
+
+#
+# MXC Vivante GPU support
+#
+# CONFIG_MXC_GPU_VIV is not set
+# end of MXC Vivante GPU support
+
+#
+# MXC VPU(Video Processing Unit) support
+#
+# CONFIG_MXC_VPU is not set
+# end of MXC VPU(Video Processing Unit) support
+
+#
+# MXC SIM Support
+#
+# end of MXC SIM Support
+
+#
+# MXC Media Local Bus Driver
+#
+CONFIG_MXC_MLB=y
+CONFIG_MXC_MLB150=y
+# end of MXC Media Local Bus Driver
+
+#
+# MXC HDMI CEC (Consumer Electronics Control) support
+#
+# end of MXC HDMI CEC (Consumer Electronics Control) support
+
+#
+# MXC MIPI Support
+#
+# CONFIG_MXC_MIPI_CSI2 is not set
+# end of MXC MIPI Support
+# end of MXC support drivers
+# end of Device Drivers
+
+#
+# File systems
+#
+CONFIG_DCACHE_WORD_ACCESS=y
+# CONFIG_VALIDATE_FS_PARSER is not set
+CONFIG_FS_IOMAP=y
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_EXT2_FS_POSIX_ACL=y
+CONFIG_EXT2_FS_SECURITY=y
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_POSIX_ACL=y
+CONFIG_EXT3_FS_SECURITY=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+# CONFIG_F2FS_FS is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_EXPORTFS=y
+# CONFIG_EXPORTFS_BLOCK_OPS is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_MANDATORY_FILE_LOCKING=y
+# CONFIG_FS_ENCRYPTION is not set
+# CONFIG_FS_VERITY is not set
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_FANOTIFY is not set
+CONFIG_QUOTA=y
+CONFIG_QUOTA_NETLINK_INTERFACE=y
+# CONFIG_PRINT_QUOTA_WARNING is not set
+# CONFIG_QUOTA_DEBUG is not set
+# CONFIG_QFMT_V1 is not set
+# CONFIG_QFMT_V2 is not set
+CONFIG_QUOTACTL=y
+CONFIG_AUTOFS4_FS=y
+CONFIG_AUTOFS_FS=y
+CONFIG_FUSE_FS=y
+# CONFIG_CUSE is not set
+# CONFIG_VIRTIO_FS is not set
+CONFIG_OVERLAY_FS=y
+# CONFIG_OVERLAY_FS_REDIRECT_DIR is not set
+CONFIG_OVERLAY_FS_REDIRECT_ALWAYS_FOLLOW=y
+# CONFIG_OVERLAY_FS_INDEX is not set
+# CONFIG_OVERLAY_FS_XINO_AUTO is not set
+# CONFIG_OVERLAY_FS_METACOPY is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+# end of Caches
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=m
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_UDF_FS=m
+# end of CD-ROM/DVD Filesystems
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=m
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_FAT_DEFAULT_UTF8 is not set
+# CONFIG_NTFS_FS is not set
+# end of DOS/FAT/NT Filesystems
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+# CONFIG_PROC_CHILDREN is not set
+CONFIG_KERNFS=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_TMPFS_XATTR is not set
+CONFIG_MEMFD_CREATE=y
+CONFIG_CONFIGFS_FS=y
+# end of Pseudo filesystems
+
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ORANGEFS_FS is not set
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_ECRYPT_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+CONFIG_UBIFS_FS=y
+# CONFIG_UBIFS_FS_ADVANCED_COMPR is not set
+CONFIG_UBIFS_FS_LZO=y
+CONFIG_UBIFS_FS_ZLIB=y
+CONFIG_UBIFS_FS_ZSTD=y
+# CONFIG_UBIFS_ATIME_SUPPORT is not set
+CONFIG_UBIFS_FS_XATTR=y
+CONFIG_UBIFS_FS_SECURITY=y
+# CONFIG_UBIFS_FS_AUTHENTICATION is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX6FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_PSTORE is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_EROFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V2=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+# CONFIG_NFS_SWAP is not set
+# CONFIG_NFS_V4_1 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFS_USE_LEGACY_DNS is not set
+CONFIG_NFS_USE_KERNEL_DNS=y
+# CONFIG_NFSD is not set
+CONFIG_GRACE_PERIOD=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_ACL_SUPPORT=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+CONFIG_RPCSEC_GSS_KRB5=y
+# CONFIG_SUNRPC_DISABLE_INSECURE_ENCTYPES is not set
+# CONFIG_SUNRPC_DEBUG is not set
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="cp437"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+CONFIG_NLS_ISO8859_15=m
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_MAC_ROMAN is not set
+# CONFIG_NLS_MAC_CELTIC is not set
+# CONFIG_NLS_MAC_CENTEURO is not set
+# CONFIG_NLS_MAC_CROATIAN is not set
+# CONFIG_NLS_MAC_CYRILLIC is not set
+# CONFIG_NLS_MAC_GAELIC is not set
+# CONFIG_NLS_MAC_GREEK is not set
+# CONFIG_NLS_MAC_ICELAND is not set
+# CONFIG_NLS_MAC_INUIT is not set
+# CONFIG_NLS_MAC_ROMANIAN is not set
+# CONFIG_NLS_MAC_TURKISH is not set
+CONFIG_NLS_UTF8=y
+# CONFIG_DLM is not set
+# CONFIG_UNICODE is not set
+# end of File systems
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+# CONFIG_KEYS_REQUEST_CACHE is not set
+# CONFIG_PERSISTENT_KEYRINGS is not set
+# CONFIG_BIG_KEYS is not set
+# CONFIG_ENCRYPTED_KEYS is not set
+# CONFIG_KEY_DH_OPERATIONS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+CONFIG_SECURITYFS=y
+CONFIG_HAVE_HARDENED_USERCOPY_ALLOCATOR=y
+# CONFIG_HARDENED_USERCOPY is not set
+# CONFIG_FORTIFY_SOURCE is not set
+# CONFIG_STATIC_USERMODEHELPER is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_LSM="lockdown,yama,loadpin,safesetid,integrity"
+
+#
+# Kernel hardening options
+#
+
+#
+# Memory initialization
+#
+CONFIG_INIT_STACK_NONE=y
+# CONFIG_INIT_ON_ALLOC_DEFAULT_ON is not set
+# CONFIG_INIT_ON_FREE_DEFAULT_ON is not set
+# end of Memory initialization
+# end of Kernel hardening options
+# end of Security options
+
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_RNG_DEFAULT=y
+CONFIG_CRYPTO_AKCIPHER2=y
+CONFIG_CRYPTO_AKCIPHER=y
+CONFIG_CRYPTO_KPP2=y
+CONFIG_CRYPTO_KPP=y
+CONFIG_CRYPTO_ACOMP2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+CONFIG_CRYPTO_USER=y
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+CONFIG_CRYPTO_GF128MUL=y
+CONFIG_CRYPTO_NULL=y
+CONFIG_CRYPTO_NULL2=y
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_AUTHENC=y
+CONFIG_CRYPTO_TEST=m
+
+#
+# Public-key cryptography
+#
+CONFIG_CRYPTO_RSA=y
+# CONFIG_CRYPTO_DH is not set
+CONFIG_CRYPTO_ECC=y
+CONFIG_CRYPTO_ECDH=y
+# CONFIG_CRYPTO_ECRDSA is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+CONFIG_CRYPTO_CCM=y
+CONFIG_CRYPTO_GCM=y
+# CONFIG_CRYPTO_CHACHA20POLY1305 is not set
+# CONFIG_CRYPTO_AEGIS128 is not set
+CONFIG_CRYPTO_SEQIV=y
+CONFIG_CRYPTO_ECHAINIV=m
+# CONFIG_CRYPTO_TLS is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CFB is not set
+CONFIG_CRYPTO_CTR=y
+CONFIG_CRYPTO_CTS=y
+CONFIG_CRYPTO_ECB=y
+CONFIG_CRYPTO_LRW=y
+# CONFIG_CRYPTO_OFB is not set
+# CONFIG_CRYPTO_PCBC is not set
+CONFIG_CRYPTO_XTS=y
+# CONFIG_CRYPTO_KEYWRAP is not set
+# CONFIG_CRYPTO_ADIANTUM is not set
+# CONFIG_CRYPTO_ESSIV is not set
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_CMAC=y
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_CRC32 is not set
+# CONFIG_CRYPTO_XXHASH is not set
+CONFIG_CRYPTO_CRCT10DIF=y
+CONFIG_CRYPTO_GHASH=y
+# CONFIG_CRYPTO_POLY1305 is not set
+CONFIG_CRYPTO_MD4=y
+CONFIG_CRYPTO_MD5=y
+CONFIG_CRYPTO_MICHAEL_MIC=y
+CONFIG_CRYPTO_RMD128=y
+CONFIG_CRYPTO_RMD160=y
+CONFIG_CRYPTO_RMD256=y
+CONFIG_CRYPTO_RMD320=y
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_LIB_SHA256=y
+CONFIG_CRYPTO_SHA256=y
+CONFIG_CRYPTO_SHA512=y
+# CONFIG_CRYPTO_SHA3 is not set
+# CONFIG_CRYPTO_SM3 is not set
+# CONFIG_CRYPTO_STREEBOG is not set
+CONFIG_CRYPTO_TGR192=y
+CONFIG_CRYPTO_WP512=y
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_LIB_AES=y
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_AES_TI is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_LIB_ARC4=y
+CONFIG_CRYPTO_ARC4=y
+CONFIG_CRYPTO_BLOWFISH=y
+CONFIG_CRYPTO_BLOWFISH_COMMON=y
+CONFIG_CRYPTO_CAMELLIA=y
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_LIB_DES=y
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_CHACHA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_SM4 is not set
+# CONFIG_CRYPTO_TEA is not set
+CONFIG_CRYPTO_TWOFISH=y
+CONFIG_CRYPTO_TWOFISH_COMMON=y
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+CONFIG_CRYPTO_LZO=y
+# CONFIG_CRYPTO_842 is not set
+# CONFIG_CRYPTO_LZ4 is not set
+# CONFIG_CRYPTO_LZ4HC is not set
+CONFIG_CRYPTO_ZSTD=y
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_DRBG_MENU=y
+CONFIG_CRYPTO_DRBG_HMAC=y
+# CONFIG_CRYPTO_DRBG_HASH is not set
+# CONFIG_CRYPTO_DRBG_CTR is not set
+CONFIG_CRYPTO_DRBG=y
+CONFIG_CRYPTO_JITTERENTROPY=y
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+# CONFIG_CRYPTO_USER_API_RNG is not set
+# CONFIG_CRYPTO_USER_API_AEAD is not set
+# CONFIG_CRYPTO_STATS is not set
+CONFIG_CRYPTO_HASH_INFO=y
+CONFIG_CRYPTO_HW=y
+# CONFIG_CRYPTO_DEV_FSL_CAAM_SECVIO is not set
+# CONFIG_CRYPTO_DEV_FSL_CAAM is not set
+# CONFIG_CRYPTO_DEV_SAHARA is not set
+# CONFIG_CRYPTO_DEV_ATMEL_ECC is not set
+# CONFIG_CRYPTO_DEV_ATMEL_SHA204A is not set
+CONFIG_CRYPTO_DEV_MXS_DCP=y
+# CONFIG_CRYPTO_DEV_SAFEXCEL is not set
+# CONFIG_CRYPTO_DEV_CCREE is not set
+CONFIG_ASYMMETRIC_KEY_TYPE=y
+CONFIG_ASYMMETRIC_PUBLIC_KEY_SUBTYPE=y
+CONFIG_X509_CERTIFICATE_PARSER=y
+# CONFIG_PKCS8_PRIVATE_KEY_PARSER is not set
+CONFIG_PKCS7_MESSAGE_PARSER=y
+# CONFIG_PKCS7_TEST_KEY is not set
+# CONFIG_SIGNED_PE_FILE_VERIFICATION is not set
+
+#
+# Certificates for signature checking
+#
+CONFIG_SYSTEM_TRUSTED_KEYRING=y
+CONFIG_SYSTEM_TRUSTED_KEYS=""
+# CONFIG_SYSTEM_EXTRA_CERTIFICATE is not set
+# CONFIG_SECONDARY_TRUSTED_KEYRING is not set
+# CONFIG_SYSTEM_BLACKLIST_KEYRING is not set
+# end of Certificates for signature checking
+
+#
+# Library routines
+#
+# CONFIG_PACKING is not set
+CONFIG_BITREVERSE=y
+CONFIG_HAVE_ARCH_BITREVERSE=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GENERIC_NET_UTILS=y
+# CONFIG_CORDIC is not set
+CONFIG_RATIONAL=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_STMP_DEVICE=y
+CONFIG_ARCH_USE_CMPXCHG_LOCKREF=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
+CONFIG_CRC_T10DIF=y
+CONFIG_CRC_ITU_T=m
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+# CONFIG_CRC64 is not set
+# CONFIG_CRC4 is not set
+CONFIG_CRC7=m
+CONFIG_LIBCRC32C=y
+# CONFIG_CRC8 is not set
+CONFIG_XXHASH=y
+# CONFIG_RANDOM32_SELFTEST is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_ZSTD_COMPRESS=y
+CONFIG_ZSTD_DECOMPRESS=y
+CONFIG_XZ_DEC=y
+CONFIG_XZ_DEC_X86=y
+CONFIG_XZ_DEC_POWERPC=y
+CONFIG_XZ_DEC_IA64=y
+CONFIG_XZ_DEC_ARM=y
+CONFIG_XZ_DEC_ARMTHUMB=y
+CONFIG_XZ_DEC_SPARC=y
+CONFIG_XZ_DEC_BCJ=y
+# CONFIG_XZ_DEC_TEST is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_ASSOCIATIVE_ARRAY=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT_MAP=y
+CONFIG_HAS_DMA=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_DMA_DECLARE_COHERENT=y
+CONFIG_ARCH_HAS_SETUP_DMA_OPS=y
+CONFIG_ARCH_HAS_TEARDOWN_DMA_OPS=y
+CONFIG_DMA_REMAP=y
+CONFIG_DMA_CMA=y
+
+#
+# Default contiguous memory area size:
+#
+CONFIG_CMA_SIZE_MBYTES=160
+CONFIG_CMA_SIZE_SEL_MBYTES=y
+# CONFIG_CMA_SIZE_SEL_PERCENTAGE is not set
+# CONFIG_CMA_SIZE_SEL_MIN is not set
+# CONFIG_CMA_SIZE_SEL_MAX is not set
+CONFIG_CMA_ALIGNMENT=8
+# CONFIG_DMA_API_DEBUG is not set
+CONFIG_SGL_ALLOC=y
+CONFIG_DQL=y
+CONFIG_GLOB=y
+# CONFIG_GLOB_SELFTEST is not set
+CONFIG_NLATTR=y
+CONFIG_CLZ_TAB=y
+# CONFIG_IRQ_POLL is not set
+CONFIG_MPILIB=y
+CONFIG_LIBFDT=y
+CONFIG_OID_REGISTRY=y
+CONFIG_SG_POOL=y
+CONFIG_SBITMAP=y
+# CONFIG_STRING_SELFTEST is not set
+# end of Library routines
+
+#
+# Kernel hacking
+#
+
+#
+# printk and dmesg options
+#
+# CONFIG_PRINTK_TIME is not set
+# CONFIG_PRINTK_CALLER is not set
+CONFIG_CONSOLE_LOGLEVEL_DEFAULT=7
+CONFIG_CONSOLE_LOGLEVEL_QUIET=4
+CONFIG_MESSAGE_LOGLEVEL_DEFAULT=4
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+# end of printk and dmesg options
+
+#
+# Compile-time checks and compiler options
+#
+# CONFIG_DEBUG_INFO is not set
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_READABLE_ASM is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_INSTALL is not set
+CONFIG_OPTIMIZE_INLINING=y
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_SECTION_MISMATCH_WARN_ONLY=y
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# end of Compile-time checks and compiler options
+
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE=0x1
+CONFIG_MAGIC_SYSRQ_SERIAL=y
+CONFIG_DEBUG_KERNEL=y
+CONFIG_DEBUG_MISC=y
+
+#
+# Memory Debugging
+#
+# CONFIG_PAGE_EXTENSION is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+# CONFIG_PAGE_OWNER is not set
+# CONFIG_PAGE_POISONING is not set
+# CONFIG_DEBUG_RODATA_TEST is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_STATS is not set
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_VM is not set
+CONFIG_ARCH_HAS_DEBUG_VIRTUAL=y
+# CONFIG_DEBUG_VIRTUAL is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_HIGHMEM is not set
+CONFIG_CC_HAS_KASAN_GENERIC=y
+CONFIG_KASAN_STACK=1
+# end of Memory Debugging
+
+CONFIG_ARCH_HAS_KCOV=y
+CONFIG_CC_HAS_SANCOV_TRACE_PC=y
+# CONFIG_KCOV is not set
+# CONFIG_DEBUG_SHIRQ is not set
+
+#
+# Debug Lockups and Hangs
+#
+# CONFIG_SOFTLOCKUP_DETECTOR is not set
+# CONFIG_DETECT_HUNG_TASK is not set
+# CONFIG_WQ_WATCHDOG is not set
+# end of Debug Lockups and Hangs
+
+# CONFIG_PANIC_ON_OOPS is not set
+CONFIG_PANIC_ON_OOPS_VALUE=0
+CONFIG_PANIC_TIMEOUT=0
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_SCHED_STACK_END_CHECK is not set
+# CONFIG_DEBUG_TIMEKEEPING is not set
+CONFIG_DEBUG_PREEMPT=y
+
+#
+# Lock Debugging (spinlocks, mutexes, etc...)
+#
+CONFIG_LOCK_DEBUGGING_SUPPORT=y
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_WW_MUTEX_SLOWPATH is not set
+# CONFIG_DEBUG_RWSEMS is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_LOCK_TORTURE_TEST is not set
+# CONFIG_WW_MUTEX_SELFTEST is not set
+# end of Lock Debugging (spinlocks, mutexes, etc...)
+
+# CONFIG_STACKTRACE is not set
+# CONFIG_WARN_ALL_UNSEEDED_RANDOM is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_PLIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+
+#
+# RCU Debugging
+#
+# CONFIG_RCU_PERF_TEST is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=21
+# CONFIG_RCU_TRACE is not set
+# CONFIG_RCU_EQS_DEBUG is not set
+# end of RCU Debugging
+
+# CONFIG_DEBUG_WQ_FORCE_RR_CPU is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_NOTIFIER_ERROR_INJECTION is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_DYNAMIC_FTRACE_WITH_REGS=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+CONFIG_RUNTIME_TESTING_MENU=y
+# CONFIG_LKDTM is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_TEST_SORT is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_RBTREE_TEST is not set
+# CONFIG_REED_SOLOMON_TEST is not set
+# CONFIG_INTERVAL_TREE_TEST is not set
+# CONFIG_PERCPU_TEST is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_TEST_HEXDUMP is not set
+# CONFIG_TEST_STRING_HELPERS is not set
+# CONFIG_TEST_STRSCPY is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_TEST_PRINTF is not set
+# CONFIG_TEST_BITMAP is not set
+# CONFIG_TEST_BITFIELD is not set
+# CONFIG_TEST_UUID is not set
+# CONFIG_TEST_XARRAY is not set
+# CONFIG_TEST_OVERFLOW is not set
+# CONFIG_TEST_RHASHTABLE is not set
+# CONFIG_TEST_HASH is not set
+# CONFIG_TEST_IDA is not set
+# CONFIG_TEST_LKM is not set
+# CONFIG_TEST_VMALLOC is not set
+# CONFIG_TEST_USER_COPY is not set
+# CONFIG_TEST_BPF is not set
+# CONFIG_TEST_BLACKHOLE_DEV is not set
+# CONFIG_FIND_BIT_BENCHMARK is not set
+# CONFIG_TEST_FIRMWARE is not set
+# CONFIG_TEST_SYSCTL is not set
+# CONFIG_TEST_UDELAY is not set
+# CONFIG_TEST_STATIC_KEYS is not set
+# CONFIG_TEST_KMOD is not set
+# CONFIG_TEST_MEMCAT_P is not set
+# CONFIG_TEST_STACKINIT is not set
+# CONFIG_TEST_MEMINIT is not set
+# CONFIG_MEMTEST is not set
+# CONFIG_BUG_ON_DATA_CORRUPTION is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_UBSAN is not set
+CONFIG_UBSAN_ALIGNMENT=y
+CONFIG_ARCH_HAS_DEVMEM_IS_ALLOWED=y
+# CONFIG_STRICT_DEVMEM is not set
+# CONFIG_ARM_PTDUMP_DEBUGFS is not set
+# CONFIG_DEBUG_WX is not set
+# CONFIG_UNWINDER_FRAME_POINTER is not set
+CONFIG_UNWINDER_ARM=y
+CONFIG_ARM_UNWIND=y
+# CONFIG_DEBUG_USER is not set
+# CONFIG_DEBUG_LL is not set
+CONFIG_DEBUG_VF_UART_PORT=1
+CONFIG_DEBUG_LL_INCLUDE="mach/debug-macro.S"
+CONFIG_UNCOMPRESS_INCLUDE="debug/uncompress.h"
+# CONFIG_PID_IN_CONTEXTIDR is not set
+# CONFIG_CORESIGHT is not set
+# end of Kernel hacking
diff -Naur A/arch/arm/mach-imx/Kconfig B/arch/arm/mach-imx/Kconfig
--- A/arch/arm/mach-imx/Kconfig	2022-06-30 09:25:40.000000000 +0530
+++ B/arch/arm/mach-imx/Kconfig	2022-08-09 13:39:36.591536062 +0530
@@ -550,6 +550,26 @@
 	help
 	  This enables support for Freescale i.MX6 UltraLite processor.
 
+config SOC_IMX6ULL_IWG26I
+	bool "Rugged Telematics Device support"
+	select PINCTRL_IMX6UL
+	select MX6ULL_IWG26I
+	select SOC_IMX6
+	select ARM_ERRATA_814220
+	select CHARGER_BQ2560X
+	select ST_LSM6DSM_IIO
+	select ST_MAG40_IIO
+
+	help
+	  This enables support for the iWave Rugged Telematics Device.
+
+config MX6ULL_IWG26I
+	bool "Macro to select the iWave Kernel changes"
+	depends on SOC_IMX6
+
+	help
+	  Selects the iWave specific modifications for Rugged Telematics Device.
+
 config SOC_LS1021A
 	bool "Freescale LS1021A support"
 	select ARM_GIC
diff -Naur A/arch/arm/mach-imx/mach-iwg26i.c B/arch/arm/mach-imx/mach-iwg26i.c
--- A/arch/arm/mach-imx/mach-iwg26i.c	1970-01-01 05:30:00.000000000 +0530
+++ B/arch/arm/mach-imx/mach-iwg26i.c	2022-08-09 13:47:30.510533306 +0530
@@ -0,0 +1,280 @@
+/*
+ * Copyright (c) 2017 iWave Systems Technologies Pvt. Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/can.h>
+#include <linux/fec.h>
+#include <linux/gpio.h>
+#include <linux/irqchip.h>
+#include <linux/mfd/syscon.h>
+#include <linux/mfd/syscon/imx6q-iomuxc-gpr.h>
+#include <linux/netdevice.h>
+#include <linux/of_address.h>
+#include <linux/of_gpio.h>
+#include <linux/of_platform.h>
+#include <linux/phy.h>
+#include <linux/pm_opp.h>
+#include <linux/regmap.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <linux/micrel_phy.h>
+
+#include "common.h"
+#include "cpuidle.h"
+#include "hardware.h"
+
+#define HW_OCOTP_CFGn(n)	(0x00000410 + (n) * 0x10)
+#define BSP_VERSION		"L5.4.70"
+#define CANFD_RESET		IMX_GPIO_NR(1, 22)
+
+static int flexcan0_en_gpio;
+
+/*
+ * @file mach-iwg26i.c
+ * @brief Enet clk enable
+ * @ingroup ENET
+ */
+static void __init imx6ul_enet_clk_init(void)
+{
+	struct regmap *gpr;
+
+	gpr = syscon_regmap_lookup_by_compatible("fsl,imx6ul-iomuxc-gpr");
+	if (!IS_ERR(gpr))
+		regmap_update_bits(gpr, IOMUXC_GPR1, IMX6UL_GPR1_ENET_CLK_DIR,
+				IMX6UL_GPR1_ENET_CLK_OUTPUT);
+	else
+		pr_err("failed to find fsl,imx6ul-iomux-gpr regmap\n");
+
+}
+
+/*
+ * @file mach-iwg26i.c
+ * @brief Enet phy fixup
+ * @ingroup ENET
+ */
+static int ksz8081_phy_fixup(struct phy_device *dev)
+{
+	if (dev && dev->interface == PHY_INTERFACE_MODE_MII) {
+		phy_write(dev, 0x1f, 0x8110);
+		phy_write(dev, 0x16, 0x201);
+	} else if (dev && dev->interface == PHY_INTERFACE_MODE_RMII) {
+		phy_write(dev, 0x1f, 0x0190);
+		phy_write(dev, 0x16, 0x202);
+	}
+
+	return 0;
+}
+
+static void __init imx6ul_enet_phy_init(void)
+{
+	if (IS_BUILTIN(CONFIG_PHYLIB))
+		phy_register_fixup_for_uid(PHY_ID_KSZ8081, MICREL_PHY_ID_MASK,
+				ksz8081_phy_fixup);
+}
+
+#define OCOTP_CFG3			0x440
+#define OCOTP_CFG3_SPEED_SHIFT		16
+#define OCOTP_CFG3_SPEED_696MHZ		0x2
+#define OCOTP_CFG3_SPEED_900MHZ		0x3
+
+static void __init imx6ul_opp_check_speed_grading(struct device *cpu_dev)
+{
+	struct device_node *np;
+	void __iomem *base;
+	u32 val;
+
+	np = of_find_compatible_node(NULL, NULL, "fsl,imx6ull-ocotp");
+	if (!np) {
+		pr_warn("failed to find ocotp node\n");
+		return;
+	}
+
+	base = of_iomap(np, 0);
+	if (!base) {
+		pr_warn("failed to map ocotp\n");
+		goto put_node;
+	}
+
+	/*
+	 * Speed GRADING[1:0] defines the max speed of ARM:
+	 * 2b'00: Reserved;
+	 * 2b'01: 528000000Hz;
+	 * 2b'10: 700000000Hz;
+	 * 2b'11: Reserved;
+	 * We need to set the max speed of ARM according to fuse map.
+	 */
+	val = readl_relaxed(base + OCOTP_CFG3);
+	val >>= OCOTP_CFG3_SPEED_SHIFT;
+	val &= 0x3;
+
+	printk("imx6ul_opp_check_speed_grading val ################################ %d\n", val );
+
+	if (val != OCOTP_CFG3_SPEED_696MHZ) {
+		if (dev_pm_opp_disable(cpu_dev, 792000000))
+			pr_warn("Failed to disable 792MHz OPP\n");
+	}
+
+	if (val != OCOTP_CFG3_SPEED_900MHZ) {
+		if(dev_pm_opp_disable(cpu_dev, 900000000))
+			pr_warn("Failed to disable 900MHz OPP\n");
+	}
+
+	iounmap(base);
+
+put_node:
+	of_node_put(np);
+}
+
+static void __init imx6ul_opp_init(void)
+{
+	struct device_node *np;
+	struct device *cpu_dev = get_cpu_device(0);
+
+	if (!cpu_dev) {
+		pr_warn("failed to get cpu0 device\n");
+		return;
+	}
+	np = of_node_get(cpu_dev->of_node);
+	if (!np) {
+		pr_warn("failed to find cpu0 node\n");
+		return;
+	}
+
+	if (dev_pm_opp_of_add_table(cpu_dev)) {
+		pr_warn("failed to init OPP table\n");
+		goto put_node;
+	}
+
+	imx6ul_opp_check_speed_grading(cpu_dev);
+
+put_node:
+	of_node_put(np);
+}
+
+static inline void imx6ul_enet_init(void)
+{
+	imx6ul_enet_clk_init();
+	imx6ul_enet_phy_init();
+	if (cpu_is_imx6ul())
+		imx6_enet_mac_init("fsl,imx6ul-fec", "fsl,imx6ul-ocotp");
+	else
+		imx6_enet_mac_init("fsl,imx6ul-fec", "fsl,imx6ull-ocotp");
+}
+
+static void imx6ul_flexcan0_switch(int enable)
+{
+	if (enable)
+		/* Active low enables the CAN tranceiver */
+		gpio_set_value_cansleep(flexcan0_en_gpio, 0);
+	else
+		gpio_set_value_cansleep(flexcan0_en_gpio, 1);
+}
+
+/*
+ * @file mach-iwg26i.c
+ * @brief printing board information
+ */
+static int __init print_board_info (void)
+{
+	struct device_node *np;
+	unsigned int unique_id1, unique_id2;
+	void __iomem *base;
+
+	if (cpu_is_imx6ul())
+		np = of_find_compatible_node(NULL, NULL, "fsl,imx6ul-ocotp");
+	else
+		np = of_find_compatible_node(NULL, NULL, "fsl,imx6ull-ocotp");
+	if (!np) {
+		pr_warn("failed to find ocotp node\n");
+		return 0;
+	}
+
+	base = of_iomap(np, 0);
+	if (!base) {
+		pr_warn("failed to map ocotp\n");
+		goto put_node;
+	}
+
+	unique_id1 = readl_relaxed(base + HW_OCOTP_CFGn(0));
+	unique_id2 = readl_relaxed(base + HW_OCOTP_CFGn(1));
+
+	printk ("\n");
+	printk ("Board Info :\n");
+	printk ("\tBSP Version : %s\n", BSP_VERSION);
+	printk ("\tDevice Name and Release : iW-PRGST-R1.0-REL2.1-Rugged_Telematics_Device\n");
+	printk ("\tCPU Unique ID\t: 0x%08x%08x \n", unique_id2, unique_id1);
+	printk ("\n");
+
+	iounmap(base);
+
+put_node:
+	of_node_put(np);
+	return 0;
+}
+
+static void __init imx6ul_init_machine(void)
+{
+	struct device *parent;
+
+	parent = imx_soc_device_init();
+	if (parent == NULL)
+		pr_warn("failed to initialize soc device\n");
+
+	of_platform_default_populate(NULL, NULL, parent);
+	imx_anatop_init();
+	imx6ul_enet_init();
+	imx_anatop_init();
+	imx6ul_pm_init();
+	print_board_info();
+}
+
+static void __init imx6ul_init_irq(void)
+{
+	imx_gpc_check_dt();
+	imx_init_revision_from_anatop();
+	imx_src_init();
+	irqchip_init();
+	imx6_pm_ccm_init("fsl,imx6ul-ccm");
+}
+
+static void __init imx6ul_init_late(void)
+{
+	if (IS_ENABLED(CONFIG_ARM_IMX6Q_CPUFREQ)) {
+		platform_device_register_simple("imx6q-cpufreq", -1, NULL, 0);
+	}
+
+	imx6ul_cpuidle_init();
+}
+
+static void __init imx6ul_map_io(void)
+{
+	debug_ll_io_init();
+	imx6_pm_map_io();
+	imx_busfreq_map_io();
+}
+
+static const char *imx6ul_dt_compat[] __initconst = {
+	"iw,ul_iwg26i",
+	"iw,ull_iwg26i",
+	NULL,
+};
+
+DT_MACHINE_START(IMX6UL, "Freescale i.MX6 UL/ULL (Device Tree)")
+	.map_io		= imx6ul_map_io,
+	.init_irq	= imx6ul_init_irq,
+	.init_machine	= imx6ul_init_machine,
+	.init_late	= imx6ul_init_late,
+	.dt_compat	= imx6ul_dt_compat,
+	MACHINE_END
diff -Naur A/arch/arm/mach-imx/Makefile B/arch/arm/mach-imx/Makefile
--- A/arch/arm/mach-imx/Makefile	2022-06-30 18:05:15.000000000 +0530
+++ B/arch/arm/mach-imx/Makefile	2022-08-09 13:36:04.266484110 +0530
@@ -93,6 +93,7 @@
 obj-$(CONFIG_SOC_IMX6SLL) += mach-imx6sl.o lpddr2_freq_imx6sll.o
 obj-$(CONFIG_SOC_IMX6SX) += mach-imx6sx.o ddr3_freq_imx6sx.o smp_wfe_imx6.o lpddr2_freq_imx6sx.o
 obj-$(CONFIG_SOC_IMX6UL) += mach-imx6ul.o
+obj-$(CONFIG_SOC_IMX6ULL_IWG26I) += mach-iwg26i.o
 obj-$(CONFIG_SOC_IMX7D_CA7) += mach-imx7d.o pm-imx7.o ddr3_freq_imx7d.o smp_wfe.o \
 			   lpddr3_freq_imx.o suspend-imx7.o
 obj-$(CONFIG_SOC_IMX7D_CM4) += mach-imx7d-cm4.o
diff -Naur A/Documentation/arm/iwg26i_rugged_telematics_device.txt B/Documentation/arm/iwg26i_rugged_telematics_device.txt
--- A/Documentation/arm/iwg26i_rugged_telematics_device.txt	1970-01-01 05:30:00.000000000 +0530
+++ B/Documentation/arm/iwg26i_rugged_telematics_device.txt	2022-08-09 13:39:53.859321370 +0530
@@ -0,0 +1,25 @@
+# Below are the Flags and Macros that are used for supporting the Rugged Telematics Device.
+
+[Flags]
+-------
+	iw-tcan-prop
+		- Flag to enable the CAN related changes done by iWave.
+
+	iw-esdhc-prop
+		- Flag to enable the SDHC driver changes done by iWave.
+
+	iw-wdog-prop
+		- This flag will enable the iWave changes for Watchdog driver.
+
+[Macros]
+--------
+	CONFIG_SOC_IMX6ULL_IWG26I
+		- Macro to enable the support for Rugged Telematics Device.
+		- Enables the below Configuration:
+			CONFIG_MX6ULL_IWG26I
+			CONFIG_ST_LSM6DSM_IIO
+			CONFIG_ST_MAG40_IIO
+			CONFIG_CHARGER_BQ2560X
+
+	CONFIG_MX6ULL_IWG26I
+		- Macro to enable the changes done by iWave.
diff -Naur A/drivers/iio/imu/Kconfig B/drivers/iio/imu/Kconfig
--- A/drivers/iio/imu/Kconfig	2022-06-30 18:05:15.000000000 +0530
+++ B/drivers/iio/imu/Kconfig	2022-08-09 13:36:04.266484110 +0530
@@ -53,6 +53,7 @@
 
 source "drivers/iio/imu/inv_mpu6050/Kconfig"
 source "drivers/iio/imu/st_lsm6dsx/Kconfig"
+source "drivers/iio/imu/st_lsm6dsm/Kconfig"
 
 endmenu
 
diff -Naur A/drivers/iio/imu/Makefile B/drivers/iio/imu/Makefile
--- A/drivers/iio/imu/Makefile	2022-06-30 18:05:15.000000000 +0530
+++ B/drivers/iio/imu/Makefile	2022-08-09 13:36:04.266484110 +0530
@@ -18,4 +18,8 @@
 
 obj-$(CONFIG_KMX61) += kmx61.o
 
+ifdef CONFIG_ST_LSM6DSM_IIO
+obj-$(CONFIG_ST_LSM6DSM_IIO) += st_lsm6dsm/
+else
 obj-y += st_lsm6dsx/
+endif
diff -Naur A/drivers/iio/imu/st_lsm6dsm/Kconfig B/drivers/iio/imu/st_lsm6dsm/Kconfig
--- A/drivers/iio/imu/st_lsm6dsm/Kconfig	1970-01-01 05:30:00.000000000 +0530
+++ B/drivers/iio/imu/st_lsm6dsm/Kconfig	2022-08-09 13:36:04.266484110 +0530
@@ -0,0 +1,94 @@
+#
+# st-lsm6dsm drivers for STMicroelectronics combo sensor
+#
+
+menuconfig ST_LSM6DSM_IIO
+	tristate "STMicroelectronics LSM6DSM/LSM6DSL sensor"
+	depends on (I2C || SPI) && SYSFS
+	select IIO_BUFFER
+	select IIO_TRIGGERED_BUFFER
+	select ST_LSM6DSM_I2C_IIO if (I2C)
+	select ST_LSM6DSM_SPI_IIO if (SPI)
+	help
+	  This driver supports LSM6DSM and LSM6DSL sensors.
+	  It is a gyroscope/accelerometer combo device.
+	  This driver can be built as a module. The module will be called
+	  st-lsm6dsm.
+
+if ST_LSM6DSM_IIO
+
+config ST_LSM6DSM_I2C_IIO
+	tristate
+	depends on ST_LSM6DSM_IIO
+	depends on I2C
+
+config ST_LSM6DSM_SPI_IIO
+	tristate
+	depends on ST_LSM6DSM_IIO
+	depends on SPI
+
+config ST_LSM6DSM_IIO_LIMIT_FIFO
+	int "Limit fifo read lenght (#n byte)"
+	depends on ST_LSM6DSM_IIO
+	range 0 4096
+	default 0
+	help
+	  Limit atomic fifo read to #n byte. In some platform i2c/spi read
+	  can be limited by software or hardware.
+
+	  Set 0 to disable the limit.
+
+config ST_LSM6DSM_STEP_COUNTER_ON_DURING_SUSPEND
+	bool "Keep Step counter on during suspend"
+	depends on ST_LSM6DSM_IIO
+	default n
+	help
+	  During suspend step counter is kept on if enabled. Only interrupt
+	  is disabled.
+
+menuconfig ST_LSM6DSM_IIO_MASTER_SUPPORT
+	bool "I2C master controller"
+	depends on I2C && ST_LSM6DSM_IIO
+	default n
+	help
+	  Added support for I2C master controller. Only one slave sensor is
+	  supported.
+
+if ST_LSM6DSM_IIO_MASTER_SUPPORT
+
+config ST_LSM6DSM_ENABLE_INTERNAL_PULLUP
+	bool "Enabled internals pull-up resistors"
+	default y
+
+choice
+	prompt "External sensor 0"
+	default ST_LSM6DSM_IIO_EXT0_LIS3MDL
+	help
+	  Choose the external sensor 0 connected to LSM6DS3.
+
+config ST_LSM6DSM_IIO_EXT0_LIS3MDL
+	bool "LIS3MDL"
+config ST_LSM6DSM_IIO_EXT0_AKM09911
+	bool "AKM09911"
+config ST_LSM6DSM_IIO_EXT0_AKM09912
+	bool "AKM09912"
+config ST_LSM6DSM_IIO_EXT0_AKM09916
+	bool "AKM09916"
+config ST_LSM6DSM_IIO_EXT0_LPS22HB
+	bool "LPS22HB"
+config ST_LSM6DSM_IIO_EXT0_LIS2MDL
+	bool "LIS2MDL"
+endchoice
+
+endif
+
+config ST_LSM6DSM_XL_DATA_INJECTION
+	bool "Enable XL data injection support"
+	depends on ST_LSM6DSM_IIO
+	default n
+	help
+	  This option enables the accelerometer data injection
+	  support. The device functions may so use an injected
+	  pattern instead of taking the real sensor data.
+
+endif #ST_LSM6DSM_IIO
diff -Naur A/drivers/iio/imu/st_lsm6dsm/Makefile B/drivers/iio/imu/st_lsm6dsm/Makefile
--- A/drivers/iio/imu/st_lsm6dsm/Makefile	1970-01-01 05:30:00.000000000 +0530
+++ B/drivers/iio/imu/st_lsm6dsm/Makefile	2022-08-09 13:36:04.266484110 +0530
@@ -0,0 +1,12 @@
+#
+# Makefile for STMicroelectronics LSM6DSM sensor.
+#
+
+obj-$(CONFIG_ST_LSM6DSM_IIO) += st_lsm6dsm.o
+st_lsm6dsm-objs := st_lsm6dsm_core.o
+obj-$(CONFIG_ST_LSM6DSM_I2C_IIO) += st_lsm6dsm_i2c.o
+obj-$(CONFIG_ST_LSM6DSM_SPI_IIO) += st_lsm6dsm_spi.o
+
+st_lsm6dsm-$(CONFIG_IIO_BUFFER) += st_lsm6dsm_buffer.o
+st_lsm6dsm-$(CONFIG_IIO_TRIGGER) += st_lsm6dsm_trigger.o
+st_lsm6dsm-$(CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT) += st_lsm6dsm_i2c_master.o
diff -Naur A/drivers/iio/imu/st_lsm6dsm/st_lsm6dsm_buffer.c B/drivers/iio/imu/st_lsm6dsm/st_lsm6dsm_buffer.c
--- A/drivers/iio/imu/st_lsm6dsm/st_lsm6dsm_buffer.c	1970-01-01 05:30:00.000000000 +0530
+++ B/drivers/iio/imu/st_lsm6dsm/st_lsm6dsm_buffer.c	2022-08-09 13:36:04.270484049 +0530
@@ -0,0 +1,640 @@
+/*
+ * STMicroelectronics lsm6dsm buffer driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Denis Ciocca <denis.ciocca@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/stat.h>
+#include <linux/interrupt.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/buffer.h>
+#include <linux/iio/buffer_impl.h>
+#include <linux/iio/trigger_consumer.h>
+#include <linux/iio/triggered_buffer.h>
+
+#include "st_lsm6dsm.h"
+
+#define ST_LSM6DSM_FIFO_DIFF_L			0x3a
+#define ST_LSM6DSM_FIFO_DIFF_MASK		0x07
+#define ST_LSM6DSM_FIFO_DATA_OUT_L		0x3e
+#define ST_LSM6DSM_FIFO_DATA_OVR		0x40
+#define ST_LSM6DSM_FIFO_DATA_EMPTY		0x10
+#define ST_LSM6DSM_STEP_MASK_64BIT		(0xFFFFFFFFFFFF0000)
+
+#define MIN_ID(a, b, c, d)			(((a) < (b)) ? ((a == 0) ? \
+						(d) : (c)) : ((b == 0) ? \
+						(c) : (d)))
+
+int st_lsm6dsm_push_data_with_timestamp(struct lsm6dsm_data *cdata,
+					u8 index, u8 *data, int64_t timestamp)
+{
+	int i, n = 0;
+	struct iio_chan_spec const *chs = cdata->indio_dev[index]->channels;
+	uint16_t bfch, bfchs_out = 0, bfchs_in = 0;
+	struct lsm6dsm_sensor_data *sdata = iio_priv(cdata->indio_dev[index]);
+	u8 buff[ALIGN(ST_LSM6DSM_FIFO_ELEMENT_LEN_BYTE, sizeof(s64)) + sizeof(s64)];
+
+	if (timestamp <= cdata->fifo_output[index].timestamp_p)
+		return -EINVAL;
+
+	for (i = 0; i < sdata->num_data_channels; i++) {
+		bfch = chs[i].scan_type.storagebits >> 3;
+
+		if (test_bit(i, cdata->indio_dev[index]->active_scan_mask)) {
+			memcpy(&buff[bfchs_out], &data[bfchs_in], bfch);
+			n++;
+			bfchs_out += bfch;
+		}
+
+		bfchs_in += bfch;
+	}
+
+	iio_push_to_buffers_with_timestamp(cdata->indio_dev[index],
+					   buff, timestamp);
+
+	cdata->fifo_output[index].timestamp_p = timestamp;
+
+	return 0;
+}
+
+static void st_lsm6dsm_parse_fifo_data(struct lsm6dsm_data *cdata,
+			u16 read_len, int64_t time_top, u16 num_pattern)
+{
+	int err;
+	u16 fifo_offset = 0;
+	u8 gyro_sip, accel_sip;
+#ifdef CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT
+	u8 ext0_sip;
+#endif /* CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT */
+
+	while (fifo_offset < read_len) {
+		gyro_sip = cdata->fifo_output[ST_MASK_ID_GYRO].sip;
+		accel_sip = cdata->fifo_output[ST_MASK_ID_ACCEL].sip;
+#ifdef CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT
+		ext0_sip = cdata->fifo_output[ST_MASK_ID_EXT0].sip;
+#endif /* CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT */
+
+		do {
+			if (gyro_sip > 0) {
+				if (cdata->fifo_output[ST_MASK_ID_GYRO].timestamp == 0) {
+					if (cdata->slower_id == ST_MASK_ID_GYRO)
+						cdata->fifo_output[ST_MASK_ID_GYRO].timestamp = time_top -
+							(num_pattern * gyro_sip * cdata->fifo_output[ST_MASK_ID_GYRO].deltatime) - 300000;
+					else
+						cdata->fifo_output[ST_MASK_ID_GYRO].timestamp = time_top -
+							(num_pattern * gyro_sip * cdata->fifo_output[ST_MASK_ID_GYRO].deltatime) - 300000 -
+							(cdata->fifo_output[cdata->slower_id].deltatime - cdata->fifo_output[ST_MASK_ID_GYRO].deltatime);
+				} else
+					cdata->fifo_output[ST_MASK_ID_GYRO].timestamp += cdata->fifo_output[ST_MASK_ID_GYRO].deltatime;
+
+				if (cdata->fifo_output[ST_MASK_ID_GYRO].timestamp > time_top) {
+					cdata->fifo_output[ST_MASK_ID_GYRO].timestamp -= cdata->fifo_output[ST_MASK_ID_GYRO].deltatime;
+					cdata->samples_to_discard[ST_MASK_ID_GYRO] = 1;
+				}
+
+				if (cdata->samples_to_discard[ST_MASK_ID_GYRO] > 0)
+					cdata->samples_to_discard[ST_MASK_ID_GYRO]--;
+				else {
+					cdata->fifo_output[ST_MASK_ID_GYRO].num_samples++;
+
+					if (cdata->fifo_output[ST_MASK_ID_GYRO].num_samples >= cdata->fifo_output[ST_MASK_ID_GYRO].decimator) {
+						cdata->fifo_output[ST_MASK_ID_GYRO].num_samples = 0;
+
+						if (cdata->sensors_enabled & BIT(ST_MASK_ID_GYRO)) {
+							if (cdata->samples_to_discard_2[ST_MASK_ID_GYRO] == 0) {
+								err = st_lsm6dsm_push_data_with_timestamp(
+									cdata, ST_MASK_ID_GYRO,
+									&cdata->fifo_data[fifo_offset],
+									cdata->fifo_output[ST_MASK_ID_GYRO].timestamp);
+
+								if (err >= 0)
+									cdata->fifo_output[ST_MASK_ID_GYRO].initialized = true;
+
+								memcpy(cdata->gyro_last_push, &cdata->fifo_data[fifo_offset], 6);
+							} else {
+								cdata->samples_to_discard_2[ST_MASK_ID_GYRO]--;
+
+								if (cdata->fifo_output[ST_MASK_ID_GYRO].initialized) {
+									err = st_lsm6dsm_push_data_with_timestamp(
+										cdata, ST_MASK_ID_GYRO,
+										cdata->gyro_last_push,
+										cdata->fifo_output[ST_MASK_ID_GYRO].timestamp);
+								}
+							}
+						}
+					}
+				}
+
+				fifo_offset += ST_LSM6DSM_FIFO_ELEMENT_LEN_BYTE;
+				gyro_sip--;
+			}
+
+			if (accel_sip > 0) {
+				if (cdata->fifo_output[ST_MASK_ID_ACCEL].timestamp == 0) {
+					if (cdata->slower_id == ST_MASK_ID_ACCEL)
+						cdata->fifo_output[ST_MASK_ID_ACCEL].timestamp = time_top -
+							(num_pattern * accel_sip * cdata->fifo_output[ST_MASK_ID_ACCEL].deltatime) - 300000;
+					else
+						cdata->fifo_output[ST_MASK_ID_ACCEL].timestamp = time_top -
+							(num_pattern * accel_sip * cdata->fifo_output[ST_MASK_ID_ACCEL].deltatime) - 300000 -
+							(cdata->fifo_output[cdata->slower_id].deltatime - cdata->fifo_output[ST_MASK_ID_ACCEL].deltatime);
+				} else
+					cdata->fifo_output[ST_MASK_ID_ACCEL].timestamp += cdata->fifo_output[ST_MASK_ID_ACCEL].deltatime;
+
+				if (cdata->fifo_output[ST_MASK_ID_ACCEL].timestamp > time_top) {
+					cdata->fifo_output[ST_MASK_ID_ACCEL].timestamp -= cdata->fifo_output[ST_MASK_ID_ACCEL].deltatime;
+					cdata->samples_to_discard[ST_MASK_ID_ACCEL] = 1;
+				}
+
+				if (cdata->samples_to_discard[ST_MASK_ID_ACCEL] > 0)
+					cdata->samples_to_discard[ST_MASK_ID_ACCEL]--;
+				else {
+					cdata->fifo_output[ST_MASK_ID_ACCEL].num_samples++;
+
+					if (cdata->fifo_output[ST_MASK_ID_ACCEL].num_samples >= cdata->fifo_output[ST_MASK_ID_ACCEL].decimator) {
+						cdata->fifo_output[ST_MASK_ID_ACCEL].num_samples = 0;
+
+						if (cdata->sensors_enabled & BIT(ST_MASK_ID_ACCEL)) {
+							if (cdata->samples_to_discard_2[ST_MASK_ID_ACCEL] == 0) {
+								err = st_lsm6dsm_push_data_with_timestamp(
+									cdata, ST_MASK_ID_ACCEL,
+									&cdata->fifo_data[fifo_offset],
+									cdata->fifo_output[ST_MASK_ID_ACCEL].timestamp);
+
+								if (err >= 0)
+									cdata->fifo_output[ST_MASK_ID_ACCEL].initialized = true;
+
+								memcpy(cdata->accel_last_push, &cdata->fifo_data[fifo_offset], 6);
+							} else {
+								cdata->samples_to_discard_2[ST_MASK_ID_ACCEL]--;
+
+								if (cdata->fifo_output[ST_MASK_ID_ACCEL].initialized) {
+									err = st_lsm6dsm_push_data_with_timestamp(
+										cdata, ST_MASK_ID_ACCEL,
+										cdata->accel_last_push,
+										cdata->fifo_output[ST_MASK_ID_ACCEL].timestamp);
+								}
+							}
+						}
+					}
+				}
+
+				fifo_offset += ST_LSM6DSM_FIFO_ELEMENT_LEN_BYTE;
+				accel_sip--;
+			}
+
+#ifdef CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT
+			if (ext0_sip > 0) {
+				if (cdata->fifo_output[ST_MASK_ID_EXT0].timestamp == 0) {
+					if (cdata->slower_id == ST_MASK_ID_EXT0)
+						cdata->fifo_output[ST_MASK_ID_EXT0].timestamp = time_top -
+							(num_pattern * ext0_sip * cdata->fifo_output[ST_MASK_ID_EXT0].deltatime) - 300000;
+					else
+						cdata->fifo_output[ST_MASK_ID_EXT0].timestamp = time_top -
+							(num_pattern * ext0_sip * cdata->fifo_output[ST_MASK_ID_EXT0].deltatime) - 300000 -
+							(cdata->fifo_output[cdata->slower_id].deltatime - cdata->fifo_output[ST_MASK_ID_EXT0].deltatime);
+				} else
+					cdata->fifo_output[ST_MASK_ID_EXT0].timestamp += cdata->fifo_output[ST_MASK_ID_EXT0].deltatime;
+
+				if (cdata->fifo_output[ST_MASK_ID_EXT0].timestamp > time_top) {
+					cdata->fifo_output[ST_MASK_ID_EXT0].timestamp -= cdata->fifo_output[ST_MASK_ID_EXT0].deltatime;
+					cdata->samples_to_discard[ST_MASK_ID_EXT0] = 1;
+				}
+
+				if (cdata->samples_to_discard[ST_MASK_ID_EXT0] > 0)
+					cdata->samples_to_discard[ST_MASK_ID_EXT0]--;
+				else {
+					cdata->fifo_output[ST_MASK_ID_EXT0].num_samples++;
+
+					if (cdata->fifo_output[ST_MASK_ID_EXT0].num_samples >= cdata->fifo_output[ST_MASK_ID_EXT0].decimator) {
+						cdata->fifo_output[ST_MASK_ID_EXT0].num_samples = 0;
+
+						if (cdata->sensors_enabled & BIT(ST_MASK_ID_EXT0)) {
+							if (cdata->samples_to_discard_2[ST_MASK_ID_EXT0] == 0) {
+								err = st_lsm6dsm_push_data_with_timestamp(
+									cdata, ST_MASK_ID_EXT0,
+									&cdata->fifo_data[fifo_offset],
+									cdata->fifo_output[ST_MASK_ID_EXT0].timestamp);
+
+								if (err >= 0)
+									cdata->fifo_output[ST_MASK_ID_EXT0].initialized = true;
+
+								memcpy(cdata->ext0_last_push, &cdata->fifo_data[fifo_offset], 6);
+							} else {
+								cdata->samples_to_discard_2[ST_MASK_ID_EXT0]--;
+
+								if (cdata->fifo_output[ST_MASK_ID_EXT0].initialized) {
+									err = st_lsm6dsm_push_data_with_timestamp(
+										cdata, ST_MASK_ID_EXT0,
+										cdata->ext0_last_push,
+										cdata->fifo_output[ST_MASK_ID_EXT0].timestamp);
+								}
+							}
+						}
+					}
+				}
+
+				fifo_offset += ST_LSM6DSM_FIFO_ELEMENT_LEN_BYTE;
+				ext0_sip--;
+			}
+
+		} while ((accel_sip > 0) || (gyro_sip > 0) || (ext0_sip > 0));
+#else /* CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT */
+		} while ((accel_sip > 0) || (gyro_sip > 0));
+#endif /* CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT */
+	}
+}
+
+int st_lsm6dsm_read_fifo(struct lsm6dsm_data *cdata, bool async)
+{
+	int err;
+	u8 fifo_status[2];
+	struct timespec ts;
+#if (CONFIG_ST_LSM6DSM_IIO_LIMIT_FIFO > 0)
+	u16 data_remaining, data_to_read;
+#endif /* CONFIG_ST_LSM6DSM_IIO_LIMIT_FIFO */
+	u16 read_len = 0, byte_in_pattern, num_pattern;
+	int64_t temp_counter = 0, timestamp_diff, slower_deltatime;
+
+	err = cdata->tf->read(cdata, ST_LSM6DSM_FIFO_DIFF_L,
+						2, fifo_status, true);
+	if (err < 0)
+		return err;
+
+//	get_monotonic_boottime(&ts);
+//	timestamp_diff = timespec_to_ns(&ts);
+	timestamp_diff = ktime_get_boottime_ns();
+
+	if (fifo_status[1] & ST_LSM6DSM_FIFO_DATA_OVR) {
+		st_lsm6dsm_set_fifo_mode(cdata, BYPASS);
+		st_lsm6dsm_set_fifo_mode(cdata, CONTINUOS);
+		dev_err(cdata->dev, "data fifo overrun, failed to read it.\n");
+		return -EINVAL;
+	}
+
+	if (fifo_status[1] & ST_LSM6DSM_FIFO_DATA_EMPTY)
+		return 0;
+
+	read_len = ((fifo_status[1] & ST_LSM6DSM_FIFO_DIFF_MASK) << 8) | fifo_status[0];
+	read_len *= ST_LSM6DSM_BYTE_FOR_CHANNEL;
+
+#ifdef CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT
+	byte_in_pattern = (cdata->fifo_output[ST_MASK_ID_ACCEL].sip +
+				cdata->fifo_output[ST_MASK_ID_GYRO].sip +
+				cdata->fifo_output[ST_MASK_ID_EXT0].sip) *
+				ST_LSM6DSM_FIFO_ELEMENT_LEN_BYTE;
+#else /* CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT */
+	byte_in_pattern = (cdata->fifo_output[ST_MASK_ID_ACCEL].sip +
+				cdata->fifo_output[ST_MASK_ID_GYRO].sip) *
+				ST_LSM6DSM_FIFO_ELEMENT_LEN_BYTE;
+#endif /* CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT */
+	if (byte_in_pattern == 0)
+		return 0;
+
+	num_pattern = read_len / byte_in_pattern;
+
+	read_len = (read_len / byte_in_pattern) * byte_in_pattern;
+	if (read_len == 0)
+		return 0;
+
+#if (CONFIG_ST_LSM6DSM_IIO_LIMIT_FIFO == 0)
+	err = cdata->tf->read(cdata, ST_LSM6DSM_FIFO_DATA_OUT_L,
+					read_len, cdata->fifo_data, true);
+	if (err < 0)
+		return err;
+#else /* CONFIG_ST_LSM6DSM_IIO_LIMIT_FIFO */
+	data_remaining = read_len;
+
+	do {
+		if (data_remaining > CONFIG_ST_LSM6DSM_IIO_LIMIT_FIFO)
+			data_to_read = CONFIG_ST_LSM6DSM_IIO_LIMIT_FIFO;
+		else
+			data_to_read = data_remaining;
+
+		err = cdata->tf->read(cdata, ST_LSM6DSM_FIFO_DATA_OUT_L,
+				data_to_read,
+				&cdata->fifo_data[read_len - data_remaining], true);
+		if (err < 0)
+			return err;
+
+		data_remaining -= data_to_read;
+	} while (data_remaining > 0);
+#endif /* CONFIG_ST_LSM6DSM_IIO_LIMIT_FIFO */
+
+	cdata->slower_id = MIN_ID(cdata->fifo_output[ST_MASK_ID_GYRO].sip,
+				cdata->fifo_output[ST_MASK_ID_ACCEL].sip,
+				ST_MASK_ID_GYRO, ST_MASK_ID_ACCEL);
+#ifdef CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT
+	cdata->slower_id = MIN_ID(cdata->fifo_output[cdata->slower_id].sip,
+				cdata->fifo_output[ST_MASK_ID_EXT0].sip,
+				cdata->slower_id, ST_MASK_ID_EXT0);
+#endif /* CONFIG_ST_LSM6DSM_IIO_LIMIT_FIFO */
+
+	temp_counter = cdata->slower_counter;
+	cdata->slower_counter += (read_len / byte_in_pattern) * cdata->fifo_output[cdata->slower_id].sip;
+
+	if (async)
+		goto parse_fifo;
+
+	if (temp_counter > 0) {
+		slower_deltatime = div64_s64(timestamp_diff - cdata->fifo_enable_timestamp, cdata->slower_counter);
+
+		switch (cdata->slower_id) {
+		case ST_MASK_ID_ACCEL:
+			if (cdata->fifo_output[ST_MASK_ID_GYRO].sip != 0)
+				cdata->fifo_output[ST_MASK_ID_GYRO].deltatime = div64_s64(slower_deltatime *
+					cdata->fifo_output[ST_MASK_ID_ACCEL].sip, cdata->fifo_output[ST_MASK_ID_GYRO].sip);
+
+			if (cdata->fifo_output[ST_MASK_ID_EXT0].sip != 0)
+				cdata->fifo_output[ST_MASK_ID_EXT0].deltatime = div64_s64(slower_deltatime *
+					cdata->fifo_output[ST_MASK_ID_ACCEL].sip, cdata->fifo_output[ST_MASK_ID_EXT0].sip);
+
+			cdata->fifo_output[ST_MASK_ID_ACCEL].deltatime = slower_deltatime;
+			break;
+
+		case ST_MASK_ID_GYRO:
+			if (cdata->fifo_output[ST_MASK_ID_ACCEL].sip != 0)
+				cdata->fifo_output[ST_MASK_ID_ACCEL].deltatime = div64_s64(slower_deltatime *
+					cdata->fifo_output[ST_MASK_ID_GYRO].sip, cdata->fifo_output[ST_MASK_ID_ACCEL].sip);
+
+			if (cdata->fifo_output[ST_MASK_ID_EXT0].sip != 0)
+				cdata->fifo_output[ST_MASK_ID_EXT0].deltatime = div64_s64(slower_deltatime *
+					cdata->fifo_output[ST_MASK_ID_GYRO].sip, cdata->fifo_output[ST_MASK_ID_EXT0].sip);
+
+			cdata->fifo_output[ST_MASK_ID_GYRO].deltatime = slower_deltatime;
+			break;
+
+		case ST_MASK_ID_EXT0:
+			if (cdata->fifo_output[ST_MASK_ID_ACCEL].sip != 0)
+				cdata->fifo_output[ST_MASK_ID_ACCEL].deltatime = div64_s64(slower_deltatime *
+					cdata->fifo_output[ST_MASK_ID_EXT0].sip, cdata->fifo_output[ST_MASK_ID_ACCEL].sip);
+
+			if (cdata->fifo_output[ST_MASK_ID_GYRO].sip != 0)
+				cdata->fifo_output[ST_MASK_ID_GYRO].deltatime = div64_s64(slower_deltatime *
+					cdata->fifo_output[ST_MASK_ID_EXT0].sip, cdata->fifo_output[ST_MASK_ID_GYRO].sip);
+
+			cdata->fifo_output[ST_MASK_ID_EXT0].deltatime = slower_deltatime;
+			break;
+
+		default:
+			break;
+		}
+	} else {
+		cdata->fifo_output[ST_MASK_ID_ACCEL].deltatime = cdata->fifo_output[ST_MASK_ID_ACCEL].deltatime_default;
+		cdata->fifo_output[ST_MASK_ID_GYRO].deltatime = cdata->fifo_output[ST_MASK_ID_GYRO].deltatime_default;
+#ifdef CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT
+		cdata->fifo_output[ST_MASK_ID_EXT0].deltatime = cdata->fifo_output[ST_MASK_ID_EXT0].deltatime_default;
+#endif /* CONFIG_ST_LSM6DSM_IIO_LIMIT_FIFO */
+	}
+
+parse_fifo:
+	st_lsm6dsm_parse_fifo_data(cdata, read_len, timestamp_diff, num_pattern);
+
+	return 0;
+}
+
+int lsm6dsm_read_output_data(struct lsm6dsm_data *cdata, int sindex, bool push)
+{
+	int err;
+	u8 data[6];
+	struct iio_dev *indio_dev = cdata->indio_dev[sindex];
+	struct lsm6dsm_sensor_data *sdata = iio_priv(indio_dev);
+
+	err = cdata->tf->read(cdata, sdata->data_out_reg,
+				ST_LSM6DSM_BYTE_FOR_CHANNEL * 3, data, true);
+	if (err < 0)
+		return err;
+
+	if (push)
+		st_lsm6dsm_push_data_with_timestamp(cdata, sindex,
+							data, cdata->timestamp);
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm6dsm_read_output_data);
+
+static irqreturn_t st_lsm6dsm_outdata_trigger_handler(int irq, void *p)
+{
+	struct iio_poll_func *pf = p;
+	struct iio_dev *indio_dev = pf->indio_dev;
+
+	iio_trigger_notify_done(indio_dev->trig);
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t st_lsm6dsm_step_counter_trigger_handler(int irq, void *p)
+{
+	int err;
+	u8 steps_data[2];
+	int64_t timestamp = 0;
+	struct iio_poll_func *pf = p;
+	struct iio_dev *indio_dev = pf->indio_dev;
+	struct lsm6dsm_sensor_data *sdata = iio_priv(indio_dev);
+	u8 buff[ALIGN(ST_LSM6DSM_FIFO_ELEMENT_LEN_BYTE, sizeof(s64)) + sizeof(s64)];
+
+	if (!sdata->cdata->reset_steps) {
+		err = sdata->cdata->tf->read(sdata->cdata,
+					(u8)indio_dev->channels[0].address,
+					ST_LSM6DSM_BYTE_FOR_CHANNEL,
+					steps_data, true);
+		if (err < 0)
+			goto st_lsm6dsm_step_counter_done;
+
+		sdata->cdata->num_steps = (sdata->cdata->num_steps &
+			ST_LSM6DSM_STEP_MASK_64BIT) + *((u16 *)steps_data);
+		timestamp = sdata->cdata->timestamp;
+	} else {
+		sdata->cdata->num_steps = 0;
+		timestamp = ktime_get_boottime_ns();
+		sdata->cdata->reset_steps = false;
+	}
+
+	memcpy(buff, (u8 *)&sdata->cdata->num_steps, sizeof(u64));
+	iio_push_to_buffers_with_timestamp(indio_dev, buff, timestamp);
+
+st_lsm6dsm_step_counter_done:
+	iio_trigger_notify_done(indio_dev->trig);
+	return IRQ_HANDLED;
+}
+
+static inline irqreturn_t st_lsm6dsm_handler_empty(int irq, void *p)
+{
+	return IRQ_HANDLED;
+}
+
+int st_lsm6dsm_trig_set_state(struct iio_trigger *trig, bool state)
+{
+	return 0;
+}
+
+static int st_lsm6dsm_buffer_preenable(struct iio_dev *indio_dev)
+{
+#ifdef CONFIG_ST_LSM6DSM_XL_DATA_INJECTION
+	struct lsm6dsm_sensor_data *sdata = iio_priv(indio_dev);
+
+	if (sdata->cdata->injection_mode) {
+		switch (sdata->sindex) {
+		case ST_MASK_ID_ACCEL:
+		case ST_MASK_ID_GYRO:
+			return -EBUSY;
+
+		default:
+			break;
+		}
+	}
+#endif /* CONFIG_ST_LSM6DSM_XL_DATA_INJECTION */
+
+	return 0;
+}
+
+static int st_lsm6dsm_buffer_postenable(struct iio_dev *indio_dev)
+{
+	int err;
+	struct lsm6dsm_sensor_data *sdata = iio_priv(indio_dev);
+
+	sdata->cdata->fifo_output[sdata->sindex].initialized = false;
+
+	if ((sdata->cdata->hwfifo_enabled[sdata->sindex]) &&
+		(indio_dev->buffer->length < 2 * ST_LSM6DSM_MAX_FIFO_LENGHT))
+		return -EINVAL;
+
+	err = iio_triggered_buffer_postenable(indio_dev);
+	if (err < 0)
+		return err;
+
+	mutex_lock(&sdata->cdata->odr_lock);
+
+	err = st_lsm6dsm_set_enable(sdata, true, true);
+	if (err < 0) {
+		mutex_unlock(&sdata->cdata->odr_lock);
+		return err;
+	}
+
+	mutex_unlock(&sdata->cdata->odr_lock);
+
+	if (sdata->sindex == ST_MASK_ID_STEP_COUNTER)
+		iio_trigger_poll_chained(sdata->cdata->trig[ST_MASK_ID_STEP_COUNTER]);
+
+	return 0;
+}
+
+static int st_lsm6dsm_buffer_predisable(struct iio_dev *indio_dev)
+{
+	return iio_triggered_buffer_predisable(indio_dev);
+}
+
+static int st_lsm6dsm_buffer_postdisable(struct iio_dev *indio_dev)
+{
+	int err;
+	struct lsm6dsm_sensor_data *sdata = iio_priv(indio_dev);
+
+	mutex_lock(&sdata->cdata->odr_lock);
+
+	err = st_lsm6dsm_set_enable(sdata, false, true);
+
+	mutex_unlock(&sdata->cdata->odr_lock);
+
+	return err < 0 ? err : 0;
+}
+
+static const struct iio_buffer_setup_ops st_lsm6dsm_buffer_setup_ops = {
+	.preenable = &st_lsm6dsm_buffer_preenable,
+	.postenable = &st_lsm6dsm_buffer_postenable,
+	.predisable = &st_lsm6dsm_buffer_predisable,
+	.postdisable = &st_lsm6dsm_buffer_postdisable,
+};
+
+int st_lsm6dsm_allocate_rings(struct lsm6dsm_data *cdata)
+{
+	int err;
+	struct lsm6dsm_sensor_data *sdata;
+
+	sdata = iio_priv(cdata->indio_dev[ST_MASK_ID_ACCEL]);
+
+	err = iio_triggered_buffer_setup(cdata->indio_dev[ST_MASK_ID_ACCEL],
+				NULL, &st_lsm6dsm_outdata_trigger_handler,
+				&st_lsm6dsm_buffer_setup_ops);
+	if (err < 0)
+		return err;
+
+	sdata = iio_priv(cdata->indio_dev[ST_MASK_ID_GYRO]);
+
+	err = iio_triggered_buffer_setup(cdata->indio_dev[ST_MASK_ID_GYRO],
+				NULL, &st_lsm6dsm_outdata_trigger_handler,
+				&st_lsm6dsm_buffer_setup_ops);
+	if (err < 0)
+		goto buffer_cleanup_accel;
+
+	err = iio_triggered_buffer_setup(
+				cdata->indio_dev[ST_MASK_ID_SIGN_MOTION],
+				&st_lsm6dsm_handler_empty, NULL,
+				&st_lsm6dsm_buffer_setup_ops);
+	if (err < 0)
+		goto buffer_cleanup_gyro;
+
+	err = iio_triggered_buffer_setup(
+				cdata->indio_dev[ST_MASK_ID_STEP_COUNTER],
+				NULL,
+				&st_lsm6dsm_step_counter_trigger_handler,
+				&st_lsm6dsm_buffer_setup_ops);
+	if (err < 0)
+		goto buffer_cleanup_sign_motion;
+
+	err = iio_triggered_buffer_setup(
+				cdata->indio_dev[ST_MASK_ID_STEP_DETECTOR],
+				&st_lsm6dsm_handler_empty, NULL,
+				&st_lsm6dsm_buffer_setup_ops);
+	if (err < 0)
+		goto buffer_cleanup_step_counter;
+
+	err = iio_triggered_buffer_setup(
+				cdata->indio_dev[ST_MASK_ID_TILT],
+				&st_lsm6dsm_handler_empty, NULL,
+				&st_lsm6dsm_buffer_setup_ops);
+	if (err < 0)
+		goto buffer_cleanup_step_detector;
+
+	return 0;
+
+buffer_cleanup_step_detector:
+	iio_triggered_buffer_cleanup(
+				cdata->indio_dev[ST_MASK_ID_STEP_DETECTOR]);
+buffer_cleanup_step_counter:
+	iio_triggered_buffer_cleanup(
+				cdata->indio_dev[ST_MASK_ID_STEP_COUNTER]);
+buffer_cleanup_sign_motion:
+	iio_triggered_buffer_cleanup(
+				cdata->indio_dev[ST_MASK_ID_SIGN_MOTION]);
+buffer_cleanup_gyro:
+	iio_triggered_buffer_cleanup(cdata->indio_dev[ST_MASK_ID_GYRO]);
+buffer_cleanup_accel:
+	iio_triggered_buffer_cleanup(cdata->indio_dev[ST_MASK_ID_ACCEL]);
+
+	return err;
+}
+
+void st_lsm6dsm_deallocate_rings(struct lsm6dsm_data *cdata)
+{
+	iio_triggered_buffer_cleanup(cdata->indio_dev[ST_MASK_ID_TILT]);
+	iio_triggered_buffer_cleanup(
+				cdata->indio_dev[ST_MASK_ID_STEP_DETECTOR]);
+	iio_triggered_buffer_cleanup(
+				cdata->indio_dev[ST_MASK_ID_STEP_COUNTER]);
+	iio_triggered_buffer_cleanup(
+				cdata->indio_dev[ST_MASK_ID_SIGN_MOTION]);
+	iio_triggered_buffer_cleanup(cdata->indio_dev[ST_MASK_ID_ACCEL]);
+	iio_triggered_buffer_cleanup(cdata->indio_dev[ST_MASK_ID_GYRO]);
+}
+
+MODULE_AUTHOR("Denis Ciocca <denis.ciocca@st.com>");
+MODULE_DESCRIPTION("STMicroelectronics lsm6dsm buffer driver");
+MODULE_LICENSE("GPL v2");
diff -Naur A/drivers/iio/imu/st_lsm6dsm/st_lsm6dsm_core.c B/drivers/iio/imu/st_lsm6dsm/st_lsm6dsm_core.c
--- A/drivers/iio/imu/st_lsm6dsm/st_lsm6dsm_core.c	1970-01-01 05:30:00.000000000 +0530
+++ B/drivers/iio/imu/st_lsm6dsm/st_lsm6dsm_core.c	2022-08-09 13:54:54.921999279 +0530
@@ -0,0 +1,3276 @@
+/*
+ * STMicroelectronics lsm6dsm core driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Denis Ciocca <denis.ciocca@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/mutex.h>
+#include <linux/interrupt.h>
+#include <linux/gpio.h>
+#include <linux/delay.h>
+#include <linux/of.h>
+#include <linux/irq.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/sysfs.h>
+#include <linux/iio/trigger.h>
+#include <linux/iio/buffer.h>
+#include <linux/iio/events.h>
+#include <asm/unaligned.h>
+
+#include <linux/iio/common/st_sensors.h>
+#include "st_lsm6dsm.h"
+
+#define MS_TO_NS(msec)				((msec) * 1000 * 1000)
+
+#ifndef MAX
+#define MAX(a, b)				(((a) > (b)) ? (a) : (b))
+#endif
+
+#ifndef MIN
+#define MIN(a, b)				(((a) < (b)) ? (a) : (b))
+#endif
+
+#define MIN_BNZ(a, b)				(((a) < (b)) ? ((a == 0) ? \
+						(b) : (a)) : ((b == 0) ? \
+						(a) : (b)))
+
+/* COMMON VALUES FOR ACCEL-GYRO SENSORS 
+#define ST_LSM6DSM_DRDY_PULSE_CFG_G			0x0b
+*/
+#define ST_LSM6DSM_WAI_ADDRESS				0x0f
+#define ST_LSM6DSM_WAI_EXP				0x6a
+#define ST_LSM6DSM_INT1_ADDR				0x0d
+#define ST_LSM6DSM_INT2_ADDR				0x0e
+#define ST_LSM6DSM_ACCEL_DRDY_IRQ_MASK			0x01
+#define ST_LSM6DSM_GYRO_DRDY_IRQ_MASK			0x02
+#define ST_LSM6DSM_MD1_ADDR				0x5e
+#define ST_LSM6DSM_ODR_LIST_NUM				7
+#define ST_LSM6DSM_ODR_POWER_OFF_VAL			0x00
+#define ST_LSM6DSM_ODR_13HZ_VAL				0x01
+#define ST_LSM6DSM_ODR_26HZ_VAL				0x02
+#define ST_LSM6DSM_ODR_52HZ_VAL				0x03
+#define ST_LSM6DSM_ODR_104HZ_VAL			0x04
+#define ST_LSM6DSM_ODR_208HZ_VAL			0x05
+#define ST_LSM6DSM_ODR_416HZ_VAL			0x06
+#define ST_LSM6DSM_ODR_833HZ_VAL			0x07
+#define ST_LSM6DSM_FS_LIST_NUM				4
+#define ST_LSM6DSM_BDU_ADDR				0x12
+#define ST_LSM6DSM_BDU_MASK				0x40
+#define ST_LSM6DSM_EN_BIT				0x01
+#define ST_LSM6DSM_DIS_BIT				0x00
+#define ST_LSM6DSM_FUNC_EN_ADDR				0x19
+#define ST_LSM6DSM_FUNC_EN_MASK				0x04
+#define ST_LSM6DSM_FUNC_CFG_ACCESS_ADDR			0x01
+#define ST_LSM6DSM_FUNC_CFG_ACCESS_MASK			0x01
+#define ST_LSM6DSM_FUNC_CFG_ACCESS_MASK2		0x04
+#define ST_LSM6DSM_FUNC_CFG_REG2_MASK			0x80
+#define ST_LSM6DSM_FUNC_CFG_START1_ADDR			0x62
+#define ST_LSM6DSM_FUNC_CFG_START2_ADDR			0x63
+#define ST_LSM6DSM_SENSORHUB_ADDR			0x1a
+#define ST_LSM6DSM_SENSORHUB_MASK			0x01
+#define ST_LSM6DSM_SENSORHUB_TRIG_MASK			0x10
+#define ST_LSM6DSM_TRIG_INTERNAL			0x00
+#define ST_LSM6DSM_TRIG_EXTERNAL			0x01
+#define ST_LSM6DSM_SELFTEST_ADDR			0x14
+#define ST_LSM6DSM_SELFTEST_ACCEL_MASK			0x03
+#define ST_LSM6DSM_SELFTEST_GYRO_MASK			0x0c
+#define ST_LSM6DSM_SELF_TEST_DISABLED_VAL		0x00
+#define ST_LSM6DSM_SELF_TEST_POS_SIGN_VAL		0x01
+#define ST_LSM6DSM_SELF_TEST_NEG_ACCEL_SIGN_VAL		0x02
+#define ST_LSM6DSM_SELF_TEST_NEG_GYRO_SIGN_VAL		0x03
+#define ST_LSM6DSM_LIR_ADDR				0x58
+#define ST_LSM6DSM_LIR_MASK				0x01
+/*Commented by Akshay
+#define ST_LSM6DSM_INT_ENABLE_MASK			0x80
+*/
+#define ST_LSM6DSM_TIMER_EN_ADDR			0x19
+#define ST_LSM6DSM_TIMER_EN_MASK			0x20
+#define ST_LSM6DSM_PEDOMETER_EN_ADDR			0x19
+#define ST_LSM6DSM_PEDOMETER_EN_MASK			0x10
+#define ST_LSM6DSM_INT2_ON_INT1_ADDR			0x13
+#define ST_LSM6DSM_INT2_ON_INT1_MASK			0x20
+#define ST_LSM6DSM_MIN_DURATION_MS			1638
+#define ST_LSM6DSM_ROUNDING_ADDR			0x16
+#define ST_LSM6DSM_ROUNDING_MASK			0x04
+#define ST_LSM6DSM_FIFO_MODE_ADDR			0x0a
+#define ST_LSM6DSM_FIFO_MODE_MASK			0x07
+#define ST_LSM6DSM_FIFO_MODE_BYPASS			0x00
+#define ST_LSM6DSM_FIFO_MODE_CONTINUOS			0x06
+#define ST_LSM6DSM_FIFO_THRESHOLD_IRQ_MASK		0x08
+#define ST_LSM6DSM_FIFO_ODR_MAX				0x40
+#define ST_LSM6DSM_FIFO_DECIMATOR_ADDR			0x08
+#define ST_LSM6DSM_FIFO_ACCEL_DECIMATOR_MASK		0x07
+#define ST_LSM6DSM_FIFO_GYRO_DECIMATOR_MASK		0x38
+#define ST_LSM6DSM_FIFO_DECIMATOR2_ADDR			0x09
+#define ST_LSM6DSM_FIFO_THR_L_ADDR			0x06
+#define ST_LSM6DSM_FIFO_THR_H_ADDR			0x07
+#define ST_LSM6DSM_FIFO_THR_MASK			0x07ff
+#define ST_LSM6DSM_FIFO_THR_IRQ_MASK			0x08
+#define ST_LSM6DSM_RESET_ADDR				0x12
+#define ST_LSM6DSM_RESET_MASK				0x01
+#define ST_LSM6DSM_TEST_REG_ADDR			0x00
+#define ST_LSM6DSM_START_INJECT_XL_MASK			0x08
+#define ST_LSM6DSM_INJECT_XL_X_ADDR			0x06
+#define ST_LSM6DSM_SELFTEST_NA_MS			"na"
+#define ST_LSM6DSM_SELFTEST_FAIL_MS			"fail"
+#define ST_LSM6DSM_SELFTEST_PASS_MS			"pass"
+
+/* CUSTOM VALUES FOR ACCEL SENSOR */
+#define ST_LSM6DSM_ACCEL_ODR_ADDR			0x10
+#define ST_LSM6DSM_ACCEL_ODR_MASK			0xf0
+#define ST_LSM6DSM_ACCEL_FS_ADDR			0x10
+#define ST_LSM6DSM_ACCEL_FS_MASK			0x0c
+#define ST_LSM6DSM_ACCEL_FS_2G_VAL			0x00
+#define ST_LSM6DSM_ACCEL_FS_4G_VAL			0x02
+#define ST_LSM6DSM_ACCEL_FS_8G_VAL			0x03
+#define ST_LSM6DSM_ACCEL_FS_16G_VAL			0x01
+#define ST_LSM6DSM_ACCEL_FS_2G_GAIN			IIO_G_TO_M_S_2(61)
+#define ST_LSM6DSM_ACCEL_FS_4G_GAIN			IIO_G_TO_M_S_2(122)
+#define ST_LSM6DSM_ACCEL_FS_8G_GAIN			IIO_G_TO_M_S_2(244)
+#define ST_LSM6DSM_ACCEL_FS_16G_GAIN			IIO_G_TO_M_S_2(488)
+#define ST_LSM6DSM_ACCEL_OUT_X_L_ADDR			0x28
+#define ST_LSM6DSM_ACCEL_OUT_Y_L_ADDR			0x2a
+#define ST_LSM6DSM_ACCEL_OUT_Z_L_ADDR			0x2c
+#define ST_LSM6DSM_ACCEL_STD_52HZ			1
+#define ST_LSM6DSM_ACCEL_STD_104HZ			2
+#define ST_LSM6DSM_ACCEL_STD_208HZ			3
+#define ST_LSM6DSM_SELFTEST_ACCEL_ADDR			0x10
+#define ST_LSM6DSM_SELFTEST_ACCEL_REG_VALUE		0x60
+#define ST_LSM6DSM_SELFTEST_ACCEL_MIN			1492
+#define ST_LSM6DSM_SELFTEST_ACCEL_MAX			27868
+
+/* CUSTOM VALUES FOR GYRO SENSOR */
+#define ST_LSM6DSM_GYRO_ODR_ADDR			0x11
+#define ST_LSM6DSM_GYRO_ODR_MASK			0xf0
+#define ST_LSM6DSM_GYRO_FS_ADDR				0x11
+#define ST_LSM6DSM_GYRO_FS_MASK				0x0c
+#define ST_LSM6DSM_GYRO_FS_250_VAL			0x00
+#define ST_LSM6DSM_GYRO_FS_500_VAL			0x01
+#define ST_LSM6DSM_GYRO_FS_1000_VAL			0x02
+#define ST_LSM6DSM_GYRO_FS_2000_VAL			0x03
+#define ST_LSM6DSM_GYRO_FS_250_GAIN			IIO_DEGREE_TO_RAD(8750)
+#define ST_LSM6DSM_GYRO_FS_500_GAIN			IIO_DEGREE_TO_RAD(17500)
+#define ST_LSM6DSM_GYRO_FS_1000_GAIN			IIO_DEGREE_TO_RAD(35000)
+#define ST_LSM6DSM_GYRO_FS_2000_GAIN			IIO_DEGREE_TO_RAD(70000)
+#define ST_LSM6DSM_GYRO_OUT_X_L_ADDR			0x22
+#define ST_LSM6DSM_GYRO_OUT_Y_L_ADDR			0x24
+#define ST_LSM6DSM_GYRO_OUT_Z_L_ADDR			0x26
+#define ST_LSM6DSM_GYRO_STD_13HZ			2
+#define ST_LSM6DSM_GYRO_STD_52HZ			3
+#define ST_LSM6DSM_GYRO_STD_104HZ			5
+#define ST_LSM6DSM_GYRO_STD_208HZ			8
+#define ST_LSM6DSM_SELFTEST_GYRO_ADDR			0x11
+#define ST_LSM6DSM_SELFTEST_GYRO_REG_VALUE		0x4c
+#define ST_LSM6DSM_SELFTEST_GYRO_MIN			2142
+#define ST_LSM6DSM_SELFTEST_GYRO_MAX			10000
+
+/* CUSTOM VALUES FOR SIGNIFICANT MOTION SENSOR */
+#define ST_LSM6DSM_SIGN_MOTION_EN_ADDR			0x19
+#define ST_LSM6DSM_SIGN_MOTION_EN_MASK			0x01
+#define ST_LSM6DSM_SIGN_MOTION_DRDY_IRQ_MASK		0x40
+
+/* CUSTOM VALUES FOR STEP DETECTOR SENSOR */
+#define ST_LSM6DSM_STEP_DETECTOR_DRDY_IRQ_MASK		0x80
+
+/* CUSTOM VALUES FOR STEP COUNTER SENSOR */
+#define ST_LSM6DSM_STEP_COUNTER_DRDY_IRQ_MASK		0x80
+#define ST_LSM6DSM_STEP_COUNTER_OUT_L_ADDR		0x4b
+#define ST_LSM6DSM_STEP_COUNTER_RES_ADDR		0x19
+#define ST_LSM6DSM_STEP_COUNTER_RES_MASK		0x06
+#define ST_LSM6DSM_STEP_COUNTER_RES_ALL_EN		0x03
+#define ST_LSM6DSM_STEP_COUNTER_RES_FUNC_EN		0x02
+#define ST_LSM6DSM_STEP_COUNTER_DURATION_ADDR		0x15
+#define ST_LSM6DSM_STEP_COUNTER_THS_ADDR		0x0f
+#define ST_LSM6DSM_STEP_COUNTER_THS_2G_VALUE		(0x00 | 0x10)
+#define ST_LSM6DSM_STEP_COUNTER_THS_4G_VALUE		(0x80 | 0x08)
+
+/* CUSTOM VALUES FOR TILT SENSOR */
+#define ST_LSM6DSM_TILT_EN_ADDR				0x19
+#define ST_LSM6DSM_TILT_EN_MASK				0x08
+#define ST_LSM6DSM_TILT_DRDY_IRQ_MASK			0x02
+
+/* CUSTOM VALUES FOR TAP AND TAP_TAP SENSOR 
+#define ST_LSM6DSM_TAP_EN_ADDR				0x58
+#define ST_LSM6DSM_TAP_EN_MASK				GENMASK(3, 1)
+#define ST_LSM6DSM_STAP_DRDY_IRQ_MASK			0x40
+#define ST_LSM6DSM_DTAP_DRDY_IRQ_MASK			0x08
+#define ST_LSM6DSM_TAP_THS_ADDR				0x59
+#define ST_LSM6DSM_TAP_THS_MASK				GENMASK(4, 0)
+#define ST_LSM6DSM_TAP_DUR_ADDR				0x5a
+#define ST_LSM6DSM_TAP_DUR_MASK				0xff
+#define ST_LSM6DSM_DTAP_EN_ADDR				0x5b
+#define ST_LSM6DSM_DTAP_EN_MASK				0x80
+
+CUSTOM VALUES FOR WRIST TILT SENSOR
+#define ST_LSM6DSM_WTILT_EN_ADDR			0x19
+#define ST_LSM6DSM_WTILT_EN_MASK			0x80
+#define ST_LSM6DSM_WTILT_DRDY_IRQ_MASK			0x01
+#define ST_LSM6DSM_WRIST_TILT_IA			0x55
+*/
+#define ST_LSM6DSM_ACCEL_SUFFIX_NAME			"accel"
+#define ST_LSM6DSM_GYRO_SUFFIX_NAME			"gyro"
+#define ST_LSM6DSM_STEP_COUNTER_SUFFIX_NAME		"step_c"
+#define ST_LSM6DSM_STEP_DETECTOR_SUFFIX_NAME		"step_d"
+#define ST_LSM6DSM_SIGN_MOTION_SUFFIX_NAME		"sign_motion"
+#define ST_LSM6DSM_TILT_SUFFIX_NAME			"tilt"
+/*
+#define ST_LSM6DSM_WTILT_SUFFIX_NAME			"wrist"
+#define ST_LSM6DSM_STAP_SUFFIX_NAME			"stap"
+#define ST_LSM6DSM_DTAP_SUFFIX_NAME			"dtap"
+*/
+#define ST_LSM6DSM_26HZ_INJECT_NS_UP			(ULLONG_MAX)
+#define ST_LSM6DSM_26HZ_INJECT_NS_DOWN			(25641026LL)
+#define ST_LSM6DSM_52HZ_INJECT_NS_UP			ST_LSM6DSM_26HZ_INJECT_NS_DOWN
+#define ST_LSM6DSM_52HZ_INJECT_NS_DOWN			(12820512LL)
+#define ST_LSM6DSM_104HZ_INJECT_NS_UP			ST_LSM6DSM_52HZ_INJECT_NS_DOWN
+#define ST_LSM6DSM_104HZ_INJECT_NS_DOWN			(6410256LL)
+#define ST_LSM6DSM_208HZ_INJECT_NS_UP			ST_LSM6DSM_104HZ_INJECT_NS_DOWN
+#define ST_LSM6DSM_208HZ_INJECT_NS_DOWN			(0)
+
+#define ST_LSM6DSM_DEV_ATTR_SAMP_FREQ() \
+		IIO_DEV_ATTR_SAMP_FREQ(S_IWUSR | S_IRUGO, \
+			st_lsm6dsm_sysfs_get_sampling_frequency, \
+			st_lsm6dsm_sysfs_set_sampling_frequency)
+
+#define ST_LSM6DSM_DEV_ATTR_SAMP_FREQ_AVAIL() \
+		IIO_DEV_ATTR_SAMP_FREQ_AVAIL( \
+			st_lsm6dsm_sysfs_sampling_frequency_avail)
+
+#define ST_LSM6DSM_DEV_ATTR_SCALE_AVAIL(name) \
+		IIO_DEVICE_ATTR(name, S_IRUGO, \
+			st_lsm6dsm_sysfs_scale_avail, NULL , 0);
+
+static struct st_lsm6dsm_selftest_table {
+	char *string_mode;
+	u8 accel_value;
+	u8 gyro_value;
+	u8 gyro_mask;
+} st_lsm6dsm_selftest_table[] = {
+	[0] = {
+		.string_mode = "disabled",
+		.accel_value = ST_LSM6DSM_SELF_TEST_DISABLED_VAL,
+		.gyro_value = ST_LSM6DSM_SELF_TEST_DISABLED_VAL,
+	},
+	[1] = {
+		.string_mode = "positive-sign",
+		.accel_value = ST_LSM6DSM_SELF_TEST_POS_SIGN_VAL,
+		.gyro_value = ST_LSM6DSM_SELF_TEST_POS_SIGN_VAL
+	},
+	[2] = {
+		.string_mode = "negative-sign",
+		.accel_value = ST_LSM6DSM_SELF_TEST_NEG_ACCEL_SIGN_VAL,
+		.gyro_value = ST_LSM6DSM_SELF_TEST_NEG_GYRO_SIGN_VAL
+	},
+};
+
+struct st_lsm6dsm_odr_reg {
+	unsigned int hz;
+	u8 value;
+};
+
+static struct st_lsm6dsm_odr_table {
+	u8 addr[2];
+	u8 mask[2];
+	struct st_lsm6dsm_odr_reg odr_avl[ST_LSM6DSM_ODR_LIST_NUM];
+} st_lsm6dsm_odr_table = {
+	.addr[ST_MASK_ID_ACCEL] = ST_LSM6DSM_ACCEL_ODR_ADDR,
+	.mask[ST_MASK_ID_ACCEL] = ST_LSM6DSM_ACCEL_ODR_MASK,
+	.addr[ST_MASK_ID_GYRO] = ST_LSM6DSM_GYRO_ODR_ADDR,
+	.mask[ST_MASK_ID_GYRO] = ST_LSM6DSM_GYRO_ODR_MASK,
+	.odr_avl[0] = { .hz = 13, .value = ST_LSM6DSM_ODR_13HZ_VAL },
+	.odr_avl[1] = { .hz = 26, .value = ST_LSM6DSM_ODR_26HZ_VAL },
+	.odr_avl[2] = { .hz = 52, .value = ST_LSM6DSM_ODR_52HZ_VAL },
+	.odr_avl[3] = { .hz = 104, .value = ST_LSM6DSM_ODR_104HZ_VAL },
+	.odr_avl[4] = { .hz = 208, .value = ST_LSM6DSM_ODR_208HZ_VAL },
+	.odr_avl[5] = { .hz = 416, .value = ST_LSM6DSM_ODR_416HZ_VAL },
+	.odr_avl[6] = { .hz = 833, .value = ST_LSM6DSM_ODR_833HZ_VAL },
+};
+
+struct st_lsm6dsm_fs_reg {
+	unsigned int gain;
+	u8 value;
+};
+
+static struct st_lsm6dsm_fs_table {
+	u8 addr;
+	u8 mask;
+	struct st_lsm6dsm_fs_reg fs_avl[ST_LSM6DSM_FS_LIST_NUM];
+} st_lsm6dsm_fs_table[ST_INDIO_DEV_NUM] = {
+	[ST_MASK_ID_ACCEL] = {
+		.addr = ST_LSM6DSM_ACCEL_FS_ADDR,
+		.mask = ST_LSM6DSM_ACCEL_FS_MASK,
+		.fs_avl[0] = { .gain = ST_LSM6DSM_ACCEL_FS_2G_GAIN,
+					.value = ST_LSM6DSM_ACCEL_FS_2G_VAL },
+		.fs_avl[1] = { .gain = ST_LSM6DSM_ACCEL_FS_4G_GAIN,
+					.value = ST_LSM6DSM_ACCEL_FS_4G_VAL },
+		.fs_avl[2] = { .gain = ST_LSM6DSM_ACCEL_FS_8G_GAIN,
+					.value = ST_LSM6DSM_ACCEL_FS_8G_VAL },
+		.fs_avl[3] = { .gain = ST_LSM6DSM_ACCEL_FS_16G_GAIN,
+					.value = ST_LSM6DSM_ACCEL_FS_16G_VAL },
+	},
+	[ST_MASK_ID_GYRO] = {
+		.addr = ST_LSM6DSM_GYRO_FS_ADDR,
+		.mask = ST_LSM6DSM_GYRO_FS_MASK,
+		.fs_avl[0] = { .gain = ST_LSM6DSM_GYRO_FS_250_GAIN,
+					.value = ST_LSM6DSM_GYRO_FS_250_VAL },
+		.fs_avl[1] = { .gain = ST_LSM6DSM_GYRO_FS_500_GAIN,
+					.value = ST_LSM6DSM_GYRO_FS_500_VAL },
+		.fs_avl[2] = { .gain = ST_LSM6DSM_GYRO_FS_1000_GAIN,
+					.value = ST_LSM6DSM_GYRO_FS_1000_VAL },
+		.fs_avl[3] = { .gain = ST_LSM6DSM_GYRO_FS_2000_GAIN,
+					.value = ST_LSM6DSM_GYRO_FS_2000_VAL },
+	}
+};
+
+static const struct iio_event_spec singol_thr_event = {
+	.type = IIO_EV_TYPE_THRESH,
+	.dir = IIO_EV_DIR_RISING,
+};
+
+const struct iio_event_spec lsm6dsm_fifo_flush_event = {
+	.type = IIO_EV_TYPE_FIFO_FLUSH,
+	.dir = IIO_EV_DIR_EITHER,
+};
+
+static const struct iio_chan_spec st_lsm6dsm_accel_ch[] = {
+	ST_LSM6DSM_LSM_CHANNELS(IIO_ACCEL, 1, 0, IIO_MOD_X, IIO_LE,
+				16, 16, ST_LSM6DSM_ACCEL_OUT_X_L_ADDR, 's'),
+	ST_LSM6DSM_LSM_CHANNELS(IIO_ACCEL, 1, 1, IIO_MOD_Y, IIO_LE,
+				16, 16, ST_LSM6DSM_ACCEL_OUT_Y_L_ADDR, 's'),
+	ST_LSM6DSM_LSM_CHANNELS(IIO_ACCEL, 1, 2, IIO_MOD_Z, IIO_LE,
+				16, 16, ST_LSM6DSM_ACCEL_OUT_Z_L_ADDR, 's'),
+	ST_LSM6DSM_FLUSH_CHANNEL(IIO_ACCEL),
+	IIO_CHAN_SOFT_TIMESTAMP(3)
+};
+
+static const struct iio_chan_spec st_lsm6dsm_gyro_ch[] = {
+	ST_LSM6DSM_LSM_CHANNELS(IIO_ANGL_VEL, 1, 0, IIO_MOD_X, IIO_LE,
+				16, 16, ST_LSM6DSM_GYRO_OUT_X_L_ADDR, 's'),
+	ST_LSM6DSM_LSM_CHANNELS(IIO_ANGL_VEL, 1, 1, IIO_MOD_Y, IIO_LE,
+				16, 16, ST_LSM6DSM_GYRO_OUT_Y_L_ADDR, 's'),
+	ST_LSM6DSM_LSM_CHANNELS(IIO_ANGL_VEL, 1, 2, IIO_MOD_Z, IIO_LE,
+				16, 16, ST_LSM6DSM_GYRO_OUT_Z_L_ADDR, 's'),
+	ST_LSM6DSM_FLUSH_CHANNEL(IIO_ANGL_VEL),
+	IIO_CHAN_SOFT_TIMESTAMP(3)
+};
+
+static const struct iio_chan_spec st_lsm6dsm_sign_motion_ch[] = {
+	{
+		.type = IIO_SIGN_MOTION,
+		.channel = 0,
+		.modified = 0,
+		.event_spec = &singol_thr_event,
+		.num_event_specs = 1,
+	},
+	IIO_CHAN_SOFT_TIMESTAMP(1)
+};
+
+static const struct iio_chan_spec st_lsm6dsm_step_c_ch[] = {
+	{
+		.type = IIO_STEP_COUNTER,
+		.modified = 0,
+		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),
+		.address = ST_LSM6DSM_STEP_COUNTER_OUT_L_ADDR,
+		.scan_type = {
+			.sign = 'u',
+			.realbits = 64,
+			.storagebits = 64,
+			.endianness = IIO_LE,
+		},
+	},
+	ST_LSM6DSM_FLUSH_CHANNEL(IIO_STEP_COUNTER),
+	IIO_CHAN_SOFT_TIMESTAMP(1)
+};
+
+static const struct iio_chan_spec st_lsm6dsm_step_d_ch[] = {
+	ST_LSM6DSM_FLUSH_CHANNEL(IIO_STEP_DETECTOR),
+	IIO_CHAN_SOFT_TIMESTAMP(0)
+};
+
+static const struct iio_chan_spec st_lsm6dsm_tilt_ch[] = {
+	ST_LSM6DSM_FLUSH_CHANNEL(IIO_TILT),
+	IIO_CHAN_SOFT_TIMESTAMP(0)
+};
+
+int st_lsm6dsm_write_data_with_value(struct lsm6dsm_data *cdata,
+		u8 reg_addr, u8 mask, u8 data, bool b_lock)
+{
+	int err;
+	u8 new_data = 0x00, old_data = 0x00;
+
+	err = cdata->tf->read(cdata, reg_addr, 1, &old_data, b_lock);
+	if (err < 0)
+		return err;
+
+	new_data = mask;
+
+	if (new_data == old_data)
+		return 1;
+
+	if( ( reg_addr == 0xd ) && ( old_data == 0x0 ) )
+	{
+		cdata->tf->write(cdata, reg_addr, 1, &old_data, b_lock);
+		return 0;
+	}
+	else
+	{
+		return cdata->tf->write(cdata, reg_addr, 1, &new_data, b_lock);
+	}
+}
+EXPORT_SYMBOL(st_lsm6dsm_write_data_with_value);
+
+int st_lsm6dsm_write_data_with_mask(struct lsm6dsm_data *cdata,
+				u8 reg_addr, u8 mask, u8 data, bool b_lock)
+{
+	int err;
+	u8 new_data = 0x00, old_data = 0x00;
+
+	err = cdata->tf->read(cdata, reg_addr, 1, &old_data, b_lock);
+	if (err < 0)
+		return err;
+
+	new_data = ((old_data & (~mask)) | ((data << __ffs(mask)) & mask));
+
+	if (new_data == old_data)
+		return 1;
+
+	if( ( reg_addr == 0xd ) && ( old_data == 0x0 ) )
+	{
+		cdata->tf->write(cdata, reg_addr, 1, &old_data, b_lock);
+		return 0;
+	}
+	else
+	{
+		return cdata->tf->write(cdata, reg_addr, 1, &new_data, b_lock);
+	}
+}
+EXPORT_SYMBOL(st_lsm6dsm_write_data_with_mask);
+
+static inline int st_lsm6dsm_enable_embedded_page_regs(struct lsm6dsm_data *cdata, bool enable)
+{
+	u8 value = 0x00;
+
+	if (enable)
+		value = ST_LSM6DSM_FUNC_CFG_REG2_MASK;
+
+	return cdata->tf->write(cdata, ST_LSM6DSM_FUNC_CFG_ACCESS_ADDR, 1, &value, false);
+}
+
+int st_lsm6dsm_write_embedded_registers(struct lsm6dsm_data *cdata,
+					u8 reg_addr, u8 *data, int len)
+{
+	int err = 0, err2, count = 0;
+
+	mutex_lock(&cdata->bank_registers_lock);
+
+	if (cdata->enable_digfunc_mask) {
+		err = st_lsm6dsm_write_data_with_mask(cdata,
+					ST_LSM6DSM_FUNC_EN_ADDR,
+					ST_LSM6DSM_FUNC_EN_MASK,
+					ST_LSM6DSM_DIS_BIT, false);
+		if (err < 0) {
+			mutex_unlock(&cdata->bank_registers_lock);
+			return err;
+		}
+	}
+
+	udelay(100);
+
+	err = st_lsm6dsm_enable_embedded_page_regs(cdata, true);
+	if (err < 0)
+		goto restore_digfunc;
+
+	udelay(100);
+
+	err = cdata->tf->write(cdata, reg_addr, len, data, false);
+	if (err < 0)
+		goto restore_bank_regs;
+
+	err = st_lsm6dsm_enable_embedded_page_regs(cdata, false);
+	if (err < 0)
+		goto restore_bank_regs;
+
+	udelay(100);
+
+	if (cdata->enable_digfunc_mask) {
+		err = st_lsm6dsm_write_data_with_mask(cdata,
+					ST_LSM6DSM_FUNC_EN_ADDR,
+					ST_LSM6DSM_FUNC_EN_MASK,
+					ST_LSM6DSM_EN_BIT, false);
+		if (err < 0)
+			goto restore_digfunc;
+	}
+
+	mutex_unlock(&cdata->bank_registers_lock);
+
+	return 0;
+
+restore_bank_regs:
+	do {
+		msleep(200);
+		err2 = st_lsm6dsm_enable_embedded_page_regs(cdata, false);
+	} while ((err2 < 0) && (count++ < 10));
+
+	if (count >= 10)
+		pr_err("not able to close embedded page registers. It make driver unstable!\n");
+
+restore_digfunc:
+	if (!cdata->enable_digfunc_mask) {
+		err2 = st_lsm6dsm_write_data_with_mask(cdata,
+					ST_LSM6DSM_FUNC_EN_ADDR,
+					ST_LSM6DSM_FUNC_EN_MASK,
+					ST_LSM6DSM_EN_BIT, false);
+	}
+
+	mutex_unlock(&cdata->bank_registers_lock);
+
+	return err;
+}
+
+static int lsm6dsm_set_watermark(struct lsm6dsm_data *cdata)
+{
+	int err;
+	u8 reg_value = 0;
+	u16 fifo_watermark;
+	unsigned int fifo_len, sip = 0, min_pattern = UINT_MAX;
+
+	if (cdata->fifo_output[ST_MASK_ID_ACCEL].sip > 0) {
+		sip += cdata->fifo_output[ST_MASK_ID_ACCEL].sip;
+		min_pattern = MIN(min_pattern,
+			cdata->hwfifo_watermark[ST_MASK_ID_ACCEL] /
+			cdata->fifo_output[ST_MASK_ID_ACCEL].sip);
+	}
+
+	if (cdata->fifo_output[ST_MASK_ID_GYRO].sip > 0) {
+		sip += cdata->fifo_output[ST_MASK_ID_GYRO].sip;
+		min_pattern = MIN(min_pattern,
+			cdata->hwfifo_watermark[ST_MASK_ID_GYRO] /
+			cdata->fifo_output[ST_MASK_ID_GYRO].sip);
+	}
+
+#ifdef CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT
+	if (cdata->fifo_output[ST_MASK_ID_EXT0].sip > 0) {
+		sip += cdata->fifo_output[ST_MASK_ID_EXT0].sip;
+		min_pattern = MIN(min_pattern,
+			cdata->hwfifo_watermark[ST_MASK_ID_EXT0] /
+			cdata->fifo_output[ST_MASK_ID_EXT0].sip);
+	}
+#endif /* CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT */
+
+	if (sip == 0)
+		return 0;
+
+	if (min_pattern == 0)
+		min_pattern = 1;
+
+	min_pattern = MIN(min_pattern, ((unsigned int)ST_LSM6DSM_MAX_FIFO_THRESHOLD / sip));
+
+	fifo_len = min_pattern * sip * ST_LSM6DSM_FIFO_ELEMENT_LEN_BYTE;
+	fifo_watermark = (fifo_len / 2);
+
+	if (fifo_watermark < (ST_LSM6DSM_FIFO_ELEMENT_LEN_BYTE / 2))
+		fifo_watermark = ST_LSM6DSM_FIFO_ELEMENT_LEN_BYTE / 2;
+
+	if (fifo_watermark != cdata->fifo_watermark) {
+		err = cdata->tf->read(cdata, ST_LSM6DSM_FIFO_THR_H_ADDR, 1, &reg_value, true);
+		if (err < 0)
+			return err;
+
+		fifo_watermark = (fifo_watermark & ST_LSM6DSM_FIFO_THR_MASK) |
+					((reg_value & ~ST_LSM6DSM_FIFO_THR_MASK) << 8);
+
+		err = cdata->tf->write(cdata, ST_LSM6DSM_FIFO_THR_L_ADDR, 2,
+						(u8 *)&fifo_watermark, true);
+		if (err < 0)
+			return err;
+
+		cdata->fifo_watermark = fifo_watermark;
+	}
+
+	return 0;
+}
+
+int st_lsm6dsm_set_fifo_mode(struct lsm6dsm_data *cdata, enum fifo_mode fm)
+{
+	int err;
+	u8 reg_value;
+
+	switch (fm) {
+	case BYPASS:
+		reg_value = ST_LSM6DSM_FIFO_MODE_BYPASS;
+		break;
+	case CONTINUOS:
+		reg_value = ST_LSM6DSM_FIFO_MODE_CONTINUOS | ST_LSM6DSM_FIFO_ODR_MAX;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	err = cdata->tf->write(cdata, ST_LSM6DSM_FIFO_MODE_ADDR, 1, &reg_value, true);
+	if (err < 0)
+		return err;
+
+	if (fm != BYPASS) {
+		cdata->slower_counter = 0;
+		cdata->fifo_enable_timestamp = ktime_get_boottime_ns();
+		cdata->fifo_output[ST_MASK_ID_GYRO].timestamp = 0;
+		cdata->fifo_output[ST_MASK_ID_ACCEL].timestamp = 0;
+		cdata->fifo_output[ST_MASK_ID_EXT0].timestamp = 0;
+	}
+
+	cdata->fifo_status = fm;
+
+	return 0;
+}
+EXPORT_SYMBOL(st_lsm6dsm_set_fifo_mode);
+
+static int lsm6dsm_write_decimators(struct lsm6dsm_data *cdata,
+							u8 decimators[3])
+{
+	int i;
+	u8 value[3], decimators_reg[2];
+
+	for (i = 0; i < 3; i++) {
+		switch (decimators[i]) {
+		case 0:
+		case 1:
+		case 2:
+		case 3:
+		case 4:
+			value[i] = decimators[i];
+			break;
+		case 8:
+			value[i] = 0x05;
+			break;
+		case 16:
+			value[i] = 0x06;
+			break;
+		case 32:
+			value[i] = 0x07;
+			break;
+		default:
+			return -EINVAL;
+		}
+	}
+
+	decimators_reg[0] = value[0] | (value[1] << 3);
+	decimators_reg[1] = value[2];
+
+	return cdata->tf->write(cdata, ST_LSM6DSM_FIFO_DECIMATOR_ADDR,
+			ARRAY_SIZE(decimators_reg), decimators_reg, true);
+}
+
+static bool lsm6dsm_calculate_fifo_decimators(struct lsm6dsm_data *cdata,
+				u8 decimators[3], u8 samples_in_pattern[3],
+				unsigned int new_v_odr[ST_INDIO_DEV_NUM + 1],
+				unsigned int new_hw_odr[ST_INDIO_DEV_NUM + 1],
+				int64_t new_deltatime[ST_INDIO_DEV_NUM + 1],
+				short new_fifo_decimator[ST_INDIO_DEV_NUM + 1])
+{
+	unsigned int trigger_odr;
+	u8 min_decimator, max_decimator = 0;
+	u8 accel_decimator = 0, gyro_decimator = 0, ext_decimator = 0;
+
+	trigger_odr = new_hw_odr[ST_MASK_ID_ACCEL];
+	if (trigger_odr < new_hw_odr[ST_MASK_ID_GYRO])
+		trigger_odr = new_hw_odr[ST_MASK_ID_GYRO];
+
+	if ((cdata->sensors_use_fifo & BIT(ST_MASK_ID_ACCEL)) &&
+			(new_v_odr[ST_MASK_ID_ACCEL] != 0) && cdata->accel_on)
+		accel_decimator = trigger_odr / new_v_odr[ST_MASK_ID_ACCEL];
+
+	if ((cdata->sensors_use_fifo & BIT(ST_MASK_ID_GYRO)) &&
+				(new_v_odr[ST_MASK_ID_GYRO] != 0) &&
+					(new_hw_odr[ST_MASK_ID_GYRO] > 0))
+		gyro_decimator = trigger_odr / new_v_odr[ST_MASK_ID_GYRO];
+
+#ifdef CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT
+	if ((cdata->sensors_use_fifo & BIT(ST_MASK_ID_EXT0)) &&
+			(new_v_odr[ST_MASK_ID_EXT0] != 0) && cdata->magn_on)
+		ext_decimator = trigger_odr / new_v_odr[ST_MASK_ID_EXT0];
+
+	new_fifo_decimator[ST_MASK_ID_EXT0] = 1;
+#endif /* CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT */
+
+	new_fifo_decimator[ST_MASK_ID_ACCEL] = 1;
+	new_fifo_decimator[ST_MASK_ID_GYRO] = 1;
+
+	if ((accel_decimator != 0) || (gyro_decimator != 0) || (ext_decimator != 0)) {
+		min_decimator = MIN_BNZ(MIN_BNZ(accel_decimator, gyro_decimator), ext_decimator);
+		max_decimator = MAX(MAX(accel_decimator, gyro_decimator), ext_decimator);
+		if (min_decimator != 1) {
+			if ((accel_decimator / min_decimator) == 1) {
+				accel_decimator = 1;
+				new_fifo_decimator[ST_MASK_ID_ACCEL] = min_decimator;
+			} else if ((gyro_decimator / min_decimator) == 1) {
+				gyro_decimator = 1;
+				new_fifo_decimator[ST_MASK_ID_GYRO] = min_decimator;
+			} else if ((ext_decimator / min_decimator) == 1) {
+				ext_decimator = 1;
+				new_fifo_decimator[ST_MASK_ID_EXT0] = min_decimator;
+			}
+			min_decimator = 1;
+		}
+		if ((accel_decimator > 4) && (accel_decimator < 8)) {
+			new_fifo_decimator[ST_MASK_ID_ACCEL] = accel_decimator - 3;
+			accel_decimator = 4;
+		} else if ((accel_decimator > 8) && (accel_decimator < 16)) {
+			new_fifo_decimator[ST_MASK_ID_ACCEL] = accel_decimator - 7;
+			accel_decimator = 8;
+		} else if (accel_decimator > 16 && accel_decimator < 32) {
+			new_fifo_decimator[ST_MASK_ID_ACCEL] = accel_decimator - 15;
+			accel_decimator = 16;
+		} else if (accel_decimator > 32) {
+			new_fifo_decimator[ST_MASK_ID_ACCEL] = accel_decimator / 32;
+			accel_decimator = 32;
+		}
+		if ((gyro_decimator > 4) && (gyro_decimator < 8)) {
+			new_fifo_decimator[ST_MASK_ID_GYRO] = gyro_decimator - 3;
+			gyro_decimator = 4;
+		} else if ((gyro_decimator > 8) && (gyro_decimator < 16)) {
+			new_fifo_decimator[ST_MASK_ID_GYRO] = gyro_decimator - 7;
+			gyro_decimator = 8;
+		} else if (gyro_decimator > 16 && gyro_decimator < 32) {
+			new_fifo_decimator[ST_MASK_ID_GYRO] = gyro_decimator - 15;
+			gyro_decimator = 16;
+		} else if (gyro_decimator > 32) {
+			new_fifo_decimator[ST_MASK_ID_GYRO] = gyro_decimator / 32;
+			gyro_decimator = 32;
+		}
+#ifdef CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT
+		if ((ext_decimator > 4) && (ext_decimator < 8)) {
+			new_fifo_decimator[ST_MASK_ID_EXT0] = ext_decimator - 3;
+			ext_decimator = 4;
+		} else if ((ext_decimator > 8) && (ext_decimator < 16)) {
+			new_fifo_decimator[ST_MASK_ID_EXT0] = ext_decimator - 7;
+			ext_decimator = 8;
+		} else if (ext_decimator > 16 && ext_decimator < 32) {
+			new_fifo_decimator[ST_MASK_ID_EXT0] = ext_decimator - 15;
+			ext_decimator = 16;
+		} else if (ext_decimator > 32) {
+			new_fifo_decimator[ST_MASK_ID_EXT0] = ext_decimator / 32;
+			ext_decimator = 32;
+		}
+#endif /* CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT */
+		max_decimator = MAX(MAX(accel_decimator, gyro_decimator), ext_decimator);
+	}
+
+	decimators[0] = accel_decimator;
+	if (accel_decimator > 0) {
+		new_deltatime[ST_MASK_ID_ACCEL] = accel_decimator *
+						(1000000000U / trigger_odr);
+		samples_in_pattern[0] = max_decimator / accel_decimator;
+	} else
+		samples_in_pattern[0] = 0;
+
+	decimators[1] = gyro_decimator;
+	if (gyro_decimator > 0) {
+		new_deltatime[ST_MASK_ID_GYRO] = gyro_decimator *
+						(1000000000U / trigger_odr);
+		samples_in_pattern[1] = max_decimator / gyro_decimator;
+	} else
+		samples_in_pattern[1] = 0;
+
+#ifdef CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT
+	decimators[2] = ext_decimator;
+	if (ext_decimator > 0) {
+		new_deltatime[ST_MASK_ID_EXT0] = ext_decimator *
+						(1000000000U / trigger_odr);
+		samples_in_pattern[2] = max_decimator / ext_decimator;
+	} else
+		samples_in_pattern[2] = 0;
+#endif /* CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT */
+
+#ifdef CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT
+	if ((accel_decimator == cdata->hwfifo_decimator[ST_MASK_ID_ACCEL]) &&
+		(ext_decimator == cdata->hwfifo_decimator[ST_MASK_ID_EXT0]) &&
+		(gyro_decimator == cdata->hwfifo_decimator[ST_MASK_ID_GYRO])) {
+
+#else /* CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT */
+	if ((accel_decimator == cdata->hwfifo_decimator[ST_MASK_ID_ACCEL]) &&
+		(gyro_decimator == cdata->hwfifo_decimator[ST_MASK_ID_GYRO])) {
+#endif /* CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT */
+		return false;
+	}
+
+	return true;
+}
+
+static int st_lsm6dsm_of_get_drdy_pin(struct lsm6dsm_data *cdata,
+				int *drdy_pin)
+{
+	struct device_node *np = cdata->dev->of_node;
+
+	if (!np)
+		return -EINVAL;
+
+	return of_property_read_u32(np, "st,drdy-int-pin", drdy_pin);
+}
+
+static int st_lsm6dsm_get_drdy_reg(struct lsm6dsm_data *cdata, u8 *drdy_reg)
+{
+	int err = 0, drdy_pin;
+
+	if (st_lsm6dsm_of_get_drdy_pin(cdata, &drdy_pin) < 0) {
+		struct st_sensors_platform_data *pdata;
+		struct device *dev = cdata->dev;
+
+		pdata = (struct st_sensors_platform_data *)dev->platform_data;
+		drdy_pin = pdata ? pdata->drdy_int_pin : 1;
+	}
+
+	switch (drdy_pin) {
+	case 1:
+		*drdy_reg = ST_LSM6DSM_INT1_ADDR;
+		break;
+	case 2:
+		*drdy_reg = ST_LSM6DSM_INT2_ADDR;
+		break;
+	default:
+		dev_err(cdata->dev, "unsupported data ready pin\n");
+		err = -EINVAL;
+		break;
+	}
+
+	return err;
+}
+
+int st_lsm6dsm_set_drdy_irq(struct lsm6dsm_sensor_data *sdata, bool state)
+{
+	int err;
+	u16 *irq_mask = NULL;
+	u8 reg_addr, mask = 0, value;
+	u16 tmp_irq_enable_fifo_mask, tmp_irq_enable_accel_ext_mask;
+
+	if (state)
+		value = ST_LSM6DSM_EN_BIT;
+	else
+		value = ST_LSM6DSM_DIS_BIT;
+
+	tmp_irq_enable_fifo_mask =
+			sdata->cdata->irq_enable_fifo_mask & ~sdata->sindex;
+	tmp_irq_enable_accel_ext_mask =
+			sdata->cdata->irq_enable_accel_ext_mask & ~sdata->sindex;
+
+	switch (sdata->sindex) {
+	case ST_MASK_ID_ACCEL:
+		reg_addr = sdata->cdata->drdy_reg;
+
+		if (sdata->cdata->hwfifo_enabled[ST_MASK_ID_ACCEL]) {
+			if (tmp_irq_enable_fifo_mask == 0)
+				mask = ST_LSM6DSM_FIFO_THR_IRQ_MASK;
+
+			irq_mask = &sdata->cdata->irq_enable_fifo_mask;
+		} else {
+			if (tmp_irq_enable_accel_ext_mask == 0)
+				mask = ST_LSM6DSM_ACCEL_DRDY_IRQ_MASK;
+
+			irq_mask = &sdata->cdata->irq_enable_accel_ext_mask;
+		}
+
+		break;
+	case ST_MASK_ID_GYRO:
+		reg_addr = sdata->cdata->drdy_reg;
+
+		if (sdata->cdata->hwfifo_enabled[ST_MASK_ID_GYRO]) {
+			if (tmp_irq_enable_fifo_mask == 0)
+				mask = ST_LSM6DSM_FIFO_THR_IRQ_MASK;
+
+			irq_mask = &sdata->cdata->irq_enable_fifo_mask;
+		} else
+			mask = ST_LSM6DSM_GYRO_DRDY_IRQ_MASK;
+
+		break;
+	case ST_MASK_ID_SIGN_MOTION:
+		reg_addr = ST_LSM6DSM_INT1_ADDR;
+		mask = ST_LSM6DSM_SIGN_MOTION_DRDY_IRQ_MASK;
+		break;
+	case ST_MASK_ID_STEP_COUNTER:
+		reg_addr = ST_LSM6DSM_INT2_ADDR;
+		mask = ST_LSM6DSM_STEP_COUNTER_DRDY_IRQ_MASK;
+		break;
+	case ST_MASK_ID_STEP_DETECTOR:
+		reg_addr = ST_LSM6DSM_INT1_ADDR;
+		mask = ST_LSM6DSM_STEP_DETECTOR_DRDY_IRQ_MASK;
+		break;
+	case ST_MASK_ID_TILT:
+		reg_addr = ST_LSM6DSM_MD1_ADDR;
+		mask = ST_LSM6DSM_TILT_DRDY_IRQ_MASK;
+		break;
+#ifdef CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT
+	case ST_MASK_ID_EXT0:
+		reg_addr = sdata->cdata->drdy_reg;
+
+		if (sdata->cdata->hwfifo_enabled[ST_MASK_ID_EXT0]) {
+			if (tmp_irq_enable_fifo_mask == 0)
+				mask = ST_LSM6DSM_FIFO_THR_IRQ_MASK;
+
+			irq_mask = &sdata->cdata->irq_enable_fifo_mask;
+		} else {
+			if (tmp_irq_enable_accel_ext_mask == 0)
+				mask = ST_LSM6DSM_ACCEL_DRDY_IRQ_MASK;
+
+			irq_mask = &sdata->cdata->irq_enable_accel_ext_mask;
+		}
+
+		break;
+#endif /* CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT */
+	default:
+		return -EINVAL;
+	}
+
+	if (mask > 0) {
+		err = st_lsm6dsm_write_data_with_mask(sdata->cdata,
+						reg_addr, mask, value, true);
+		if (err < 0)
+			return err;
+	}
+
+	if (irq_mask != NULL) {
+		if (state)
+			*irq_mask |= BIT(sdata->sindex);
+		else
+			*irq_mask &= ~BIT(sdata->sindex);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(st_lsm6dsm_set_drdy_irq);
+
+static int st_lsm6dsm_set_odr(struct lsm6dsm_sensor_data *sdata,
+						unsigned int odr, bool force)
+{
+	u8 reg_value;
+	int err, i = 0, n;
+	int64_t temp_last_timestamp[3] = { 0 };
+	bool scan_odr = true, fifo_conf_changed;
+	unsigned int temp_v_odr[ST_INDIO_DEV_NUM + 1];
+	unsigned int temp_hw_odr[ST_INDIO_DEV_NUM + 1];
+	int64_t new_deltatime[ST_INDIO_DEV_NUM + 1] = { 0 };
+	short new_fifo_decimator[ST_INDIO_DEV_NUM + 1] = { 0 };
+	u8 fifo_decimator[3] = { 0 }, samples_in_pattern[3] = { 0 };
+	u8 temp_num_samples[3] = { 0 }, temp_old_decimator[3] = { 1 };
+
+	if (odr == 0) {
+		if (force)
+			scan_odr = false;
+		else
+			return -EINVAL;
+	}
+
+	if (scan_odr) {
+		for (i = 0; i < ST_LSM6DSM_ODR_LIST_NUM; i++) {
+			if (st_lsm6dsm_odr_table.odr_avl[i].hz == odr)
+				break;
+		}
+		if (i == ST_LSM6DSM_ODR_LIST_NUM)
+			return -EINVAL;
+
+		if (!force) {
+			if ((sdata->cdata->sensors_enabled & BIT(sdata->sindex)) == 0) {
+				sdata->cdata->v_odr[sdata->sindex] = st_lsm6dsm_odr_table.odr_avl[i].hz;
+				return 0;
+			}
+		}
+
+		if (sdata->cdata->hw_odr[sdata->sindex] == st_lsm6dsm_odr_table.odr_avl[i].hz)
+			reg_value = 0xff;
+		else
+			reg_value = st_lsm6dsm_odr_table.odr_avl[i].value;
+	} else
+		reg_value = ST_LSM6DSM_ODR_POWER_OFF_VAL;
+
+	if (sdata->cdata->sensors_use_fifo > 0) {
+		/* someone is using fifo */
+		temp_v_odr[ST_MASK_ID_ACCEL] = sdata->cdata->v_odr[ST_MASK_ID_ACCEL];
+		temp_v_odr[ST_MASK_ID_GYRO] = sdata->cdata->v_odr[ST_MASK_ID_GYRO];
+
+		if (sdata->sindex == ST_MASK_ID_ACCEL) {
+			if (force)
+				temp_v_odr[ST_MASK_ID_ACCEL] = sdata->cdata->accel_odr_dependency[0];
+
+			temp_hw_odr[ST_MASK_ID_ACCEL] = odr;
+			temp_hw_odr[ST_MASK_ID_GYRO] = sdata->cdata->hw_odr[ST_MASK_ID_GYRO];
+		} else {
+			if (!force)
+				temp_v_odr[ST_MASK_ID_GYRO] = odr;
+
+			temp_hw_odr[ST_MASK_ID_GYRO] = odr;
+			temp_hw_odr[ST_MASK_ID_ACCEL] = sdata->cdata->hw_odr[ST_MASK_ID_ACCEL];
+		}
+#ifdef CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT
+		temp_v_odr[ST_MASK_ID_EXT0] = sdata->cdata->v_odr[ST_MASK_ID_EXT0];
+#endif /* CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT */
+
+		fifo_conf_changed = lsm6dsm_calculate_fifo_decimators(sdata->cdata,
+				fifo_decimator, samples_in_pattern, temp_v_odr,
+				temp_hw_odr, new_deltatime, new_fifo_decimator);
+		if (fifo_conf_changed) {
+			/* FIFO configuration changed, needs to write new decimators */
+			disable_irq(sdata->cdata->irq);
+
+			if (sdata->cdata->fifo_status != BYPASS) {
+				st_lsm6dsm_read_fifo(sdata->cdata, true);
+
+				temp_num_samples[0] = sdata->cdata->fifo_output[ST_MASK_ID_ACCEL].sip;
+				temp_num_samples[1] = sdata->cdata->fifo_output[ST_MASK_ID_GYRO].sip;
+				temp_last_timestamp[0] = sdata->cdata->fifo_output[ST_MASK_ID_ACCEL].timestamp_p;
+				temp_last_timestamp[1] = sdata->cdata->fifo_output[ST_MASK_ID_GYRO].timestamp_p;
+				temp_old_decimator[0] = sdata->cdata->fifo_output[ST_MASK_ID_ACCEL].decimator;
+				temp_old_decimator[1] = sdata->cdata->fifo_output[ST_MASK_ID_GYRO].decimator;
+
+#ifdef CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT
+				temp_num_samples[2] = sdata->cdata->fifo_output[ST_MASK_ID_EXT0].sip;
+				temp_last_timestamp[2] = sdata->cdata->fifo_output[ST_MASK_ID_EXT0].timestamp_p;
+				temp_old_decimator[2] = sdata->cdata->fifo_output[ST_MASK_ID_EXT0].decimator;
+#endif /* CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT */
+
+				err = st_lsm6dsm_set_fifo_mode(sdata->cdata, BYPASS);
+				if (err < 0)
+					goto reenable_fifo_irq;
+			} else {
+				temp_num_samples[0] = 0;
+				temp_num_samples[1] = 0;
+#ifdef CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT
+				temp_num_samples[2] = 0;
+#endif /* CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT */
+			}
+
+			err = lsm6dsm_write_decimators(sdata->cdata, fifo_decimator);
+			if (err < 0)
+				goto reenable_fifo_irq;
+
+			if (reg_value != 0xff) {
+				err = st_lsm6dsm_write_data_with_mask(sdata->cdata,
+						st_lsm6dsm_odr_table.addr[sdata->sindex],
+						st_lsm6dsm_odr_table.mask[sdata->sindex],
+						reg_value, true);
+				if (err < 0)
+					goto reenable_fifo_irq;
+
+				if (sdata->sindex == ST_MASK_ID_ACCEL) {
+					switch (temp_hw_odr[ST_MASK_ID_ACCEL]) {
+					case 13:
+					case 26:
+					case 52:
+						if (temp_num_samples[0] == 0)
+							sdata->cdata->samples_to_discard[ST_MASK_ID_ACCEL] = ST_LSM6DSM_ACCEL_STD_52HZ;
+						else
+							sdata->cdata->samples_to_discard_2[ST_MASK_ID_ACCEL] = ST_LSM6DSM_ACCEL_STD_52HZ;
+						break;
+					case 104:
+						if (temp_num_samples[0] == 0)
+							sdata->cdata->samples_to_discard[ST_MASK_ID_ACCEL] = ST_LSM6DSM_ACCEL_STD_104HZ;
+						else
+							sdata->cdata->samples_to_discard_2[ST_MASK_ID_ACCEL] = ST_LSM6DSM_ACCEL_STD_104HZ;
+						break;
+					default:
+						if (temp_num_samples[0] == 0)
+							sdata->cdata->samples_to_discard[ST_MASK_ID_ACCEL] = ST_LSM6DSM_ACCEL_STD_208HZ;
+						else
+							sdata->cdata->samples_to_discard_2[ST_MASK_ID_ACCEL] = ST_LSM6DSM_ACCEL_STD_208HZ;
+						break;
+					}
+				}
+
+				switch (temp_hw_odr[ST_MASK_ID_GYRO]) {
+				case 13:
+					if (temp_num_samples[1] == 0)
+						sdata->cdata->samples_to_discard[ST_MASK_ID_GYRO] = ST_LSM6DSM_GYRO_STD_13HZ;
+					else
+						sdata->cdata->samples_to_discard_2[ST_MASK_ID_GYRO] = ST_LSM6DSM_GYRO_STD_13HZ;
+					break;
+				case 26:
+				case 52:
+					if (temp_num_samples[1] == 0)
+						sdata->cdata->samples_to_discard[ST_MASK_ID_GYRO] = ST_LSM6DSM_GYRO_STD_52HZ;
+					else
+						sdata->cdata->samples_to_discard_2[ST_MASK_ID_GYRO] = ST_LSM6DSM_GYRO_STD_52HZ;
+					break;
+				case 104:
+					if (temp_num_samples[1] == 0)
+						sdata->cdata->samples_to_discard[ST_MASK_ID_GYRO] = ST_LSM6DSM_GYRO_STD_104HZ;
+					else
+						sdata->cdata->samples_to_discard_2[ST_MASK_ID_GYRO] = ST_LSM6DSM_GYRO_STD_104HZ;
+					break;
+				default:
+					if (temp_num_samples[1] == 0)
+						sdata->cdata->samples_to_discard[ST_MASK_ID_GYRO] = ST_LSM6DSM_GYRO_STD_208HZ;
+					else
+						sdata->cdata->samples_to_discard_2[ST_MASK_ID_GYRO] = ST_LSM6DSM_GYRO_STD_208HZ;
+					break;
+				}
+			}
+
+			sdata->cdata->hwfifo_decimator[ST_MASK_ID_ACCEL] = fifo_decimator[0];
+			sdata->cdata->hwfifo_decimator[ST_MASK_ID_GYRO] = fifo_decimator[1];
+
+			sdata->cdata->fifo_output[ST_MASK_ID_ACCEL].decimator = new_fifo_decimator[ST_MASK_ID_ACCEL];
+			sdata->cdata->fifo_output[ST_MASK_ID_GYRO].decimator = new_fifo_decimator[ST_MASK_ID_GYRO];
+
+			sdata->cdata->fifo_output[ST_MASK_ID_ACCEL].num_samples = new_fifo_decimator[ST_MASK_ID_ACCEL] - 1;
+			sdata->cdata->fifo_output[ST_MASK_ID_GYRO].num_samples = new_fifo_decimator[ST_MASK_ID_GYRO] - 1;
+
+			sdata->cdata->fifo_output[ST_MASK_ID_ACCEL].sip = samples_in_pattern[0];
+			sdata->cdata->fifo_output[ST_MASK_ID_GYRO].sip = samples_in_pattern[1];
+
+			sdata->cdata->fifo_output[ST_MASK_ID_ACCEL].deltatime_default = new_deltatime[ST_MASK_ID_ACCEL];
+			sdata->cdata->fifo_output[ST_MASK_ID_GYRO].deltatime_default = new_deltatime[ST_MASK_ID_GYRO];
+
+#ifdef CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT
+			sdata->cdata->hwfifo_decimator[ST_MASK_ID_EXT0] = fifo_decimator[2];
+			sdata->cdata->fifo_output[ST_MASK_ID_EXT0].decimator = new_fifo_decimator[ST_MASK_ID_EXT0];
+			sdata->cdata->fifo_output[ST_MASK_ID_EXT0].num_samples = new_fifo_decimator[ST_MASK_ID_EXT0] - 1;
+			sdata->cdata->fifo_output[ST_MASK_ID_EXT0].sip = samples_in_pattern[2];
+			sdata->cdata->fifo_output[ST_MASK_ID_EXT0].deltatime_default = new_deltatime[ST_MASK_ID_EXT0];
+#endif /* CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT */
+
+			err = lsm6dsm_set_watermark(sdata->cdata);
+			if (err < 0)
+				goto reenable_fifo_irq;
+
+			if ((samples_in_pattern[0] > 0) || (samples_in_pattern[1] > 0) || (samples_in_pattern[2] > 0)) {
+				err = st_lsm6dsm_set_fifo_mode(sdata->cdata, CONTINUOS);
+				if (err < 0)
+					goto reenable_fifo_irq;
+
+				if (((temp_num_samples[0] > 0) && (samples_in_pattern[0] > 0)) && (sdata->cdata->fifo_output[ST_MASK_ID_ACCEL].initialized)) {
+					unsigned int n_gen;
+					int64_t temp_deltatime = 0;
+
+					if (sdata->cdata->fifo_enable_timestamp > temp_last_timestamp[0]) {
+						n_gen = div64_s64(sdata->cdata->fifo_enable_timestamp - temp_last_timestamp[0],
+							sdata->cdata->fifo_output[ST_MASK_ID_ACCEL].deltatime * temp_old_decimator[0]);
+
+						if (n_gen > 0)
+							temp_deltatime = div64_s64(sdata->cdata->fifo_enable_timestamp - temp_last_timestamp[0], n_gen);
+
+						for (n = 0; n < n_gen; n++) {
+							temp_last_timestamp[0] += temp_deltatime;
+							err = st_lsm6dsm_push_data_with_timestamp(sdata->cdata, ST_MASK_ID_ACCEL,
+								sdata->cdata->accel_last_push, temp_last_timestamp[0]);
+							if (err < 0)
+								break;
+
+							sdata->cdata->fifo_output[ST_MASK_ID_ACCEL].timestamp_p = temp_last_timestamp[0];
+						}
+					}
+				} else
+					sdata->cdata->fifo_output[ST_MASK_ID_ACCEL].deltatime = new_deltatime[ST_MASK_ID_ACCEL];
+
+				if (((temp_num_samples[1] > 0) && (samples_in_pattern[1] > 0)) && (sdata->cdata->fifo_output[ST_MASK_ID_GYRO].initialized)) {
+					unsigned int n_gen;
+					int64_t temp_deltatime = 0;
+
+					if (sdata->cdata->fifo_enable_timestamp > temp_last_timestamp[1]) {
+						n_gen = div64_s64(sdata->cdata->fifo_enable_timestamp - temp_last_timestamp[1],
+							sdata->cdata->fifo_output[ST_MASK_ID_GYRO].deltatime * temp_old_decimator[1]);
+
+						if (n_gen > 0)
+							temp_deltatime = div64_s64(sdata->cdata->fifo_enable_timestamp - temp_last_timestamp[1], n_gen);
+
+						for (n = 0; n < n_gen; n++) {
+							temp_last_timestamp[1] += temp_deltatime;
+							err = st_lsm6dsm_push_data_with_timestamp(sdata->cdata, ST_MASK_ID_GYRO,
+								sdata->cdata->gyro_last_push, temp_last_timestamp[1]);
+							if (err < 0)
+								break;
+
+							sdata->cdata->fifo_output[ST_MASK_ID_GYRO].timestamp_p = temp_last_timestamp[1];
+						}
+					}
+				} else
+					sdata->cdata->fifo_output[ST_MASK_ID_GYRO].deltatime = new_deltatime[ST_MASK_ID_GYRO];
+
+#ifdef CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT
+				if (((temp_num_samples[2] > 0) && (samples_in_pattern[2] > 0)) && (sdata->cdata->fifo_output[ST_MASK_ID_EXT0].initialized)) {
+					unsigned int n_gen;
+					int64_t temp_deltatime = 0;
+
+					if (sdata->cdata->fifo_enable_timestamp > temp_last_timestamp[2]) {
+						n_gen = div64_s64(sdata->cdata->fifo_enable_timestamp - temp_last_timestamp[2],
+							sdata->cdata->fifo_output[ST_MASK_ID_EXT0].deltatime * temp_old_decimator[2]);
+
+						if (n_gen > 0)
+							temp_deltatime = div64_s64(sdata->cdata->fifo_enable_timestamp - temp_last_timestamp[2], n_gen);
+
+						for (n = 0; n < n_gen; n++) {
+							temp_last_timestamp[2] += temp_deltatime;
+							err = st_lsm6dsm_push_data_with_timestamp(sdata->cdata, ST_MASK_ID_EXT0,
+								sdata->cdata->ext0_last_push, temp_last_timestamp[2]);
+							if (err < 0)
+								break;
+
+							sdata->cdata->fifo_output[ST_MASK_ID_EXT0].timestamp_p = temp_last_timestamp[2];
+						}
+					}
+				} else
+					sdata->cdata->fifo_output[ST_MASK_ID_EXT0].deltatime = new_deltatime[ST_MASK_ID_EXT0];
+#endif /* CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT */
+			}
+
+			enable_irq(sdata->cdata->irq);
+		} else {
+			/* FIFO configuration not changed */
+
+			if (reg_value == 0xff) {
+				if (temp_v_odr[sdata->sindex] != 0)
+					sdata->cdata->v_odr[sdata->sindex] = temp_v_odr[sdata->sindex];
+
+				sdata->cdata->hw_odr[sdata->sindex] = temp_hw_odr[sdata->sindex];
+				return 0;
+			}
+
+			disable_irq(sdata->cdata->irq);
+
+			if (sdata->cdata->fifo_status != BYPASS) {
+				st_lsm6dsm_read_fifo(sdata->cdata, true);
+
+				temp_num_samples[0] = sdata->cdata->fifo_output[ST_MASK_ID_ACCEL].sip;
+				temp_num_samples[1] = sdata->cdata->fifo_output[ST_MASK_ID_GYRO].sip;
+				temp_last_timestamp[0] = sdata->cdata->fifo_output[ST_MASK_ID_ACCEL].timestamp_p;
+				temp_last_timestamp[1] = sdata->cdata->fifo_output[ST_MASK_ID_GYRO].timestamp_p;
+				temp_old_decimator[0] = sdata->cdata->fifo_output[ST_MASK_ID_ACCEL].decimator;
+				temp_old_decimator[1] = sdata->cdata->fifo_output[ST_MASK_ID_GYRO].decimator;
+
+#ifdef CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT
+				temp_num_samples[2] = sdata->cdata->fifo_output[ST_MASK_ID_EXT0].sip;
+				temp_last_timestamp[2] = sdata->cdata->fifo_output[ST_MASK_ID_EXT0].timestamp_p;
+				temp_old_decimator[2] = sdata->cdata->fifo_output[ST_MASK_ID_EXT0].decimator;
+#endif /* CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT */
+
+				err = st_lsm6dsm_set_fifo_mode(sdata->cdata, BYPASS);
+				if (err < 0)
+					goto reenable_fifo_irq;
+			} else {
+				temp_num_samples[0] = 0;
+				temp_num_samples[1] = 0;
+#ifdef CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT
+				temp_num_samples[2] = 0;
+#endif /* CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT */
+			}
+
+			err = st_lsm6dsm_write_data_with_mask(sdata->cdata,
+					st_lsm6dsm_odr_table.addr[sdata->sindex],
+					st_lsm6dsm_odr_table.mask[sdata->sindex],
+					reg_value, true);
+			if (err < 0)
+				goto reenable_fifo_irq;
+
+			if (sdata->sindex == ST_MASK_ID_ACCEL) {
+				switch (temp_hw_odr[ST_MASK_ID_ACCEL]) {
+				case 13:
+				case 26:
+				case 52:
+					if (temp_num_samples[0] == 0)
+						sdata->cdata->samples_to_discard[ST_MASK_ID_ACCEL] = ST_LSM6DSM_ACCEL_STD_52HZ;
+					else
+						sdata->cdata->samples_to_discard_2[ST_MASK_ID_ACCEL] = ST_LSM6DSM_ACCEL_STD_52HZ;
+					break;
+				case 104:
+					if (temp_num_samples[0] == 0)
+						sdata->cdata->samples_to_discard[ST_MASK_ID_ACCEL] = ST_LSM6DSM_ACCEL_STD_104HZ;
+					else
+						sdata->cdata->samples_to_discard_2[ST_MASK_ID_ACCEL] = ST_LSM6DSM_ACCEL_STD_104HZ;
+					break;
+				default:
+					if (temp_num_samples[0] == 0)
+						sdata->cdata->samples_to_discard[ST_MASK_ID_ACCEL] = ST_LSM6DSM_ACCEL_STD_208HZ;
+					else
+						sdata->cdata->samples_to_discard_2[ST_MASK_ID_ACCEL] = ST_LSM6DSM_ACCEL_STD_208HZ;
+					break;
+				}
+			}
+
+			switch (temp_hw_odr[ST_MASK_ID_GYRO]) {
+			case 13:
+				if (temp_num_samples[1] == 0)
+					sdata->cdata->samples_to_discard[ST_MASK_ID_GYRO] = ST_LSM6DSM_GYRO_STD_13HZ;
+				else
+					sdata->cdata->samples_to_discard_2[ST_MASK_ID_GYRO] = ST_LSM6DSM_GYRO_STD_13HZ;
+				break;
+			case 26:
+			case 52:
+				if (temp_num_samples[1] == 0)
+					sdata->cdata->samples_to_discard[ST_MASK_ID_GYRO] = ST_LSM6DSM_GYRO_STD_52HZ;
+				else
+					sdata->cdata->samples_to_discard_2[ST_MASK_ID_GYRO] = ST_LSM6DSM_GYRO_STD_52HZ;
+				break;
+			case 104:
+				if (temp_num_samples[1] == 0)
+					sdata->cdata->samples_to_discard[ST_MASK_ID_GYRO] = ST_LSM6DSM_GYRO_STD_104HZ;
+				else
+					sdata->cdata->samples_to_discard_2[ST_MASK_ID_GYRO] = ST_LSM6DSM_GYRO_STD_104HZ;
+				break;
+			default:
+				if (temp_num_samples[1] == 0)
+					sdata->cdata->samples_to_discard[ST_MASK_ID_GYRO] = ST_LSM6DSM_GYRO_STD_208HZ;
+				else
+					sdata->cdata->samples_to_discard_2[ST_MASK_ID_GYRO] = ST_LSM6DSM_GYRO_STD_208HZ;
+				break;
+			}
+
+			if ((sdata->cdata->fifo_output[ST_MASK_ID_ACCEL].sip > 0) ||
+					(sdata->cdata->fifo_output[ST_MASK_ID_GYRO].sip > 0) ||
+						(sdata->cdata->fifo_output[ST_MASK_ID_EXT0].sip > 0)) {
+				err = st_lsm6dsm_set_fifo_mode(sdata->cdata, CONTINUOS);
+				if (err < 0)
+					goto reenable_fifo_irq;
+
+				if (((temp_num_samples[0] > 0) && (samples_in_pattern[0] > 0)) && (sdata->cdata->fifo_output[ST_MASK_ID_ACCEL].initialized)) {
+					unsigned int n_gen;
+					int64_t temp_deltatime = 0;
+
+					if (sdata->cdata->fifo_enable_timestamp > temp_last_timestamp[0]) {
+						n_gen = div64_s64(sdata->cdata->fifo_enable_timestamp - temp_last_timestamp[0],
+							sdata->cdata->fifo_output[ST_MASK_ID_ACCEL].deltatime * temp_old_decimator[0]);
+
+						if (n_gen > 0)
+							temp_deltatime = div64_s64(sdata->cdata->fifo_enable_timestamp - temp_last_timestamp[0], n_gen);
+
+						for (n = 0; n < n_gen; n++) {
+							temp_last_timestamp[0] += temp_deltatime;
+							err = st_lsm6dsm_push_data_with_timestamp(sdata->cdata, ST_MASK_ID_ACCEL,
+								sdata->cdata->accel_last_push, temp_last_timestamp[0]);
+							if (err < 0)
+								break;
+
+							sdata->cdata->fifo_output[ST_MASK_ID_ACCEL].timestamp_p = temp_last_timestamp[0];
+						}
+					}
+				} else
+					sdata->cdata->fifo_output[ST_MASK_ID_ACCEL].deltatime = new_deltatime[ST_MASK_ID_ACCEL];
+
+				if (((temp_num_samples[1] > 0) && (samples_in_pattern[1] > 0)) && (sdata->cdata->fifo_output[ST_MASK_ID_GYRO].initialized)) {
+					unsigned int n_gen;
+					int64_t temp_deltatime = 0;
+
+					if (sdata->cdata->fifo_enable_timestamp > temp_last_timestamp[1]) {
+						n_gen = div64_s64(sdata->cdata->fifo_enable_timestamp - temp_last_timestamp[1],
+							sdata->cdata->fifo_output[ST_MASK_ID_GYRO].deltatime * temp_old_decimator[1]);
+
+						if (n_gen > 0)
+							temp_deltatime = div64_s64(sdata->cdata->fifo_enable_timestamp - temp_last_timestamp[1], n_gen);
+
+						for (n = 0; n < n_gen; n++) {
+							temp_last_timestamp[1] += temp_deltatime;
+							err = st_lsm6dsm_push_data_with_timestamp(sdata->cdata, ST_MASK_ID_GYRO,
+								sdata->cdata->gyro_last_push, temp_last_timestamp[1]);
+							if (err < 0)
+								break;
+
+							sdata->cdata->fifo_output[ST_MASK_ID_GYRO].timestamp_p = temp_last_timestamp[1];
+						}
+					}
+				} else
+					sdata->cdata->fifo_output[ST_MASK_ID_GYRO].deltatime = new_deltatime[ST_MASK_ID_GYRO];
+
+#ifdef CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT
+				if (((temp_num_samples[2] > 0) && (samples_in_pattern[2] > 0)) && (sdata->cdata->fifo_output[ST_MASK_ID_EXT0].initialized)) {
+					unsigned int n_gen;
+					int64_t temp_deltatime = 0;
+
+					if (sdata->cdata->fifo_enable_timestamp > temp_last_timestamp[2]) {
+						n_gen = div64_s64(sdata->cdata->fifo_enable_timestamp - temp_last_timestamp[2],
+							sdata->cdata->fifo_output[ST_MASK_ID_EXT0].deltatime * temp_old_decimator[2]);
+
+						if (n_gen > 0)
+							temp_deltatime = div64_s64(sdata->cdata->fifo_enable_timestamp - temp_last_timestamp[2], n_gen);
+
+						for (n = 0; n < n_gen; n++) {
+							temp_last_timestamp[2] += temp_deltatime;
+							err = st_lsm6dsm_push_data_with_timestamp(sdata->cdata, ST_MASK_ID_EXT0,
+								sdata->cdata->ext0_last_push, temp_last_timestamp[2]);
+							if (err < 0)
+								break;
+
+							sdata->cdata->fifo_output[ST_MASK_ID_EXT0].timestamp_p = temp_last_timestamp[2];
+						}
+					}
+				} else
+					sdata->cdata->fifo_output[ST_MASK_ID_EXT0].deltatime = new_deltatime[ST_MASK_ID_EXT0];
+#endif /* CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT */
+			}
+
+			enable_irq(sdata->cdata->irq);
+		}
+
+		if (temp_v_odr[sdata->sindex] != 0)
+			sdata->cdata->v_odr[sdata->sindex] = temp_v_odr[sdata->sindex];
+
+		sdata->cdata->hw_odr[sdata->sindex] = temp_hw_odr[sdata->sindex];
+	} else {
+		/* no one is using FIFO */
+
+		disable_irq(sdata->cdata->irq);
+
+		if ((odr != 0) && (sdata->cdata->hw_odr[sdata->sindex] == st_lsm6dsm_odr_table.odr_avl[i].hz)) {
+			if (sdata->sindex == ST_MASK_ID_ACCEL) {
+				sdata->cdata->nofifo_decimation[ST_MASK_ID_ACCEL].decimator =
+					sdata->cdata->hw_odr[ST_MASK_ID_ACCEL] / sdata->cdata->v_odr[ST_MASK_ID_ACCEL];
+				sdata->cdata->nofifo_decimation[ST_MASK_ID_ACCEL].num_samples =
+					sdata->cdata->nofifo_decimation[ST_MASK_ID_ACCEL].decimator - 1;
+#ifdef CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT
+				sdata->cdata->nofifo_decimation[ST_MASK_ID_EXT0].decimator =
+					sdata->cdata->hw_odr[ST_MASK_ID_ACCEL] / sdata->cdata->v_odr[ST_MASK_ID_EXT0];
+				sdata->cdata->nofifo_decimation[ST_MASK_ID_EXT0].num_samples =
+					sdata->cdata->nofifo_decimation[ST_MASK_ID_EXT0].decimator - 1;
+#endif /* CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT */
+			}
+
+			enable_irq(sdata->cdata->irq);
+
+			return 0;
+		}
+
+		err = st_lsm6dsm_write_data_with_mask(sdata->cdata,
+				st_lsm6dsm_odr_table.addr[sdata->sindex],
+				st_lsm6dsm_odr_table.mask[sdata->sindex],
+				reg_value, true);
+		if (err < 0) {
+			enable_irq(sdata->cdata->irq);
+			return err;
+		}
+
+		if (!force)
+			sdata->cdata->v_odr[sdata->sindex] = st_lsm6dsm_odr_table.odr_avl[i].hz;
+
+		if (odr == 0)
+			sdata->cdata->hw_odr[sdata->sindex] = 0;
+		else
+			sdata->cdata->hw_odr[sdata->sindex] = st_lsm6dsm_odr_table.odr_avl[i].hz;
+
+		if (sdata->sindex == ST_MASK_ID_ACCEL) {
+			switch (sdata->cdata->hw_odr[sdata->sindex]) {
+			case 13:
+			case 26:
+			case 52:
+				sdata->cdata->samples_to_discard[ST_MASK_ID_ACCEL] = ST_LSM6DSM_ACCEL_STD_52HZ;
+				break;
+			case 104:
+				sdata->cdata->samples_to_discard[ST_MASK_ID_ACCEL] = ST_LSM6DSM_ACCEL_STD_104HZ;
+				break;
+			default:
+				sdata->cdata->samples_to_discard[ST_MASK_ID_ACCEL] = ST_LSM6DSM_ACCEL_STD_208HZ;
+				break;
+			}
+		}
+
+		switch (sdata->cdata->hw_odr[ST_MASK_ID_GYRO]) {
+		case 13:
+			sdata->cdata->samples_to_discard[ST_MASK_ID_GYRO] = ST_LSM6DSM_GYRO_STD_13HZ;
+			break;
+		case 26:
+		case 52:
+			sdata->cdata->samples_to_discard[ST_MASK_ID_GYRO] = ST_LSM6DSM_GYRO_STD_52HZ;
+			break;
+		case 104:
+			sdata->cdata->samples_to_discard[ST_MASK_ID_GYRO] = ST_LSM6DSM_GYRO_STD_104HZ;
+			break;
+		default:
+			sdata->cdata->samples_to_discard[ST_MASK_ID_GYRO] = ST_LSM6DSM_GYRO_STD_208HZ;
+			break;
+		}
+
+		if (sdata->sindex == ST_MASK_ID_ACCEL) {
+			if (sdata->cdata->hw_odr[sdata->sindex] > 0) {
+				sdata->cdata->nofifo_decimation[ST_MASK_ID_ACCEL].decimator =
+					sdata->cdata->hw_odr[ST_MASK_ID_ACCEL] / sdata->cdata->v_odr[ST_MASK_ID_ACCEL];
+#ifdef CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT
+				sdata->cdata->nofifo_decimation[ST_MASK_ID_EXT0].decimator =
+					sdata->cdata->hw_odr[ST_MASK_ID_ACCEL] / sdata->cdata->v_odr[ST_MASK_ID_EXT0];
+#endif /* CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT */
+			} else {
+				sdata->cdata->nofifo_decimation[ST_MASK_ID_ACCEL].decimator = 1;
+				sdata->cdata->nofifo_decimation[ST_MASK_ID_EXT0].decimator = 1;
+			}
+
+			sdata->cdata->nofifo_decimation[ST_MASK_ID_ACCEL].num_samples =
+				sdata->cdata->nofifo_decimation[ST_MASK_ID_ACCEL].decimator - 1;
+#ifdef CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT
+			sdata->cdata->nofifo_decimation[ST_MASK_ID_EXT0].num_samples =
+				sdata->cdata->nofifo_decimation[ST_MASK_ID_EXT0].decimator - 1;
+#endif /* CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT */
+		}
+
+		enable_irq(sdata->cdata->irq);
+	}
+
+	sdata->cdata->trigger_odr = sdata->cdata->hw_odr[0] > sdata->cdata->hw_odr[1] ? sdata->cdata->hw_odr[0] : sdata->cdata->hw_odr[1];
+
+	return 0;
+
+reenable_fifo_irq:
+	enable_irq(sdata->cdata->irq);
+	return err;
+}
+
+/*
+ * Enable / disable accelerometer
+ */
+static int lsm6dsm_enable_accel(struct lsm6dsm_data *cdata, enum st_mask_id id, int min_odr)
+{
+	int odr;
+	struct lsm6dsm_sensor_data *sdata_accel = iio_priv(cdata->indio_dev[ST_MASK_ID_ACCEL]);
+
+	switch (id) {
+	case ST_MASK_ID_ACCEL:
+		cdata->accel_odr_dependency[0] = min_odr;
+		if (min_odr > 0)
+			cdata->accel_on = true;
+		else
+			cdata->accel_on = false;
+
+		break;
+	case ST_MASK_ID_SENSOR_HUB:
+		cdata->accel_odr_dependency[1] = min_odr;
+		if (min_odr > 0)
+			cdata->magn_on = true;
+		else
+			cdata->magn_on = false;
+
+		break;
+	case ST_MASK_ID_DIGITAL_FUNC:
+		cdata->accel_odr_dependency[2] = min_odr;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (cdata->accel_odr_dependency[0] > cdata->accel_odr_dependency[1])
+		odr = cdata->accel_odr_dependency[0];
+	else
+		odr = cdata->accel_odr_dependency[1];
+
+	if (cdata->accel_odr_dependency[2] > odr)
+		odr = cdata->accel_odr_dependency[2];
+
+#ifdef CONFIG_ST_LSM6DSM_XL_DATA_INJECTION
+	if (cdata->injection_mode)
+		return 0;
+#endif /* CONFIG_ST_LSM6DSM_XL_DATA_INJECTION */
+
+	return st_lsm6dsm_set_odr(sdata_accel, odr, true);
+}
+
+/*
+ * Enable / disable digital func
+ */
+static int lsm6dsm_enable_digital_func(struct lsm6dsm_data *cdata,
+					bool enable, enum st_mask_id id)
+{
+	int err;
+
+	if (enable) {
+		if (cdata->enable_digfunc_mask == 0) {
+			err = lsm6dsm_enable_accel(cdata,
+						ST_MASK_ID_DIGITAL_FUNC, 26);
+			if (err < 0)
+				return err;
+
+			err = st_lsm6dsm_write_data_with_mask(cdata,
+						ST_LSM6DSM_FUNC_EN_ADDR,
+						ST_LSM6DSM_FUNC_EN_MASK,
+						ST_LSM6DSM_EN_BIT, true);
+			if (err < 0)
+				return err;
+		}
+		cdata->enable_digfunc_mask |= BIT(id);
+	} else {
+		if ((cdata->enable_digfunc_mask & ~BIT(id)) == 0) {
+			err = st_lsm6dsm_write_data_with_mask(cdata,
+						ST_LSM6DSM_FUNC_EN_ADDR,
+						ST_LSM6DSM_FUNC_EN_MASK,
+						ST_LSM6DSM_DIS_BIT, true);
+			if (err < 0)
+				return err;
+
+			err = lsm6dsm_enable_accel(cdata,
+						ST_MASK_ID_DIGITAL_FUNC, 0);
+			if (err < 0)
+				return err;
+		}
+		cdata->enable_digfunc_mask &= ~BIT(id);
+
+	}
+
+	return 0;
+}
+
+/*
+ * Enable / disable HW pedometer
+ */
+static int lsm6dsm_enable_pedometer(struct lsm6dsm_data *cdata,
+					bool enable, enum st_mask_id id)
+{
+	int err;
+
+	if (enable) {
+		if (cdata->enable_pedometer_mask == 0) {
+			err = st_lsm6dsm_write_data_with_mask(cdata,
+						ST_LSM6DSM_PEDOMETER_EN_ADDR,
+						ST_LSM6DSM_PEDOMETER_EN_MASK,
+						ST_LSM6DSM_EN_BIT, true);
+			if (err < 0)
+				return err;
+
+			err = lsm6dsm_enable_digital_func(cdata,
+						true, ST_MASK_ID_HW_PEDOMETER);
+			if (err < 0)
+				return err;
+		}
+		cdata->enable_pedometer_mask |= BIT(id);
+	} else {
+		if ((cdata->enable_pedometer_mask & ~BIT(id)) == 0) {
+			err = st_lsm6dsm_write_data_with_mask(cdata,
+						ST_LSM6DSM_PEDOMETER_EN_ADDR,
+						ST_LSM6DSM_PEDOMETER_EN_MASK,
+						ST_LSM6DSM_DIS_BIT, true);
+			if (err < 0)
+				return err;
+
+			err = lsm6dsm_enable_digital_func(cdata,
+						false, ST_MASK_ID_HW_PEDOMETER);
+			if (err < 0)
+				return err;
+		}
+		cdata->enable_pedometer_mask &= ~BIT(id);
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT
+int st_lsm6dsm_enable_sensor_hub(struct lsm6dsm_data *cdata,
+					bool enable, enum st_mask_id id)
+{
+	int err;
+
+	if (enable) {
+		if (cdata->enable_sensorhub_mask == 0) {
+			err = lsm6dsm_enable_digital_func(cdata,
+						true, ST_MASK_ID_SENSOR_HUB);
+			if (err < 0)
+				return err;
+
+			err = lsm6dsm_enable_accel(cdata, ST_MASK_ID_SENSOR_HUB,
+						cdata->v_odr[ST_MASK_ID_EXT0]);
+			if (err < 0)
+				return err;
+
+			err = st_lsm6dsm_write_data_with_mask(cdata,
+						ST_LSM6DSM_SENSORHUB_ADDR,
+						ST_LSM6DSM_SENSORHUB_MASK,
+						ST_LSM6DSM_EN_BIT, true);
+			if (err < 0)
+				return err;
+
+		} else
+			err = lsm6dsm_enable_accel(cdata, ST_MASK_ID_SENSOR_HUB,
+						cdata->v_odr[ST_MASK_ID_EXT0]);
+
+		cdata->enable_sensorhub_mask |= BIT(id);
+	} else {
+		if ((cdata->enable_sensorhub_mask & ~BIT(id)) == 0) {
+			err = st_lsm6dsm_write_data_with_mask(cdata,
+						ST_LSM6DSM_SENSORHUB_ADDR,
+						ST_LSM6DSM_SENSORHUB_MASK,
+						ST_LSM6DSM_DIS_BIT, true);
+			if (err < 0)
+				return err;
+
+			err = lsm6dsm_enable_accel(cdata,
+						ST_MASK_ID_SENSOR_HUB, 0);
+			if (err < 0)
+				return err;
+
+			err = lsm6dsm_enable_digital_func(cdata,
+						false, ST_MASK_ID_SENSOR_HUB);
+			if (err < 0)
+				return err;
+		} else
+			err = lsm6dsm_enable_accel(cdata, ST_MASK_ID_SENSOR_HUB,
+						cdata->v_odr[ST_MASK_ID_EXT0]);
+
+		cdata->enable_sensorhub_mask &= ~BIT(id);
+	}
+
+	return err < 0 ? err : 0;
+}
+#endif /* CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT */
+
+int st_lsm6dsm_set_enable(struct lsm6dsm_sensor_data *sdata, bool enable, bool buffer)
+{
+	int err;
+	u8 reg_value;
+
+	switch (sdata->sindex) {
+	case ST_MASK_ID_ACCEL:
+		err = lsm6dsm_enable_accel(sdata->cdata, ST_MASK_ID_ACCEL,
+			enable ? sdata->cdata->v_odr[ST_MASK_ID_ACCEL] : 0);
+		if (err < 0)
+			return 0;
+
+		break;
+	case ST_MASK_ID_GYRO:
+		err = st_lsm6dsm_set_odr(sdata, enable ?
+			sdata->cdata->v_odr[ST_MASK_ID_GYRO] : 0, true);
+		if (err < 0)
+			return err;
+
+		break;
+	case ST_MASK_ID_SIGN_MOTION:
+		if (enable)
+			reg_value = ST_LSM6DSM_EN_BIT;
+		else
+			reg_value = ST_LSM6DSM_DIS_BIT;
+
+		err = st_lsm6dsm_write_data_with_mask(sdata->cdata,
+					ST_LSM6DSM_SIGN_MOTION_EN_ADDR,
+					ST_LSM6DSM_SIGN_MOTION_EN_MASK,
+					reg_value, true);
+		if (err < 0)
+			return err;
+
+		err = lsm6dsm_enable_pedometer(sdata->cdata,
+						enable, ST_MASK_ID_SIGN_MOTION);
+		if (err < 0)
+			return err;
+
+		break;
+	case ST_MASK_ID_STEP_COUNTER:
+		if (enable)
+			reg_value = ST_LSM6DSM_EN_BIT;
+		else
+			reg_value = ST_LSM6DSM_DIS_BIT;
+
+		err = st_lsm6dsm_write_data_with_mask(sdata->cdata,
+					ST_LSM6DSM_TIMER_EN_ADDR,
+					ST_LSM6DSM_TIMER_EN_MASK,
+					reg_value, true);
+		if (err < 0)
+			return err;
+
+		err = lsm6dsm_enable_pedometer(sdata->cdata,
+					enable, ST_MASK_ID_STEP_COUNTER);
+		if (err < 0)
+			return err;
+
+		break;
+	case ST_MASK_ID_STEP_DETECTOR:
+		err = lsm6dsm_enable_pedometer(sdata->cdata,
+					enable, ST_MASK_ID_STEP_DETECTOR);
+		if (err < 0)
+			return err;
+
+		break;
+	case ST_MASK_ID_TILT:
+		if (enable)
+			reg_value = ST_LSM6DSM_EN_BIT;
+		else
+			reg_value = ST_LSM6DSM_DIS_BIT;
+
+		err = st_lsm6dsm_write_data_with_mask(sdata->cdata,
+					ST_LSM6DSM_TILT_EN_ADDR,
+					ST_LSM6DSM_TILT_EN_MASK,
+					reg_value, true);
+		if (err < 0)
+			return err;
+
+		err = lsm6dsm_enable_digital_func(sdata->cdata,
+						enable, ST_MASK_ID_TILT);
+		if (err < 0)
+			return err;
+
+		break;
+
+		if (err < 0)
+			return err;
+
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (buffer) {
+		err = st_lsm6dsm_set_drdy_irq(sdata, enable);
+		if (err < 0)
+			return err;
+
+		if (enable)
+			sdata->cdata->sensors_enabled |= BIT(sdata->sindex);
+		else
+			sdata->cdata->sensors_enabled &= ~BIT(sdata->sindex);
+	}
+
+	return 0;
+}
+
+static int st_lsm6dsm_set_fs(struct lsm6dsm_sensor_data *sdata,
+							unsigned int gain)
+{
+	int err, i;
+	u8 pedometer_reg_value;
+
+	for (i = 0; i < ST_LSM6DSM_FS_LIST_NUM; i++) {
+		if (st_lsm6dsm_fs_table[sdata->sindex].fs_avl[i].gain == gain)
+			break;
+	}
+	if (i == ST_LSM6DSM_FS_LIST_NUM)
+		return -EINVAL;
+
+	err = st_lsm6dsm_write_data_with_mask(sdata->cdata,
+			st_lsm6dsm_fs_table[sdata->sindex].addr,
+			st_lsm6dsm_fs_table[sdata->sindex].mask,
+			st_lsm6dsm_fs_table[sdata->sindex].fs_avl[i].value,
+			true);
+	if (err < 0)
+		return err;
+
+	sdata->c_gain[0] = gain;
+
+	if (sdata->sindex == ST_MASK_ID_ACCEL) {
+		if (i == 0)
+			pedometer_reg_value = ST_LSM6DSM_STEP_COUNTER_THS_2G_VALUE;
+		else
+			pedometer_reg_value = ST_LSM6DSM_STEP_COUNTER_THS_4G_VALUE;
+
+		st_lsm6dsm_write_embedded_registers(sdata->cdata,
+					ST_LSM6DSM_STEP_COUNTER_THS_ADDR,
+					&pedometer_reg_value, 1);
+	}
+
+	return 0;
+}
+
+static int st_lsm6dsm_read_raw(struct iio_dev *indio_dev,
+			struct iio_chan_spec const *ch, int *val,
+							int *val2, long mask)
+{
+	int err;
+	u8 outdata[ST_LSM6DSM_BYTE_FOR_CHANNEL];
+	struct lsm6dsm_sensor_data *sdata = iio_priv(indio_dev);
+
+	switch (mask) {
+	case IIO_CHAN_INFO_RAW:
+		mutex_lock(&indio_dev->mlock);
+
+		if (indio_dev->currentmode == INDIO_BUFFER_TRIGGERED) {
+			mutex_unlock(&indio_dev->mlock);
+			return -EBUSY;
+		}
+
+		mutex_lock(&sdata->cdata->odr_lock);
+
+		err = st_lsm6dsm_set_enable(sdata, true, false);
+		if (err < 0) {
+			mutex_unlock(&sdata->cdata->odr_lock);
+			mutex_unlock(&indio_dev->mlock);
+			return err;
+		}
+
+		if (sdata->sindex == ST_MASK_ID_ACCEL)
+			msleep(40);
+
+		if (sdata->sindex == ST_MASK_ID_GYRO)
+			msleep(120);
+
+		err = sdata->cdata->tf->read(sdata->cdata, ch->address,
+				ST_LSM6DSM_BYTE_FOR_CHANNEL, outdata, true);
+		if (err < 0) {
+			st_lsm6dsm_set_enable(sdata, false, false);
+			mutex_unlock(&sdata->cdata->odr_lock);
+			mutex_unlock(&indio_dev->mlock);
+			return err;
+		}
+
+		*val = (s16)get_unaligned_le16(outdata);
+		*val = *val >> ch->scan_type.shift;
+
+		st_lsm6dsm_set_enable(sdata, false, false);
+
+		mutex_unlock(&sdata->cdata->odr_lock);
+		mutex_unlock(&indio_dev->mlock);
+
+		return IIO_VAL_INT;
+	case IIO_CHAN_INFO_SCALE:
+		*val = 0;
+		*val2 = sdata->c_gain[0];
+		return IIO_VAL_INT_PLUS_MICRO;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int st_lsm6dsm_write_raw(struct iio_dev *indio_dev,
+		struct iio_chan_spec const *chan, int val, int val2, long mask)
+{
+	int err;
+	struct lsm6dsm_sensor_data *sdata = iio_priv(indio_dev);
+
+	switch (mask) {
+	case IIO_CHAN_INFO_SCALE:
+		mutex_lock(&indio_dev->mlock);
+
+		if (indio_dev->currentmode == INDIO_BUFFER_TRIGGERED) {
+			mutex_unlock(&indio_dev->mlock);
+			return -EBUSY;
+		}
+
+		err = st_lsm6dsm_set_fs(sdata, val2);
+		mutex_unlock(&indio_dev->mlock);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return err < 0 ? err : 0;
+}
+
+static int st_lsm6dsm_reset_steps(struct lsm6dsm_data *cdata)
+{
+	int err;
+	u8 reg_value = 0x00;
+
+	err = cdata->tf->read(cdata,
+			ST_LSM6DSM_STEP_COUNTER_RES_ADDR, 1, &reg_value, true);
+	if (err < 0)
+		return err;
+
+	if (reg_value & ST_LSM6DSM_FUNC_EN_MASK)
+		reg_value = ST_LSM6DSM_STEP_COUNTER_RES_FUNC_EN;
+	else
+		reg_value = ST_LSM6DSM_DIS_BIT;
+
+	err = st_lsm6dsm_write_data_with_mask(cdata,
+				ST_LSM6DSM_STEP_COUNTER_RES_ADDR,
+				ST_LSM6DSM_STEP_COUNTER_RES_MASK,
+				ST_LSM6DSM_STEP_COUNTER_RES_ALL_EN, true);
+	if (err < 0)
+		return err;
+
+	err = st_lsm6dsm_write_data_with_mask(cdata,
+				ST_LSM6DSM_STEP_COUNTER_RES_ADDR,
+				ST_LSM6DSM_STEP_COUNTER_RES_MASK,
+				reg_value, true);
+	if (err < 0)
+		return err;
+
+	cdata->reset_steps = true;
+
+	return 0;
+}
+
+static int st_lsm6dsm_init_sensor(struct lsm6dsm_data *cdata)
+{
+	int err;
+	u8 default_reg_value = ST_LSM6DSM_RESET_MASK;
+
+	err = cdata->tf->write(cdata, ST_LSM6DSM_RESET_ADDR, 1,
+					&default_reg_value, true);
+	if (err < 0)
+		return err;
+
+	msleep(200);
+
+	/* Latch interrupts */
+	err = st_lsm6dsm_write_data_with_mask(cdata, ST_LSM6DSM_LIR_ADDR,
+				ST_LSM6DSM_LIR_MASK, ST_LSM6DSM_EN_BIT, true);
+	if (err < 0)
+		return err;
+
+	/* Enable BDU for sensors data */
+	err = st_lsm6dsm_write_data_with_mask(cdata, ST_LSM6DSM_BDU_ADDR,
+				ST_LSM6DSM_BDU_MASK, ST_LSM6DSM_EN_BIT, true);
+	if (err < 0)
+		return err;
+
+	err = st_lsm6dsm_write_data_with_mask(cdata,
+					ST_LSM6DSM_ROUNDING_ADDR,
+					ST_LSM6DSM_ROUNDING_MASK,
+					ST_LSM6DSM_EN_BIT, true);
+	if (err < 0)
+		return err;
+
+	/* Redirect INT2 on INT1, all interrupt will be available on INT1 */
+	err = st_lsm6dsm_write_data_with_mask(cdata,
+					ST_LSM6DSM_INT2_ON_INT1_ADDR,
+					ST_LSM6DSM_INT2_ON_INT1_MASK,
+					ST_LSM6DSM_EN_BIT, true);
+	if (err < 0)
+		return err;
+
+	err = st_lsm6dsm_write_data_with_value(cdata, 0x58, 0x0e, ST_LSM6DSM_EN_BIT, true);
+	if (err < 0)
+		return err;
+
+	err = st_lsm6dsm_write_data_with_value(cdata, 0x59, 0x89, ST_LSM6DSM_EN_BIT, true);
+	if (err < 0)
+		return err;
+
+	err = st_lsm6dsm_write_data_with_value(cdata, 0x5a, 0x06, ST_LSM6DSM_EN_BIT, true);
+	if (err < 0)
+		return err;
+
+	err = st_lsm6dsm_write_data_with_value(cdata, 0x5b, 0x00, ST_LSM6DSM_EN_BIT, true);
+	if (err < 0)
+		return err;
+
+	err = st_lsm6dsm_write_data_with_value(cdata, 0x5e, 0x40, ST_LSM6DSM_EN_BIT, true);
+	if (err < 0)
+		return err;
+
+	err = st_lsm6dsm_reset_steps(cdata);
+	if (err < 0)
+		return err;
+
+	default_reg_value = 0x00;
+
+	err = st_lsm6dsm_write_embedded_registers(cdata,
+					ST_LSM6DSM_STEP_COUNTER_DURATION_ADDR,
+					&default_reg_value, 1);
+	if (err < 0)
+		return err;
+
+	default_reg_value = ST_LSM6DSM_STEP_COUNTER_THS_2G_VALUE;
+
+	err = st_lsm6dsm_write_embedded_registers(cdata,
+					ST_LSM6DSM_STEP_COUNTER_THS_ADDR,
+					&default_reg_value, 1);
+	if (err < 0)
+		return err;
+
+	return st_lsm6dsm_get_drdy_reg(cdata, &cdata->drdy_reg);
+}
+
+static int st_lsm6dsm_set_selftest(struct lsm6dsm_sensor_data *sdata, int index)
+{
+	u8 mode, mask;
+
+	switch (sdata->sindex) {
+	case ST_MASK_ID_ACCEL:
+		mask = ST_LSM6DSM_SELFTEST_ACCEL_MASK;
+		mode = st_lsm6dsm_selftest_table[index].accel_value;
+		break;
+	case ST_MASK_ID_GYRO:
+		mask = ST_LSM6DSM_SELFTEST_GYRO_MASK;
+		mode = st_lsm6dsm_selftest_table[index].gyro_value;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return st_lsm6dsm_write_data_with_mask(sdata->cdata,
+				ST_LSM6DSM_SELFTEST_ADDR, mask, mode, true);
+}
+
+static ssize_t st_lsm6dsm_sysfs_set_max_delivery_rate(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	u8 duration;
+	int err;
+	unsigned int max_delivery_rate;
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct lsm6dsm_sensor_data *sdata = iio_priv(indio_dev);
+
+	err = kstrtouint(buf, 10, &max_delivery_rate);
+	if (err < 0)
+		return -EINVAL;
+
+	if (max_delivery_rate == sdata->cdata->v_odr[ST_MASK_ID_STEP_COUNTER])
+		return size;
+
+	duration = max_delivery_rate / ST_LSM6DSM_MIN_DURATION_MS;
+
+	err = st_lsm6dsm_write_embedded_registers(sdata->cdata,
+					ST_LSM6DSM_STEP_COUNTER_DURATION_ADDR,
+					&duration, 1);
+	if (err < 0)
+		return err;
+
+	sdata->cdata->v_odr[ST_MASK_ID_STEP_COUNTER] = max_delivery_rate;
+
+	return size;
+}
+
+static ssize_t st_lsm6dsm_sysfs_get_max_delivery_rate(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct lsm6dsm_sensor_data *sdata = iio_priv(dev_get_drvdata(dev));
+
+	return sprintf(buf, "%d\n",
+				sdata->cdata->v_odr[ST_MASK_ID_STEP_COUNTER]);
+}
+
+static ssize_t st_lsm6dsm_sysfs_reset_counter(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	int err;
+	struct lsm6dsm_sensor_data *sdata = iio_priv(dev_get_drvdata(dev));
+
+	err = st_lsm6dsm_reset_steps(sdata->cdata);
+	if (err < 0)
+		return err;
+
+	return size;
+}
+
+static ssize_t st_lsm6dsm_sysfs_get_sampling_frequency(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct lsm6dsm_sensor_data *sdata = iio_priv(dev_get_drvdata(dev));
+
+	return sprintf(buf, "%d\n", sdata->cdata->v_odr[sdata->sindex]);
+}
+
+static ssize_t st_lsm6dsm_sysfs_set_sampling_frequency(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	int err;
+	unsigned int odr;
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct lsm6dsm_sensor_data *sdata = iio_priv(indio_dev);
+
+	err = kstrtoint(buf, 10, &odr);
+	if (err < 0)
+		return err;
+	mutex_lock(&indio_dev->mlock);
+
+	mutex_lock(&sdata->cdata->odr_lock);
+#ifdef CONFIG_ST_LSM6DSM_XL_DATA_INJECTION
+	if (!((sdata->sindex & ST_MASK_ID_ACCEL) &&
+					sdata->cdata->injection_mode)) {
+		if (sdata->cdata->v_odr[sdata->sindex] != odr)
+			err = st_lsm6dsm_set_odr(sdata, odr, false);
+	}
+#else /* CONFIG_ST_LSM6DSM_XL_DATA_INJECTION */
+	if (sdata->cdata->v_odr[sdata->sindex] != odr) {
+		if ((sdata->sindex == ST_MASK_ID_ACCEL) && (sdata->cdata->sensors_enabled & BIT(ST_MASK_ID_ACCEL))){
+			err = lsm6dsm_enable_accel(sdata->cdata, ST_MASK_ID_ACCEL, odr);
+		}else{
+			err = st_lsm6dsm_set_odr(sdata, odr, false);
+		}
+	}
+#endif /* CONFIG_ST_LSM6DSM_XL_DATA_INJECTION */
+	mutex_unlock(&sdata->cdata->odr_lock);
+
+	mutex_unlock(&indio_dev->mlock);
+
+	return err < 0 ? err : size;
+}
+
+static ssize_t st_lsm6dsm_sysfs_sampling_frequency_avail(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	int i, len = 0;
+
+	for (i = 0; i < ST_LSM6DSM_ODR_LIST_NUM; i++) {
+		len += scnprintf(buf + len, PAGE_SIZE - len, "%d ",
+					st_lsm6dsm_odr_table.odr_avl[i].hz);
+	}
+	buf[len - 1] = '\n';
+
+	return len;
+}
+
+static ssize_t st_lsm6dsm_sysfs_scale_avail(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	int i, len = 0;
+	struct lsm6dsm_sensor_data *sdata = iio_priv(dev_get_drvdata(dev));
+
+	for (i = 0; i < ST_LSM6DSM_FS_LIST_NUM; i++) {
+		len += scnprintf(buf + len, PAGE_SIZE - len, "0.%06u ",
+			st_lsm6dsm_fs_table[sdata->sindex].fs_avl[i].gain);
+	}
+	buf[len - 1] = '\n';
+
+	return len;
+}
+
+static ssize_t st_lsm6dsm_sysfs_get_selftest_available(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%s, %s\n",
+				st_lsm6dsm_selftest_table[1].string_mode,
+				st_lsm6dsm_selftest_table[2].string_mode);
+}
+
+static ssize_t st_lsm6dsm_sysfs_get_selftest_status(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	int8_t result;
+	char *message;
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct lsm6dsm_sensor_data *sdata = iio_priv(indio_dev);
+
+	mutex_lock(&sdata->cdata->odr_lock);
+
+	switch (sdata->sindex) {
+	case ST_MASK_ID_ACCEL:
+		result = sdata->cdata->accel_selftest_status;
+		break;
+	case ST_MASK_ID_GYRO:
+		result = sdata->cdata->gyro_selftest_status;
+		break;
+	default:
+		mutex_unlock(&sdata->cdata->odr_lock);
+		return -EINVAL;
+	}
+
+	mutex_unlock(&sdata->cdata->odr_lock);
+
+	if (result == 0)
+		message = ST_LSM6DSM_SELFTEST_NA_MS;
+	else if (result < 0)
+		message = ST_LSM6DSM_SELFTEST_FAIL_MS;
+	else if (result > 0)
+		message = ST_LSM6DSM_SELFTEST_PASS_MS;
+
+	return sprintf(buf, "%s\n", message);
+}
+
+static ssize_t st_lsm6dsm_sysfs_start_selftest_status(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	int err, i, n;
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct lsm6dsm_sensor_data *sdata = iio_priv(indio_dev);
+	u8 reg_status, reg_addr, temp_reg_status, outdata[6];
+	int x = 0, y = 0, z = 0, x_selftest = 0, y_selftest = 0, z_selftest = 0;
+
+	mutex_lock(&sdata->cdata->odr_lock);
+
+	switch (sdata->sindex) {
+	case ST_MASK_ID_ACCEL:
+		sdata->cdata->accel_selftest_status = 0;
+		break;
+	case ST_MASK_ID_GYRO:
+		sdata->cdata->gyro_selftest_status = 0;
+		break;
+	default:
+		mutex_unlock(&sdata->cdata->odr_lock);
+		mutex_unlock(&indio_dev->mlock);
+		return -EINVAL;
+	}
+
+	if (sdata->cdata->sensors_enabled > 0) {
+		mutex_unlock(&sdata->cdata->odr_lock);
+		return -EBUSY;
+	}
+
+	for (n = 0; n < ARRAY_SIZE(st_lsm6dsm_selftest_table); n++) {
+		if (strncmp(buf, st_lsm6dsm_selftest_table[n].string_mode,
+								size - 2) == 0)
+			break;
+	}
+	if (n == ARRAY_SIZE(st_lsm6dsm_selftest_table)) {
+		mutex_unlock(&sdata->cdata->odr_lock);
+		return -EINVAL;
+	}
+
+	switch (sdata->sindex) {
+	case ST_MASK_ID_ACCEL:
+		reg_addr = ST_LSM6DSM_SELFTEST_ACCEL_ADDR;
+		temp_reg_status = ST_LSM6DSM_SELFTEST_ACCEL_REG_VALUE;
+		break;
+	case ST_MASK_ID_GYRO:
+		reg_addr = ST_LSM6DSM_SELFTEST_GYRO_ADDR;
+		temp_reg_status = ST_LSM6DSM_SELFTEST_GYRO_REG_VALUE;
+		break;
+	default:
+		mutex_unlock(&sdata->cdata->odr_lock);
+		return -EINVAL;
+	}
+
+	err = sdata->cdata->tf->read(sdata->cdata,
+					reg_addr, 1, &reg_status, true);
+	if (err < 0) {
+		mutex_unlock(&sdata->cdata->odr_lock);
+		return err;
+	}
+
+	err = sdata->cdata->tf->write(sdata->cdata,
+					reg_addr, 1, &temp_reg_status, false);
+	if (err < 0) {
+		mutex_unlock(&sdata->cdata->odr_lock);
+		return err;
+	}
+
+	/* get data with selftest disabled */
+	msleep(100);
+
+	for (i = 0; i < 20; i++) {
+		err = sdata->cdata->tf->read(sdata->cdata,
+					sdata->data_out_reg, 6, outdata, true);
+		if (err < 0) {
+			i--;
+			continue;
+		}
+
+		x += ((s16)*(u16 *)&outdata[0]) / 20;
+		y += ((s16)*(u16 *)&outdata[2]) / 20;
+		z += ((s16)*(u16 *)&outdata[4]) / 20;
+
+		mdelay(10);
+	}
+
+	err = st_lsm6dsm_set_selftest(sdata, n);
+	if (err < 0) {
+		mutex_unlock(&sdata->cdata->odr_lock);
+		return err;
+	}
+
+	/* get data with selftest enabled */
+	msleep(100);
+
+	for (i = 0; i < 20; i++) {
+		err = sdata->cdata->tf->read(sdata->cdata,
+					sdata->data_out_reg, 6, outdata, true);
+		if (err < 0) {
+			i--;
+			continue;
+		}
+
+		x_selftest += ((s16)*(u16 *)&outdata[0]) / 20;
+		y_selftest += ((s16)*(u16 *)&outdata[2]) / 20;
+		z_selftest += ((s16)*(u16 *)&outdata[4]) / 20;
+
+		mdelay(10);
+	}
+
+	err = sdata->cdata->tf->write(sdata->cdata,
+					reg_addr, 1, &reg_status, false);
+	if (err < 0) {
+		mutex_unlock(&sdata->cdata->odr_lock);
+		return err;
+	}
+
+	err = st_lsm6dsm_set_selftest(sdata, 0);
+	if (err < 0) {
+		mutex_unlock(&sdata->cdata->odr_lock);
+		return err;
+	}
+
+	switch (sdata->sindex) {
+	case ST_MASK_ID_ACCEL:
+		if ((abs(x_selftest - x) < ST_LSM6DSM_SELFTEST_ACCEL_MIN) ||
+				(abs(x_selftest - x) > ST_LSM6DSM_SELFTEST_ACCEL_MAX)) {
+			sdata->cdata->accel_selftest_status = -1;
+			goto selftest_failure;
+		}
+
+		if ((abs(y_selftest - y) < ST_LSM6DSM_SELFTEST_ACCEL_MIN) ||
+				(abs(y_selftest - y) > ST_LSM6DSM_SELFTEST_ACCEL_MAX)) {
+			sdata->cdata->accel_selftest_status = -1;
+			goto selftest_failure;
+		}
+
+		if ((abs(z_selftest - z) < ST_LSM6DSM_SELFTEST_ACCEL_MIN) ||
+				(abs(z_selftest - z) > ST_LSM6DSM_SELFTEST_ACCEL_MAX)) {
+			sdata->cdata->accel_selftest_status = -1;
+			goto selftest_failure;
+		}
+
+		sdata->cdata->accel_selftest_status = 1;
+		break;
+	case ST_MASK_ID_GYRO:
+		if ((abs(x_selftest - x) < ST_LSM6DSM_SELFTEST_GYRO_MIN) ||
+				(abs(x_selftest - x) > ST_LSM6DSM_SELFTEST_GYRO_MAX)) {
+			sdata->cdata->gyro_selftest_status = -1;
+			goto selftest_failure;
+		}
+
+		if ((abs(y_selftest - y) < ST_LSM6DSM_SELFTEST_GYRO_MIN) ||
+				(abs(y_selftest - y) > ST_LSM6DSM_SELFTEST_GYRO_MAX)) {
+			sdata->cdata->gyro_selftest_status = -1;
+			goto selftest_failure;
+		}
+
+		if ((abs(z_selftest - z) < ST_LSM6DSM_SELFTEST_GYRO_MIN) ||
+				(abs(z_selftest - z) > ST_LSM6DSM_SELFTEST_GYRO_MAX)) {
+			sdata->cdata->gyro_selftest_status = -1;
+			goto selftest_failure;
+		}
+
+		sdata->cdata->gyro_selftest_status = 1;
+		break;
+	default:
+		mutex_unlock(&sdata->cdata->odr_lock);
+		return -EINVAL;
+	}
+
+selftest_failure:
+	mutex_unlock(&sdata->cdata->odr_lock);
+
+	return size;
+}
+
+ssize_t st_lsm6dsm_sysfs_flush_fifo(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	u64 sensor_last_timestamp, event_type = 0;
+	int stype = 0;
+	u64 timestamp_flush = 0;
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct lsm6dsm_sensor_data *sdata = iio_priv(indio_dev);
+
+	mutex_lock(&indio_dev->mlock);
+
+	if (indio_dev->currentmode == INDIO_BUFFER_TRIGGERED) {
+		mutex_lock(&sdata->cdata->odr_lock);
+		disable_irq(sdata->cdata->irq);
+	} else {
+		mutex_unlock(&indio_dev->mlock);
+		return -EINVAL;
+	}
+
+	sensor_last_timestamp =
+			sdata->cdata->fifo_output[sdata->sindex].timestamp_p;
+
+	st_lsm6dsm_read_fifo(sdata->cdata, true);
+
+	if (sensor_last_timestamp ==
+			sdata->cdata->fifo_output[sdata->sindex].timestamp_p)
+		event_type = IIO_EV_DIR_FIFO_EMPTY;
+	else
+		event_type = IIO_EV_DIR_FIFO_DATA;
+
+	timestamp_flush = sdata->cdata->fifo_output[sdata->sindex].timestamp_p;
+
+	enable_irq(sdata->cdata->irq);
+
+	switch (sdata->sindex) {
+	case ST_MASK_ID_ACCEL:
+		stype = IIO_ACCEL;
+		break;
+
+	case ST_MASK_ID_GYRO:
+		stype = IIO_ANGL_VEL;
+		break;
+
+#ifdef CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT
+	case ST_MASK_ID_EXT0:
+		stype = IIO_MAGN;
+		break;
+#endif /* CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT */
+
+	}
+
+	iio_push_event(indio_dev, IIO_UNMOD_EVENT_CODE(stype,
+				-1, IIO_EV_TYPE_FIFO_FLUSH, event_type),
+				timestamp_flush);
+
+	mutex_unlock(&sdata->cdata->odr_lock);
+	mutex_unlock(&indio_dev->mlock);
+
+	return size;
+}
+
+ssize_t st_lsm6dsm_sysfs_get_hwfifo_enabled(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct lsm6dsm_sensor_data *sdata = iio_priv(indio_dev);
+
+	return sprintf(buf, "%d\n",
+				sdata->cdata->hwfifo_enabled[sdata->sindex]);
+}
+
+ssize_t st_lsm6dsm_sysfs_set_hwfifo_enabled(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	int err;
+	bool enable = false;
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct lsm6dsm_sensor_data *sdata = iio_priv(indio_dev);
+
+	mutex_lock(&indio_dev->mlock);
+	if (indio_dev->currentmode == INDIO_BUFFER_TRIGGERED) {
+		err = -EBUSY;
+		goto set_hwfifo_enabled_unlock_mutex;
+	}
+
+	err = strtobool(buf, &enable);
+	if (err < 0)
+		goto set_hwfifo_enabled_unlock_mutex;
+
+	mutex_lock(&sdata->cdata->odr_lock);
+
+	sdata->cdata->hwfifo_enabled[sdata->sindex] = enable;
+
+	if (enable)
+		sdata->cdata->sensors_use_fifo |= BIT(sdata->sindex);
+	else
+		sdata->cdata->sensors_use_fifo &= ~BIT(sdata->sindex);
+
+	mutex_unlock(&sdata->cdata->odr_lock);
+	mutex_unlock(&indio_dev->mlock);
+
+	return size;
+
+set_hwfifo_enabled_unlock_mutex:
+	mutex_unlock(&indio_dev->mlock);
+	return err;
+}
+
+ssize_t st_lsm6dsm_sysfs_get_hwfifo_watermark(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct lsm6dsm_sensor_data *sdata = iio_priv(indio_dev);
+
+	return sprintf(buf, "%d\n",
+				sdata->cdata->hwfifo_watermark[sdata->sindex]);
+}
+
+ssize_t st_lsm6dsm_sysfs_set_hwfifo_watermark(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	int err = 0, watermark = 0, old_watermark;
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct lsm6dsm_sensor_data *sdata = iio_priv(indio_dev);
+
+	err = kstrtoint(buf, 10, &watermark);
+	if (err < 0)
+		return err;
+
+	if ((watermark < 1) || (watermark > ST_LSM6DSM_MAX_FIFO_LENGHT))
+		return -EINVAL;
+
+	mutex_lock(&sdata->cdata->odr_lock);
+
+	if ((sdata->cdata->sensors_enabled & BIT(sdata->sindex)) &&
+				(sdata->cdata->sensors_use_fifo & BIT(sdata->sindex))) {
+		disable_irq(sdata->cdata->irq);
+
+		if (sdata->cdata->fifo_status != BYPASS)
+			st_lsm6dsm_read_fifo(sdata->cdata, true);
+
+		old_watermark = sdata->cdata->hwfifo_watermark[sdata->sindex];
+		sdata->cdata->hwfifo_watermark[sdata->sindex] = watermark;
+
+		err = lsm6dsm_set_watermark(sdata->cdata);
+		if (err < 0)
+			sdata->cdata->hwfifo_watermark[sdata->sindex] = old_watermark;
+
+		enable_irq(sdata->cdata->irq);
+	} else
+		sdata->cdata->hwfifo_watermark[sdata->sindex] = watermark;
+
+	mutex_unlock(&sdata->cdata->odr_lock);
+
+	return err < 0 ? err : size;
+}
+
+ssize_t st_lsm6dsm_sysfs_get_hwfifo_watermark_max(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", ST_LSM6DSM_MAX_FIFO_LENGHT);
+}
+
+ssize_t st_lsm6dsm_sysfs_get_hwfifo_watermark_min(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", 1);
+}
+
+#ifdef CONFIG_ST_LSM6DSM_XL_DATA_INJECTION
+static ssize_t st_lsm6dsm_sysfs_set_injection_mode(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	int err, start;
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct lsm6dsm_sensor_data *sdata = iio_priv(indio_dev);
+
+	mutex_lock(&indio_dev->mlock);
+
+	if (indio_dev->currentmode == INDIO_BUFFER_TRIGGERED) {
+		mutex_unlock(&indio_dev->mlock);
+		return -EBUSY;
+	}
+
+	err = kstrtoint(buf, 10, &start);
+	if (err < 0) {
+		mutex_unlock(&indio_dev->mlock);
+		return err;
+	}
+
+	mutex_lock(&sdata->cdata->odr_lock);
+
+	if (start == 0) {
+		/* End injection */
+		err = st_lsm6dsm_write_data_with_mask(sdata->cdata,
+				ST_LSM6DSM_TEST_REG_ADDR,
+				ST_LSM6DSM_START_INJECT_XL_MASK, 0, true);
+		if (err < 0) {
+			mutex_unlock(&sdata->cdata->odr_lock);
+			mutex_unlock(&indio_dev->mlock);
+			return err;
+		}
+
+		 /* Force accel ODR to 26Hz if dependencies are enabled */
+		 if (sdata->cdata->sensors_enabled > 0) {
+			err = st_lsm6dsm_write_data_with_mask(sdata->cdata,
+				st_lsm6dsm_odr_table.addr[sdata->sindex],
+				st_lsm6dsm_odr_table.mask[sdata->sindex],
+				st_lsm6dsm_odr_table.odr_avl[1].value, true);
+			if (err < 0) {
+				mutex_unlock(&sdata->cdata->odr_lock);
+				mutex_unlock(&indio_dev->mlock);
+				return err;
+			}
+		}
+
+		sdata->cdata->injection_mode = false;
+	} else {
+		sdata->cdata->last_injection_timestamp = 0;
+		sdata->cdata->injection_odr = 0;
+
+		/* Set start injection */
+		err = st_lsm6dsm_write_data_with_mask(sdata->cdata,
+				ST_LSM6DSM_TEST_REG_ADDR,
+				ST_LSM6DSM_START_INJECT_XL_MASK, 1, true);
+		if (err < 0) {
+			mutex_unlock(&sdata->cdata->odr_lock);
+			mutex_unlock(&indio_dev->mlock);
+			return err;
+		}
+
+		sdata->cdata->injection_mode = true;
+	}
+
+	mutex_unlock(&sdata->cdata->odr_lock);
+	mutex_unlock(&indio_dev->mlock);
+
+	return size;
+}
+
+static ssize_t st_lsm6dsm_sysfs_get_injection_mode(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct lsm6dsm_sensor_data *sdata = iio_priv(indio_dev);
+
+	return sprintf(buf, "%d\n", sdata->cdata->injection_mode);
+}
+
+static ssize_t st_lsm6dsm_sysfs_upload_xl_data(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	int err, i, n = 1;
+	s64 timestamp, deltatime;
+	u8 sample[3], current_odr;
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct lsm6dsm_sensor_data *sdata = iio_priv(indio_dev);
+
+	mutex_lock(&indio_dev->mlock);
+
+	if (!sdata->cdata->injection_mode) {
+		mutex_unlock(&indio_dev->mlock);
+		return -EINVAL;
+	}
+
+	for (i = 0; i < 3; i++)
+		sample[i] = *(s16 *)(&buf[i * 2]) >> 8;
+
+	timestamp = *(s64 *)(buf + ALIGN(6, sizeof(s64)));
+
+	if (sdata->cdata->last_injection_timestamp > 0) {
+		deltatime = timestamp - sdata->cdata->last_injection_timestamp;
+		if ((deltatime > ST_LSM6DSM_208HZ_INJECT_NS_DOWN) &&
+				(deltatime <= ST_LSM6DSM_208HZ_INJECT_NS_UP)) {
+			current_odr = 208;
+			n = 4;
+		} else if ((deltatime > ST_LSM6DSM_104HZ_INJECT_NS_DOWN) &&
+				(deltatime <= ST_LSM6DSM_104HZ_INJECT_NS_UP)) {
+			current_odr = 104;
+			n = 3;
+		} else if ((deltatime > ST_LSM6DSM_52HZ_INJECT_NS_DOWN) &&
+				(deltatime <= ST_LSM6DSM_52HZ_INJECT_NS_UP)) {
+			current_odr = 52;
+			n = 2;
+		} else if ((deltatime > ST_LSM6DSM_26HZ_INJECT_NS_DOWN) &&
+				(deltatime <= ST_LSM6DSM_26HZ_INJECT_NS_UP)) {
+			current_odr = 26;
+			n = 1;
+		} else {
+			mutex_unlock(&indio_dev->mlock);
+			return -EINVAL;
+		}
+
+		if (sdata->cdata->injection_odr != current_odr) {
+			err = st_lsm6dsm_write_data_with_mask(sdata->cdata,
+				st_lsm6dsm_odr_table.addr[sdata->sindex],
+				st_lsm6dsm_odr_table.mask[sdata->sindex],
+				st_lsm6dsm_odr_table.odr_avl[n].value, true);
+			if (err < 0) {
+				mutex_unlock(&indio_dev->mlock);
+				return err;
+			}
+
+			sdata->cdata->injection_odr = current_odr;
+		}
+	}
+
+	sdata->cdata->last_injection_timestamp = timestamp;
+
+	err = sdata->cdata->tf->write(sdata->cdata, ST_LSM6DSM_INJECT_XL_X_ADDR,
+					3, (u8 *)sample, false);
+	if (err < 0) {
+		mutex_unlock(&indio_dev->mlock);
+		return err;
+	}
+
+	mutex_unlock(&indio_dev->mlock);
+
+	usleep_range(1000, 2000);
+
+	return size;
+}
+
+static ssize_t st_lsm6dsm_sysfs_get_injection_sensors(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%s\n", "lsm6dsm_accel");
+}
+#endif /* CONFIG_ST_LSM6DSM_XL_DATA_INJECTION */
+
+static ST_LSM6DSM_DEV_ATTR_SAMP_FREQ();
+static ST_LSM6DSM_DEV_ATTR_SAMP_FREQ_AVAIL();
+static ST_LSM6DSM_DEV_ATTR_SCALE_AVAIL(in_accel_scale_available);
+static ST_LSM6DSM_DEV_ATTR_SCALE_AVAIL(in_anglvel_scale_available);
+
+static ST_LSM6DSM_HWFIFO_ENABLED();
+static ST_LSM6DSM_HWFIFO_WATERMARK();
+static ST_LSM6DSM_HWFIFO_WATERMARK_MIN();
+static ST_LSM6DSM_HWFIFO_WATERMARK_MAX();
+static ST_LSM6DSM_HWFIFO_FLUSH();
+
+static IIO_DEVICE_ATTR(reset_counter, S_IWUSR,
+				NULL, st_lsm6dsm_sysfs_reset_counter, 0);
+
+static IIO_DEVICE_ATTR(max_delivery_rate, S_IWUSR | S_IRUGO,
+				st_lsm6dsm_sysfs_get_max_delivery_rate,
+				st_lsm6dsm_sysfs_set_max_delivery_rate, 0);
+
+static IIO_DEVICE_ATTR(selftest_available, S_IRUGO,
+				st_lsm6dsm_sysfs_get_selftest_available,
+				NULL, 0);
+
+static IIO_DEVICE_ATTR(selftest, S_IWUSR | S_IRUGO,
+				st_lsm6dsm_sysfs_get_selftest_status,
+				st_lsm6dsm_sysfs_start_selftest_status, 0);
+
+#ifdef CONFIG_ST_LSM6DSM_XL_DATA_INJECTION
+static IIO_DEVICE_ATTR(injection_mode, S_IWUSR | S_IRUGO,
+				st_lsm6dsm_sysfs_get_injection_mode,
+				st_lsm6dsm_sysfs_set_injection_mode, 0);
+
+static IIO_DEVICE_ATTR(in_accel_injection_raw, S_IWUSR, NULL,
+				st_lsm6dsm_sysfs_upload_xl_data, 0);
+
+static IIO_DEVICE_ATTR(injection_sensors, S_IRUGO,
+				st_lsm6dsm_sysfs_get_injection_sensors,
+				NULL, 0);
+#endif /* CONFIG_ST_LSM6DSM_XL_DATA_INJECTION */
+
+static struct attribute *st_lsm6dsm_accel_attributes[] = {
+	&iio_dev_attr_sampling_frequency_available.dev_attr.attr,
+	&iio_dev_attr_in_accel_scale_available.dev_attr.attr,
+	&iio_dev_attr_sampling_frequency.dev_attr.attr,
+	&iio_dev_attr_selftest_available.dev_attr.attr,
+	&iio_dev_attr_selftest.dev_attr.attr,
+	&iio_dev_attr_hwfifo_enabled.dev_attr.attr,
+	&iio_dev_attr_hwfifo_watermark.dev_attr.attr,
+	&iio_dev_attr_hwfifo_watermark_min.dev_attr.attr,
+	&iio_dev_attr_hwfifo_watermark_max.dev_attr.attr,
+	&iio_dev_attr_hwfifo_flush.dev_attr.attr,
+#ifdef CONFIG_ST_LSM6DSM_XL_DATA_INJECTION
+	&iio_dev_attr_injection_mode.dev_attr.attr,
+	&iio_dev_attr_in_accel_injection_raw.dev_attr.attr,
+#endif /* CONFIG_ST_LSM6DSM_XL_DATA_INJECTION */
+	NULL,
+};
+
+static const struct attribute_group st_lsm6dsm_accel_attribute_group = {
+	.attrs = st_lsm6dsm_accel_attributes,
+};
+
+static const struct iio_info st_lsm6dsm_accel_info = {
+	.attrs = &st_lsm6dsm_accel_attribute_group,
+	.read_raw = &st_lsm6dsm_read_raw,
+	.write_raw = &st_lsm6dsm_write_raw,
+};
+
+static struct attribute *st_lsm6dsm_gyro_attributes[] = {
+	&iio_dev_attr_sampling_frequency_available.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_scale_available.dev_attr.attr,
+	&iio_dev_attr_sampling_frequency.dev_attr.attr,
+	&iio_dev_attr_selftest_available.dev_attr.attr,
+	&iio_dev_attr_selftest.dev_attr.attr,
+	&iio_dev_attr_hwfifo_enabled.dev_attr.attr,
+	&iio_dev_attr_hwfifo_watermark.dev_attr.attr,
+	&iio_dev_attr_hwfifo_watermark_min.dev_attr.attr,
+	&iio_dev_attr_hwfifo_watermark_max.dev_attr.attr,
+	&iio_dev_attr_hwfifo_flush.dev_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group st_lsm6dsm_gyro_attribute_group = {
+	.attrs = st_lsm6dsm_gyro_attributes,
+};
+
+static const struct iio_info st_lsm6dsm_gyro_info = {
+	.attrs = &st_lsm6dsm_gyro_attribute_group,
+	.read_raw = &st_lsm6dsm_read_raw,
+	.write_raw = &st_lsm6dsm_write_raw,
+};
+
+static struct attribute *st_lsm6dsm_sign_motion_attributes[] = {
+#ifdef CONFIG_ST_LSM6DSM_XL_DATA_INJECTION
+	&iio_dev_attr_injection_sensors.dev_attr.attr,
+#endif /* CONFIG_ST_LSM6DSM_XL_DATA_INJECTION */
+	NULL,
+};
+
+static const struct attribute_group st_lsm6dsm_sign_motion_attribute_group = {
+	.attrs = st_lsm6dsm_sign_motion_attributes,
+};
+
+static const struct iio_info st_lsm6dsm_sign_motion_info = {
+	.attrs = &st_lsm6dsm_sign_motion_attribute_group,
+};
+
+static struct attribute *st_lsm6dsm_step_c_attributes[] = {
+	&iio_dev_attr_reset_counter.dev_attr.attr,
+	&iio_dev_attr_max_delivery_rate.dev_attr.attr,
+#ifdef CONFIG_ST_LSM6DSM_XL_DATA_INJECTION
+	&iio_dev_attr_injection_sensors.dev_attr.attr,
+#endif /* CONFIG_ST_LSM6DSM_XL_DATA_INJECTION */
+	NULL,
+};
+
+static const struct attribute_group st_lsm6dsm_step_c_attribute_group = {
+	.attrs = st_lsm6dsm_step_c_attributes,
+};
+
+static const struct iio_info st_lsm6dsm_step_c_info = {
+	.attrs = &st_lsm6dsm_step_c_attribute_group,
+	.read_raw = &st_lsm6dsm_read_raw,
+};
+
+static struct attribute *st_lsm6dsm_step_d_attributes[] = {
+#ifdef CONFIG_ST_LSM6DSM_XL_DATA_INJECTION
+	&iio_dev_attr_injection_sensors.dev_attr.attr,
+#endif /* CONFIG_ST_LSM6DSM_XL_DATA_INJECTION */
+	NULL,
+};
+
+static const struct attribute_group st_lsm6dsm_step_d_attribute_group = {
+	.attrs = st_lsm6dsm_step_d_attributes,
+};
+
+static const struct iio_info st_lsm6dsm_step_d_info = {
+	.attrs = &st_lsm6dsm_step_d_attribute_group,
+};
+
+static struct attribute *st_lsm6dsm_tilt_attributes[] = {
+#ifdef CONFIG_ST_LSM6DSM_XL_DATA_INJECTION
+	&iio_dev_attr_injection_sensors.dev_attr.attr,
+#endif /* CONFIG_ST_LSM6DSM_XL_DATA_INJECTION */
+	NULL,
+};
+
+static const struct attribute_group st_lsm6dsm_tilt_attribute_group = {
+	.attrs = st_lsm6dsm_tilt_attributes,
+};
+
+static const struct iio_info st_lsm6dsm_tilt_info = {
+	.attrs = &st_lsm6dsm_tilt_attribute_group,
+};
+
+#ifdef CONFIG_IIO_TRIGGER
+static const struct iio_trigger_ops st_lsm6dsm_trigger_ops = {
+	.set_trigger_state = ST_LSM6DSM_TRIGGER_SET_STATE,
+};
+#define ST_LSM6DSM_TRIGGER_OPS (&st_lsm6dsm_trigger_ops)
+#else
+#define ST_LSM6DSM_TRIGGER_OPS NULL
+#endif
+
+int st_lsm6dsm_common_probe(struct lsm6dsm_data *cdata, int irq)
+{
+	u8 wai = 0x00;
+	int i, n, err;
+	struct lsm6dsm_sensor_data *sdata;
+
+	mutex_init(&cdata->bank_registers_lock);
+	mutex_init(&cdata->fifo_lock);
+	mutex_init(&cdata->tb.buf_lock);
+	mutex_init(&cdata->odr_lock);
+
+	cdata->fifo_watermark = 0;
+	cdata->fifo_status = BYPASS;
+	cdata->enable_digfunc_mask = 0;
+	cdata->enable_pedometer_mask = 0;
+#ifdef CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT
+	cdata->enable_sensorhub_mask = 0;
+#endif /* CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT */
+
+	cdata->irq_enable_fifo_mask = 0;
+	cdata->irq_enable_accel_ext_mask = 0;
+
+	for (i = 0; i < ST_INDIO_DEV_NUM + 1; i++) {
+		cdata->hw_odr[i] = 0;
+		cdata->v_odr[i] = 0;
+		cdata->hwfifo_enabled[i] = false;
+		cdata->hwfifo_decimator[i] = 0;
+		cdata->hwfifo_watermark[i] = 1;
+		cdata->nofifo_decimation[i].decimator = 1;
+		cdata->nofifo_decimation[i].num_samples = 0;
+		cdata->fifo_output[i].sip = 0;
+		cdata->fifo_output[i].decimator = 1;
+		cdata->fifo_output[i].timestamp_p = 0;
+		cdata->fifo_output[i].sip = 0;
+		cdata->fifo_output[i].initialized = false;
+	}
+
+	cdata->sensors_use_fifo = 0;
+	cdata->sensors_enabled = 1;
+
+	cdata->gyro_selftest_status = 0;
+	cdata->accel_selftest_status = 0;
+
+	cdata->accel_on = true;
+	cdata->magn_on = false;
+
+	cdata->reset_steps = false;
+	cdata->num_steps = 0;
+
+	cdata->accel_odr_dependency[0] = 0;
+	cdata->accel_odr_dependency[1] = 0;
+	cdata->accel_odr_dependency[2] = 0;
+
+	cdata->trigger_odr = 0;
+
+	cdata->fifo_data = kmalloc(ST_LSM6DSM_MAX_FIFO_SIZE *
+						sizeof(u8), GFP_KERNEL);
+	if (!cdata->fifo_data)
+		return -ENOMEM;
+
+#ifdef CONFIG_ST_LSM6DSM_XL_DATA_INJECTION
+	cdata->injection_mode = false;
+	cdata->last_injection_timestamp = 0;
+	cdata->injection_odr = 0;
+#endif /* CONFIG_ST_LSM6DSM_XL_DATA_INJECTION */
+
+	err = cdata->tf->read(cdata, ST_LSM6DSM_WAI_ADDRESS, 1, &wai, true);
+	if (err < 0) {
+		dev_err(cdata->dev, "failed to read Who-Am-I register.\n");
+		goto free_fifo_data;
+	}
+	if (wai != ST_LSM6DSM_WAI_EXP) {
+		dev_err(cdata->dev,
+			"Who-Am-I value not valid. Expected %x, Found %x\n",
+						ST_LSM6DSM_WAI_EXP, wai);
+		err = -ENODEV;
+		goto free_fifo_data;
+	}
+
+	if (irq > 0) {
+		cdata->irq = irq;
+	} else {
+		err = -EINVAL;
+		dev_info(cdata->dev,
+			"DRDY not available, curernt implementation needs irq!\n");
+		goto free_fifo_data;
+	}
+
+	for (i = 0; i < ST_INDIO_DEV_NUM; i++) {
+		cdata->indio_dev[i] = iio_device_alloc(sizeof(struct lsm6dsm_sensor_data));
+		if (!cdata->indio_dev[i]) {
+			err = -ENOMEM;
+			goto iio_device_free;
+		}
+
+		sdata = iio_priv(cdata->indio_dev[i]);
+		sdata->cdata = cdata;
+		sdata->sindex = i;
+
+		switch (i) {
+		case ST_MASK_ID_ACCEL:
+			sdata->data_out_reg = st_lsm6dsm_accel_ch[0].address;
+			cdata->v_odr[i] = st_lsm6dsm_odr_table.odr_avl[3].hz;
+			sdata->c_gain[0] = st_lsm6dsm_fs_table[i].fs_avl[0].gain;
+			sdata->cdata->samples_to_discard_2[ST_MASK_ID_ACCEL] = 0;
+			sdata->num_data_channels = 3;
+			break;
+		case ST_MASK_ID_GYRO:
+			sdata->data_out_reg = st_lsm6dsm_gyro_ch[0].address;
+			cdata->v_odr[i] = st_lsm6dsm_odr_table.odr_avl[3].hz;
+			sdata->c_gain[0] = st_lsm6dsm_fs_table[i].fs_avl[0].gain;
+			sdata->cdata->samples_to_discard_2[ST_MASK_ID_GYRO] = 0;
+			sdata->num_data_channels = 3;
+			break;
+		case ST_MASK_ID_STEP_COUNTER:
+			sdata->data_out_reg = st_lsm6dsm_step_c_ch[0].address;
+			sdata->num_data_channels = 1;
+			break;
+
+		default:
+			sdata->num_data_channels = 0;
+			break;
+		}
+
+		cdata->indio_dev[i]->modes = INDIO_DIRECT_MODE;
+	}
+
+	cdata->indio_dev[ST_MASK_ID_ACCEL]->name =
+			kasprintf(GFP_KERNEL, "%s_%s", cdata->name,
+					ST_LSM6DSM_ACCEL_SUFFIX_NAME);
+	cdata->indio_dev[ST_MASK_ID_ACCEL]->info = &st_lsm6dsm_accel_info;
+	cdata->indio_dev[ST_MASK_ID_ACCEL]->channels = st_lsm6dsm_accel_ch;
+	cdata->indio_dev[ST_MASK_ID_ACCEL]->num_channels =
+						ARRAY_SIZE(st_lsm6dsm_accel_ch);
+
+	cdata->indio_dev[ST_MASK_ID_GYRO]->name =
+			kasprintf(GFP_KERNEL, "%s_%s", cdata->name,
+					ST_LSM6DSM_GYRO_SUFFIX_NAME);
+	cdata->indio_dev[ST_MASK_ID_GYRO]->info = &st_lsm6dsm_gyro_info;
+	cdata->indio_dev[ST_MASK_ID_GYRO]->channels = st_lsm6dsm_gyro_ch;
+	cdata->indio_dev[ST_MASK_ID_GYRO]->num_channels =
+						ARRAY_SIZE(st_lsm6dsm_gyro_ch);
+
+	cdata->indio_dev[ST_MASK_ID_SIGN_MOTION]->name =
+			kasprintf(GFP_KERNEL, "%s_%s", cdata->name,
+					ST_LSM6DSM_SIGN_MOTION_SUFFIX_NAME);
+	cdata->indio_dev[ST_MASK_ID_SIGN_MOTION]->info =
+						&st_lsm6dsm_sign_motion_info;
+	cdata->indio_dev[ST_MASK_ID_SIGN_MOTION]->channels =
+						st_lsm6dsm_sign_motion_ch;
+	cdata->indio_dev[ST_MASK_ID_SIGN_MOTION]->num_channels =
+					ARRAY_SIZE(st_lsm6dsm_sign_motion_ch);
+
+	cdata->indio_dev[ST_MASK_ID_STEP_COUNTER]->name =
+			kasprintf(GFP_KERNEL, "%s_%s", cdata->name,
+					ST_LSM6DSM_STEP_COUNTER_SUFFIX_NAME);
+	cdata->indio_dev[ST_MASK_ID_STEP_COUNTER]->info =
+						&st_lsm6dsm_step_c_info;
+	cdata->indio_dev[ST_MASK_ID_STEP_COUNTER]->channels =
+						st_lsm6dsm_step_c_ch;
+	cdata->indio_dev[ST_MASK_ID_STEP_COUNTER]->num_channels =
+					ARRAY_SIZE(st_lsm6dsm_step_c_ch);
+
+	cdata->indio_dev[ST_MASK_ID_STEP_DETECTOR]->name =
+			kasprintf(GFP_KERNEL, "%s_%s", cdata->name,
+					ST_LSM6DSM_STEP_DETECTOR_SUFFIX_NAME);
+	cdata->indio_dev[ST_MASK_ID_STEP_DETECTOR]->info =
+						&st_lsm6dsm_step_d_info;
+	cdata->indio_dev[ST_MASK_ID_STEP_DETECTOR]->channels =
+						st_lsm6dsm_step_d_ch;
+	cdata->indio_dev[ST_MASK_ID_STEP_DETECTOR]->num_channels =
+					ARRAY_SIZE(st_lsm6dsm_step_d_ch);
+
+	cdata->indio_dev[ST_MASK_ID_TILT]->name =
+			kasprintf(GFP_KERNEL, "%s_%s", cdata->name,
+					ST_LSM6DSM_TILT_SUFFIX_NAME);
+	cdata->indio_dev[ST_MASK_ID_TILT]->info = &st_lsm6dsm_tilt_info;
+	cdata->indio_dev[ST_MASK_ID_TILT]->channels = st_lsm6dsm_tilt_ch;
+	cdata->indio_dev[ST_MASK_ID_TILT]->num_channels =
+					ARRAY_SIZE(st_lsm6dsm_tilt_ch);
+
+	err = st_lsm6dsm_init_sensor(cdata);
+	if (err < 0)
+		goto iio_device_free;
+
+	err = st_lsm6dsm_allocate_rings(cdata);
+	if (err < 0)
+		goto iio_device_free;
+
+	if (irq > 0) {
+		err = st_lsm6dsm_allocate_triggers(cdata,
+							ST_LSM6DSM_TRIGGER_OPS);
+		if (err < 0)
+			goto deallocate_ring;
+	}
+
+	for (n = 0; n < ST_INDIO_DEV_NUM; n++) {
+		err = iio_device_register(cdata->indio_dev[n]);
+		if (err)
+			goto iio_device_unregister_and_trigger_deallocate;
+	}
+
+	st_lsm6dsm_i2c_master_probe(cdata);
+
+	device_init_wakeup(cdata->dev, true);
+
+	return 0;
+
+iio_device_unregister_and_trigger_deallocate:
+	for (n--; n >= 0; n--)
+		iio_device_unregister(cdata->indio_dev[n]);
+
+	if (irq > 0)
+		st_lsm6dsm_deallocate_triggers(cdata);
+deallocate_ring:
+	st_lsm6dsm_deallocate_rings(cdata);
+iio_device_free:
+	for (i--; i >= 0; i--)
+		iio_device_free(cdata->indio_dev[i]);
+free_fifo_data:
+	kfree(cdata->fifo_data);
+
+	return err;
+}
+EXPORT_SYMBOL(st_lsm6dsm_common_probe);
+
+void st_lsm6dsm_common_remove(struct lsm6dsm_data *cdata, int irq)
+{
+	int i;
+
+	for (i = 0; i < ST_INDIO_DEV_NUM; i++)
+		iio_device_unregister(cdata->indio_dev[i]);
+
+	if (irq > 0)
+		st_lsm6dsm_deallocate_triggers(cdata);
+
+	st_lsm6dsm_deallocate_rings(cdata);
+
+	for (i = 0; i < ST_INDIO_DEV_NUM; i++)
+		iio_device_free(cdata->indio_dev[i]);
+
+	kfree(cdata->fifo_data);
+
+	st_lsm6dsm_i2c_master_exit(cdata);
+}
+EXPORT_SYMBOL(st_lsm6dsm_common_remove);
+
+#ifdef CONFIG_PM
+int st_lsm6dsm_common_suspend(struct lsm6dsm_data *cdata)
+{
+	int err, i;
+	u8 tmp_sensors_enabled;
+	struct lsm6dsm_sensor_data *sdata;
+	u8 reg_value;
+	u8 interrupt_reg_value;
+	u8 mask;
+
+	cdata->tf->read(cdata, 0x10, 1, &reg_value, true);
+	cdata->tf->read(cdata, 0x58, 1, &interrupt_reg_value, true);
+
+	tmp_sensors_enabled = cdata->sensors_enabled;
+
+	for (i = 0; i < ST_INDIO_DEV_NUM; i++) {
+		if ((i == ST_MASK_ID_SIGN_MOTION) || (i == ST_MASK_ID_TILT))
+			continue;
+
+		sdata = iio_priv(cdata->indio_dev[i]);
+
+#ifdef CONFIG_ST_LSM6DSM_STEP_COUNTER_ON_DURING_SUSPEND
+		if ((BIT(i) & cdata->sensors_enabled) &&
+					(i == ST_MASK_ID_STEP_COUNTER)) {
+			err = st_lsm6dsm_write_data_with_mask(sdata->cdata,
+					ST_LSM6DSM_INT2_ADDR,
+					ST_LSM6DSM_STEP_COUNTER_DRDY_IRQ_MASK,
+					ST_LSM6DSM_DIS_BIT, true);
+			if (err < 0)
+				return err;
+
+			continue;
+		}
+#endif /* CONFIG_ST_LSM6DSM_STEP_COUNTER_ON_DURING_SUSPEND */
+
+		err = st_lsm6dsm_set_enable(sdata, false, true);
+		if (err < 0)
+			return err;
+	}
+
+	err = st_lsm6dsm_write_data_with_value(sdata->cdata, 0x58, interrupt_reg_value, ST_LSM6DSM_EN_BIT, true);
+	if (err < 0)
+		return err;
+
+	err = st_lsm6dsm_write_data_with_value(sdata->cdata, 0x0d, 0x00, ST_LSM6DSM_DIS_BIT, true);
+	if (err < 0)
+		return err;
+
+	err = st_lsm6dsm_write_data_with_value(sdata->cdata, 0x10, 0x40, ST_LSM6DSM_EN_BIT, true);
+	if (err < 0)
+		return err;
+
+	cdata->sensors_enabled = tmp_sensors_enabled;
+
+	if (cdata->sensors_enabled & ST_LSM6DSM_WAKE_UP_SENSORS) {
+		if (device_may_wakeup(cdata->dev)){
+			enable_irq_wake(cdata->irq);
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(st_lsm6dsm_common_suspend);
+
+int st_lsm6dsm_common_resume(struct lsm6dsm_data *cdata)
+{
+	int err, i;
+	struct lsm6dsm_sensor_data *sdata;
+	u8 reg_value;
+	u8 reg_value1;
+
+	cdata->tf->read(cdata, 0x10, 1, &reg_value, true);
+
+	for (i = 0; i < ST_INDIO_DEV_NUM; i++) {
+		if ((i == ST_MASK_ID_SIGN_MOTION) || (i == ST_MASK_ID_TILT))
+			continue;
+
+		sdata = iio_priv(cdata->indio_dev[i]);
+
+		if (BIT(sdata->sindex) & cdata->sensors_enabled) {
+#ifdef CONFIG_ST_LSM6DSM_STEP_COUNTER_ON_DURING_SUSPEND
+		if (i == ST_MASK_ID_STEP_COUNTER) {
+			err = st_lsm6dsm_write_data_with_mask(sdata->cdata,
+					ST_LSM6DSM_INT2_ADDR,
+					ST_LSM6DSM_STEP_COUNTER_DRDY_IRQ_MASK,
+					ST_LSM6DSM_EN_BIT, true);
+			if (err < 0)
+				return err;
+
+			continue;
+		}
+#endif /* CONFIG_ST_LSM6DSM_STEP_COUNTER_ON_DURING_SUSPEND */
+
+			err = st_lsm6dsm_set_enable(sdata, true, true);
+			if (err < 0)
+				return err;
+		}
+	}
+
+	err = st_lsm6dsm_write_data_with_value(sdata->cdata, 0x10, 0x70, ST_LSM6DSM_EN_BIT, true);
+	if (err < 0)
+		return err;
+
+	if (cdata->sensors_enabled & ST_LSM6DSM_WAKE_UP_SENSORS){
+		if (device_may_wakeup(cdata->dev)){
+			disable_irq_wake(cdata->irq);
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(st_lsm6dsm_common_resume);
+#endif /* CONFIG_PM */
+
+MODULE_AUTHOR("Denis Ciocca <denis.ciocca@st.com>");
+MODULE_DESCRIPTION("STMicroelectronics lsm6dsm core driver");
+MODULE_LICENSE("GPL v2");
diff -Naur A/drivers/iio/imu/st_lsm6dsm/st_lsm6dsm.h B/drivers/iio/imu/st_lsm6dsm/st_lsm6dsm.h
--- A/drivers/iio/imu/st_lsm6dsm/st_lsm6dsm.h	1970-01-01 05:30:00.000000000 +0530
+++ B/drivers/iio/imu/st_lsm6dsm/st_lsm6dsm.h	2022-08-09 13:36:04.270484049 +0530
@@ -0,0 +1,371 @@
+/*
+ * STMicroelectronics lsm6dsm driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Denis Ciocca <denis.ciocca@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#ifndef ST_LSM6DSM_H
+#define ST_LSM6DSM_H
+
+#include <linux/types.h>
+#include <linux/iio/trigger.h>
+
+#ifdef CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT
+#include <linux/i2c.h>
+#endif /* CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT */
+
+#define LSM6DSM_DEV_NAME			"lsm6dsm"
+#define LSM6DSL_DEV_NAME			"lsm6dsl"
+
+enum st_mask_id {
+	ST_MASK_ID_ACCEL = 0,
+	ST_MASK_ID_GYRO,
+	ST_MASK_ID_SIGN_MOTION,
+	ST_MASK_ID_STEP_COUNTER,
+	ST_MASK_ID_STEP_DETECTOR,
+	ST_MASK_ID_TILT,
+/* Commented by Akshay
+	ST_MASK_ID_WTILT,
+	ST_MASK_ID_TAP,
+	ST_MASK_ID_TAP_TAP,
+*/	
+	ST_MASK_ID_EXT0,
+	ST_MASK_ID_HW_PEDOMETER,
+	ST_MASK_ID_SENSOR_HUB,
+	ST_MASK_ID_DIGITAL_FUNC,
+	ST_MASK_ID_SENSOR_HUB_ASYNC_OP,
+};
+
+#define ST_INDIO_DEV_NUM			6
+
+#define ST_LSM6DSM_TX_MAX_LENGTH		12
+#define ST_LSM6DSM_RX_MAX_LENGTH		4097
+
+#define ST_LSM6DSM_BYTE_FOR_CHANNEL		2
+/* Commented by Akshay
+#define ST_LSM6DSM_BYTE_FOR_WRIST_TILT		1
+*/
+#define ST_LSM6DSM_FIFO_ELEMENT_LEN_BYTE	6
+
+#define ST_LSM6DSM_MAX_FIFO_SIZE		4096
+#define ST_LSM6DSM_MAX_FIFO_THRESHOLD		546
+#define ST_LSM6DSM_MAX_FIFO_LENGHT		(ST_LSM6DSM_MAX_FIFO_SIZE / \
+					ST_LSM6DSM_FIFO_ELEMENT_LEN_BYTE)
+
+#define ST_LSM6DSM_SELFTEST_NA_MS		"na"
+#define ST_LSM6DSM_SELFTEST_FAIL_MS		"fail"
+#define ST_LSM6DSM_SELFTEST_PASS_MS		"pass"
+
+#define ST_LSM6DSM_WAKE_UP_SENSORS	(BIT(ST_MASK_ID_SIGN_MOTION) | \
+					BIT(ST_MASK_ID_TILT))
+
+#ifdef CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT
+#define ST_LSM6DSM_NUM_CLIENTS			1
+#else /* CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT */
+#define ST_LSM6DSM_NUM_CLIENTS			0
+#endif /* CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT */
+
+#define ST_LSM6DSM_LSM_CHANNELS(device_type, modif, index, mod, \
+						endian, sbits, rbits, addr, s) \
+{ \
+	.type = device_type, \
+	.modified = modif, \
+	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \
+			BIT(IIO_CHAN_INFO_SCALE), \
+	.scan_index = index, \
+	.channel2 = mod, \
+	.address = addr, \
+	.scan_type = { \
+		.sign = s, \
+		.realbits = rbits, \
+		.shift = sbits - rbits, \
+		.storagebits = sbits, \
+		.endianness = endian, \
+	}, \
+}
+
+extern const struct iio_event_spec lsm6dsm_fifo_flush_event;
+
+#define ST_LSM6DSM_FLUSH_CHANNEL(device_type) \
+{ \
+	.type = device_type, \
+	.modified = 0, \
+	.scan_index = -1, \
+	.indexed = -1, \
+	.event_spec = &lsm6dsm_fifo_flush_event,\
+	.num_event_specs = 1, \
+}
+
+#define ST_LSM6DSM_HWFIFO_ENABLED() \
+	IIO_DEVICE_ATTR(hwfifo_enabled, S_IWUSR | S_IRUGO, \
+			st_lsm6dsm_sysfs_get_hwfifo_enabled,\
+			st_lsm6dsm_sysfs_set_hwfifo_enabled, 0);
+
+#define ST_LSM6DSM_HWFIFO_WATERMARK() \
+	IIO_DEVICE_ATTR(hwfifo_watermark, S_IWUSR | S_IRUGO, \
+			st_lsm6dsm_sysfs_get_hwfifo_watermark,\
+			st_lsm6dsm_sysfs_set_hwfifo_watermark, 0);
+
+#define ST_LSM6DSM_HWFIFO_WATERMARK_MIN() \
+	IIO_DEVICE_ATTR(hwfifo_watermark_min, S_IRUGO, \
+			st_lsm6dsm_sysfs_get_hwfifo_watermark_min, NULL, 0);
+
+#define ST_LSM6DSM_HWFIFO_WATERMARK_MAX() \
+	IIO_DEVICE_ATTR(hwfifo_watermark_max, S_IRUGO, \
+			st_lsm6dsm_sysfs_get_hwfifo_watermark_max, NULL, 0);
+
+#define ST_LSM6DSM_HWFIFO_FLUSH() \
+	IIO_DEVICE_ATTR(hwfifo_flush, S_IWUSR, NULL, \
+			st_lsm6dsm_sysfs_flush_fifo, 0);
+
+enum fifo_mode {
+	BYPASS = 0,
+	CONTINUOS,
+};
+
+struct st_lsm6dsm_transfer_buffer {
+	struct mutex buf_lock;
+	u8 rx_buf[ST_LSM6DSM_RX_MAX_LENGTH];
+	u8 tx_buf[ST_LSM6DSM_TX_MAX_LENGTH] ____cacheline_aligned;
+};
+
+struct lsm6dsm_out_decimation {
+	short decimator;
+	short num_samples;
+};
+
+struct lsm6dsm_fifo_output {
+	u8 sip;
+	int64_t deltatime;
+	int64_t deltatime_default;
+	int64_t timestamp;
+	int64_t timestamp_p;
+	short decimator;
+	short num_samples;
+	bool initialized;
+};
+
+/* struct lsm6dsm_data - common data for i2c or spi driver instance
+ * @name: pointer to the device name (i2c name or spi modalias).
+ * @enable_digfunc_mask: mask used to enable/disable hw digital functions.
+ * @enable_pedometer_mask: mask used to enable/disable hw pedometer function.
+ * @enable_sensorhub_mask: mask used to enable/disable sensor-hub feature.
+ * @irq_enable_fifo_mask: mask used to enable/disable fifo irq.
+ * @irq_enable_accel_ext_mask: mask used to enable/disable accel irq.
+ * @hw_odr: physical sensor odr expressed in Hz.
+ * @v_odr: requested sensor odr by userspace expressed in Hz.
+ * @hwfifo_enabled: is hwfifo enabled?
+ * @hwfifo_decimator: hwfifo decimator factor.
+ * @hwfifo_watermark: hwfifo watermark value.
+ * @samples_to_discard: samples to discard due to ODR switch.
+ * @nofifo_decimation: output status when fifo is disabled.
+ * @fifo_output: output status when fifo is enabled.
+ * @sensors_enabled: sensors enabled mask.
+ * @sensors_use_fifo: sensors use fifo mask.
+ * @accel_odr_dependency: odr dependency: accel, sensor-hub, dig-func.
+ * @accel_on: accel is going to be enabled during fifo odr switch?
+ * @magn_on: magn is going to be enabled during fifo odr switch?
+ * @odr_lock: mutex to avoid race condition during odr switch.
+ * @reset_steps: do I need to reset number of steps?
+ * @fifo_data: fifo data.
+ * @gyro_selftest_status: gyroscope selftest result.
+ * @accel_selftest_status: accelerometer selftest result.
+ * @irq: irq number.
+ * @timestamp: timestamp value from boot process.
+ */
+struct lsm6dsm_data {
+	const char *name;
+
+	u16 enable_digfunc_mask;
+	u16 enable_pedometer_mask;
+#ifdef CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT
+	u16 enable_sensorhub_mask;
+#endif /* CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT */
+
+	u16 irq_enable_fifo_mask;
+	u16 irq_enable_accel_ext_mask;
+
+	unsigned int hw_odr[ST_INDIO_DEV_NUM + 1];
+	unsigned int v_odr[ST_INDIO_DEV_NUM + 1];
+	unsigned int trigger_odr;
+
+	bool hwfifo_enabled[ST_INDIO_DEV_NUM + 1];
+	u8 hwfifo_decimator[ST_INDIO_DEV_NUM + 1];
+	u16 hwfifo_watermark[ST_INDIO_DEV_NUM + 1];
+	u16 fifo_watermark;
+
+	u8 samples_to_discard[ST_INDIO_DEV_NUM + 1];
+	u8 samples_to_discard_2[ST_INDIO_DEV_NUM + 1];
+	struct lsm6dsm_out_decimation nofifo_decimation[ST_INDIO_DEV_NUM + 1];
+	struct lsm6dsm_fifo_output fifo_output[ST_INDIO_DEV_NUM + 1];
+
+	u16 sensors_enabled;
+	u16 sensors_use_fifo;
+	u64 num_steps;
+
+	int accel_odr_dependency[3];
+
+	bool accel_on;
+	bool magn_on;
+	enum fifo_mode fifo_status;
+
+	struct mutex odr_lock;
+
+	bool reset_steps;
+
+	u8 *fifo_data;
+	u8 accel_last_push[6];
+	u8 gyro_last_push[6];
+	u8 ext0_last_push[6];
+	int8_t gyro_selftest_status;
+	int8_t accel_selftest_status;
+
+	u8 drdy_reg;
+	int irq;
+
+	s64 timestamp;
+	int64_t fifo_enable_timestamp;
+	int64_t slower_counter;
+	uint8_t slower_id;
+
+#ifdef CONFIG_ST_LSM6DSM_XL_DATA_INJECTION
+	bool injection_mode;
+	s64 last_injection_timestamp;
+	u8 injection_odr;
+#endif /* CONFIG_ST_LSM6DSM_XL_DATA_INJECTION */
+
+	struct work_struct data_work;
+
+	struct device *dev;
+	struct iio_dev *indio_dev[ST_INDIO_DEV_NUM + 1];
+	struct iio_trigger *trig[ST_INDIO_DEV_NUM + 1];
+	struct mutex bank_registers_lock;
+	struct mutex fifo_lock;
+
+#ifdef CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT
+	bool ext0_available;
+	int8_t ext0_selftest_status;
+	struct mutex i2c_transfer_lock;
+#endif /* CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT */
+
+	const struct st_lsm6dsm_transfer_function *tf;
+	struct st_lsm6dsm_transfer_buffer tb;
+};
+
+struct st_lsm6dsm_transfer_function {
+	int (*write)(struct lsm6dsm_data *cdata,
+				u8 reg_addr, int len, u8 *data, bool b_lock);
+	int (*read)(struct lsm6dsm_data *cdata,
+				u8 reg_addr, int len, u8 *data, bool b_lock);
+};
+
+struct lsm6dsm_sensor_data {
+	struct lsm6dsm_data *cdata;
+
+	unsigned int c_gain[3];
+
+	u8 num_data_channels;
+	u8 sindex;
+	u8 data_out_reg;
+};
+
+int st_lsm6dsm_write_data_with_mask(struct lsm6dsm_data *cdata,
+			u8 reg_addr, u8 mask, u8 data, bool b_lock);
+
+int st_lsm6dsm_push_data_with_timestamp(struct lsm6dsm_data *cdata,
+					u8 index, u8 *data, int64_t timestamp);
+
+int st_lsm6dsm_common_probe(struct lsm6dsm_data *cdata, int irq);
+void st_lsm6dsm_common_remove(struct lsm6dsm_data *cdata, int irq);
+
+int st_lsm6dsm_set_enable(struct lsm6dsm_sensor_data *sdata, bool enable, bool buffer);
+int st_lsm6dsm_set_fifo_mode(struct lsm6dsm_data *cdata, enum fifo_mode fm);
+int st_lsm6dsm_enable_sensor_hub(struct lsm6dsm_data *cdata, bool enable,
+							enum st_mask_id id);
+int lsm6dsm_read_output_data(struct lsm6dsm_data *cdata, int sindex, bool push);
+int st_lsm6dsm_set_drdy_irq(struct lsm6dsm_sensor_data *sdata, bool state);
+
+ssize_t st_lsm6dsm_sysfs_get_hwfifo_enabled(struct device *dev,
+				struct device_attribute *attr, char *buf);
+ssize_t st_lsm6dsm_sysfs_set_hwfifo_enabled(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size);
+ssize_t st_lsm6dsm_sysfs_get_hwfifo_watermark(struct device *dev,
+				struct device_attribute *attr, char *buf);
+ssize_t st_lsm6dsm_sysfs_set_hwfifo_watermark(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size);
+ssize_t st_lsm6dsm_sysfs_get_hwfifo_watermark_max(struct device *dev,
+				struct device_attribute *attr, char *buf);
+ssize_t st_lsm6dsm_sysfs_get_hwfifo_watermark_min(struct device *dev,
+				struct device_attribute *attr, char *buf);
+ssize_t st_lsm6dsm_sysfs_flush_fifo(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size);
+
+#ifdef CONFIG_IIO_BUFFER
+int st_lsm6dsm_allocate_rings(struct lsm6dsm_data *cdata);
+void st_lsm6dsm_deallocate_rings(struct lsm6dsm_data *cdata);
+int st_lsm6dsm_trig_set_state(struct iio_trigger *trig, bool state);
+int st_lsm6dsm_read_fifo(struct lsm6dsm_data *cdata, bool async);
+#define ST_LSM6DSM_TRIGGER_SET_STATE (&st_lsm6dsm_trig_set_state)
+#else /* CONFIG_IIO_BUFFER */
+static inline int st_lsm6dsm_allocate_rings(struct lsm6dsm_data *cdata)
+{
+	return 0;
+}
+static inline void st_lsm6dsm_deallocate_rings(struct lsm6dsm_data *cdata)
+{
+}
+static inline int st_lsm6dsm_read_fifo(struct lsm6dsm_data *cdata, bool async)
+{
+	return 0;
+}
+#define ST_LSM6DSM_TRIGGER_SET_STATE NULL
+#endif /* CONFIG_IIO_BUFFER */
+
+#ifdef CONFIG_IIO_TRIGGER
+int st_lsm6dsm_allocate_triggers(struct lsm6dsm_data *cdata,
+				const struct iio_trigger_ops *trigger_ops);
+void st_lsm6dsm_deallocate_triggers(struct lsm6dsm_data *cdata);
+void st_lsm6dsm_flush_works(void);
+#else /* CONFIG_IIO_TRIGGER */
+static inline int st_lsm6dsm_allocate_triggers(struct lsm6dsm_data *cdata,
+			const struct iio_trigger_ops *trigger_ops, int irq)
+{
+	return 0;
+}
+static inline void st_lsm6dsm_deallocate_triggers(struct lsm6dsm_data *cdata,
+								int irq)
+{
+	return;
+}
+static inline void st_lsm6dsm_flush_works(void)
+{
+	return;
+}
+#endif /* CONFIG_IIO_TRIGGER */
+
+#ifdef CONFIG_PM
+int st_lsm6dsm_common_suspend(struct lsm6dsm_data *cdata);
+int st_lsm6dsm_common_resume(struct lsm6dsm_data *cdata);
+#endif /* CONFIG_PM */
+
+#ifdef CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT
+int st_lsm6dsm_write_embedded_registers(struct lsm6dsm_data *cdata,
+						u8 reg_addr, u8 *data, int len);
+int st_lsm6dsm_i2c_master_probe(struct lsm6dsm_data *cdata);
+int st_lsm6dsm_i2c_master_exit(struct lsm6dsm_data *cdata);
+#else /* CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT */
+static inline int st_lsm6dsm_i2c_master_probe(struct lsm6dsm_data *cdata)
+{
+	return 0;
+}
+static inline int st_lsm6dsm_i2c_master_exit(struct lsm6dsm_data *cdata)
+{
+	return 0;
+}
+#endif /* CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT */
+
+#endif /* ST_LSM6DSM_H */
diff -Naur A/drivers/iio/imu/st_lsm6dsm/st_lsm6dsm_i2c.c B/drivers/iio/imu/st_lsm6dsm/st_lsm6dsm_i2c.c
--- A/drivers/iio/imu/st_lsm6dsm/st_lsm6dsm_i2c.c	1970-01-01 05:30:00.000000000 +0530
+++ B/drivers/iio/imu/st_lsm6dsm/st_lsm6dsm_i2c.c	2022-08-09 13:36:04.270484049 +0530
@@ -0,0 +1,178 @@
+/*
+ * STMicroelectronics lsm6dsm i2c driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Denis Ciocca <denis.ciocca@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/of.h>
+#include <linux/iio/iio.h>
+
+#include "st_lsm6dsm.h"
+
+static int st_lsm6dsm_i2c_read(struct lsm6dsm_data *cdata,
+				u8 reg_addr, int len, u8 *data, bool b_lock)
+{
+	int err = 0;
+	struct i2c_msg msg[2];
+	struct i2c_client *client = to_i2c_client(cdata->dev);
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &reg_addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	if (b_lock) {
+		mutex_lock(&cdata->bank_registers_lock);
+		err = i2c_transfer(client->adapter, msg, 2);
+		mutex_unlock(&cdata->bank_registers_lock);
+	} else
+		err = i2c_transfer(client->adapter, msg, 2);
+
+	return err;
+}
+
+static int st_lsm6dsm_i2c_write(struct lsm6dsm_data *cdata,
+				u8 reg_addr, int len, u8 *data, bool b_lock)
+{
+	int err = 0;
+	u8 send[len + 1];
+	struct i2c_msg msg;
+	struct i2c_client *client = to_i2c_client(cdata->dev);
+
+	send[0] = reg_addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len;
+	msg.buf = send;
+
+	if (b_lock) {
+		mutex_lock(&cdata->bank_registers_lock);
+		err = i2c_transfer(client->adapter, &msg, 1);
+		mutex_unlock(&cdata->bank_registers_lock);
+	} else
+		err = i2c_transfer(client->adapter, &msg, 1);
+
+	return err;
+}
+
+static const struct st_lsm6dsm_transfer_function st_lsm6dsm_tf_i2c = {
+	.write = st_lsm6dsm_i2c_write,
+	.read = st_lsm6dsm_i2c_read,
+};
+
+static int st_lsm6dsm_i2c_probe(struct i2c_client *client,
+						const struct i2c_device_id *id)
+{
+	int err;
+	struct lsm6dsm_data *cdata;
+
+	cdata = kmalloc(sizeof(*cdata), GFP_KERNEL);
+	if (!cdata)
+		return -ENOMEM;
+
+	cdata->dev = &client->dev;
+	cdata->name = client->name;
+	i2c_set_clientdata(client, cdata);
+
+	cdata->tf = &st_lsm6dsm_tf_i2c;
+
+	err = st_lsm6dsm_common_probe(cdata, client->irq);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(cdata);
+	return err;
+}
+
+static int st_lsm6dsm_i2c_remove(struct i2c_client *client)
+{
+	struct lsm6dsm_data *cdata = i2c_get_clientdata(client);
+
+	st_lsm6dsm_common_remove(cdata, client->irq);
+	kfree(cdata);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int st_lsm6dsm_suspend(struct device *dev)
+{
+	struct lsm6dsm_data *cdata = i2c_get_clientdata(to_i2c_client(dev));
+
+	return st_lsm6dsm_common_suspend(cdata);
+}
+
+static int st_lsm6dsm_resume(struct device *dev)
+{
+	struct lsm6dsm_data *cdata = i2c_get_clientdata(to_i2c_client(dev));
+
+	return st_lsm6dsm_common_resume(cdata);
+}
+
+static const struct dev_pm_ops st_lsm6dsm_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(st_lsm6dsm_suspend, st_lsm6dsm_resume)
+};
+
+#define ST_LSM6DSM_PM_OPS		(&st_lsm6dsm_pm_ops)
+#else /* CONFIG_PM */
+#define ST_LSM6DSM_PM_OPS		NULL
+#endif /* CONFIG_PM */
+
+static const struct i2c_device_id st_lsm6dsm_id_table[] = {
+	{ LSM6DSM_DEV_NAME },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, st_lsm6dsm_id_table);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lsm6dsm_of_match[] = {
+	{
+		.compatible = "st,lsm6dsm",
+		.data = LSM6DSM_DEV_NAME,
+	},
+	{
+		.compatible = "st,lsm6dsl",
+		.data = LSM6DSL_DEV_NAME,
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, lsm6dsm_of_match);
+#else /* CONFIG_OF */
+#define lsm6dsm_of_match		NULL
+#endif /* CONFIG_OF */
+
+static struct i2c_driver st_lsm6dsm_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "st-lsm6dsm-i2c",
+		.pm = ST_LSM6DSM_PM_OPS,
+		.of_match_table = of_match_ptr(lsm6dsm_of_match),
+	},
+	.probe = st_lsm6dsm_i2c_probe,
+	.remove = st_lsm6dsm_i2c_remove,
+	.id_table = st_lsm6dsm_id_table,
+};
+module_i2c_driver(st_lsm6dsm_driver);
+
+MODULE_AUTHOR("Denis Ciocca <denis.ciocca@st.com>");
+MODULE_DESCRIPTION("STMicroelectronics lsm6dsm i2c driver");
+MODULE_LICENSE("GPL v2");
diff -Naur A/drivers/iio/imu/st_lsm6dsm/st_lsm6dsm_i2c_master.c B/drivers/iio/imu/st_lsm6dsm/st_lsm6dsm_i2c_master.c
--- A/drivers/iio/imu/st_lsm6dsm/st_lsm6dsm_i2c_master.c	1970-01-01 05:30:00.000000000 +0530
+++ B/drivers/iio/imu/st_lsm6dsm/st_lsm6dsm_i2c_master.c	2022-08-09 13:36:04.270484049 +0530
@@ -0,0 +1,1767 @@
+/*
+ * STMicroelectronics lsm6dsm i2c master driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Denis Ciocca <denis.ciocca@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/sysfs.h>
+#include <linux/iio/trigger.h>
+#include <linux/iio/buffer.h>
+#include <linux/iio/buffer_impl.h>
+#include <linux/iio/events.h>
+#include <linux/iio/trigger_consumer.h>
+#include <linux/iio/triggered_buffer.h>
+#include <asm/unaligned.h>
+
+#include "st_lsm6dsm.h"
+
+#define EXT0_INDEX				0
+
+#define ST_LSM6DSM_ODR_LIST_NUM			4
+#define ST_LSM6DSM_SENSOR_HUB_OP_TIMEOUT	5
+#define ST_LSM6DSM_SRC_FUNC_ADDR		0x53
+#define ST_LSM6DSM_EN_BIT			0x01
+#define ST_LSM6DSM_DIS_BIT			0x00
+#define ST_LSM6DSM_SLV0_ADDR_ADDR		0x02
+#define ST_LSM6DSM_SLV1_ADDR_ADDR		0x05
+#define ST_LSM6DSM_SLV2_ADDR_ADDR		0x08
+#define ST_LSM6DSM_SLV0_OUT_ADDR		0x2e
+#define ST_LSM6DSM_INTER_PULLUP_ADDR		0x1a
+#define ST_LSM6DSM_INTER_PULLUP_MASK		0x08
+#define ST_LSM6DSM_FUNC_MAX_RATE_ADDR		0x18
+#define ST_LSM6DSM_FUNC_MAX_RATE_MASK		0x02
+#define ST_LSM6DSM_DATAWRITE_SLV0		0x0e
+#define ST_LSM6DSM_SLVX_READ			0x01
+
+/* External sensors configuration */
+#ifdef CONFIG_ST_LSM6DSM_IIO_EXT0_LIS3MDL
+static int lis3mdl_initialization(struct lsm6dsm_sensor_data *sdata);
+
+#define ST_LSM6DSM_EXT0_ADDR			0x1e
+#define ST_LSM6DSM_EXT0_ADDR2			0x1c
+#define ST_LSM6DSM_EXT0_WAI_ADDR		0x0f
+#define ST_LSM6DSM_EXT0_WAI_VALUE		0x3d
+#define ST_LSM6DSM_EXT0_RESET_ADDR		0x21
+#define ST_LSM6DSM_EXT0_RESET_MASK		0x04
+#define ST_LSM6DSM_EXT0_FULLSCALE_ADDR		0x21
+#define ST_LSM6DSM_EXT0_FULLSCALE_MASK		0x60
+#define ST_LSM6DSM_EXT0_FULLSCALE_VALUE		0x02
+#define ST_LSM6DSM_EXT0_ODR_ADDR		0x20
+#define ST_LSM6DSM_EXT0_ODR_MASK		0x1c
+#define ST_LSM6DSM_EXT0_ODR0_HZ			10
+#define ST_LSM6DSM_EXT0_ODR0_VALUE		0x04
+#define ST_LSM6DSM_EXT0_ODR1_HZ			20
+#define ST_LSM6DSM_EXT0_ODR1_VALUE		0x05
+#define ST_LSM6DSM_EXT0_ODR2_HZ			40
+#define ST_LSM6DSM_EXT0_ODR2_VALUE		0x06
+#define ST_LSM6DSM_EXT0_ODR3_HZ			80
+#define ST_LSM6DSM_EXT0_ODR3_VALUE		0x07
+#define ST_LSM6DSM_EXT0_PW_ADDR			0x22
+#define ST_LSM6DSM_EXT0_PW_MASK			0x03
+#define ST_LSM6DSM_EXT0_PW_OFF			0x02
+#define ST_LSM6DSM_EXT0_PW_ON			0x00
+#define ST_LSM6DSM_EXT0_GAIN_VALUE		438
+#define ST_LSM6DSM_EXT0_OUT_X_L_ADDR		0x28
+#define ST_LSM6DSM_EXT0_OUT_Y_L_ADDR		0x2a
+#define ST_LSM6DSM_EXT0_OUT_Z_L_ADDR		0x2c
+#define ST_LSM6DSM_EXT0_READ_DATA_LEN		6
+#define ST_LSM6DSM_EXT0_BDU_ADDR		0x24
+#define ST_LSM6DSM_EXT0_BDU_MASK		0x40
+#define ST_LSM6DSM_EXT0_STD			0
+#define ST_LSM6DSM_EXT0_BOOT_FUNCTION		(&lis3mdl_initialization)
+#define ST_LSM6DSM_SELFTEST_EXT0_MIN		2281
+#define ST_LSM6DSM_SELFTEST_EXT0_MAX		6843
+#define ST_LSM6DSM_SELFTEST_EXT0_MIN_Z		228
+#define ST_LSM6DSM_SELFTEST_EXT0_MAX_Z		2281
+#define ST_LSM6DSM_SELFTEST_ADDR1		0x20
+#define ST_LSM6DSM_SELFTEST_ADDR2		0x21
+#define ST_LSM6DSM_SELFTEST_ADDR3		0x22
+#define ST_LSM6DSM_SELFTEST_ADDR1_VALUE		0x1c
+#define ST_LSM6DSM_SELFTEST_ADDR2_VALUE		0x40
+#define ST_LSM6DSM_SELFTEST_ADDR3_VALUE		0x00
+#define ST_LSM6DSM_SELFTEST_ENABLE		0x1d
+#endif /* CONFIG_ST_LSM6DSM_IIO_EXT0_LIS3MDL */
+
+#ifdef CONFIG_ST_LSM6DSM_IIO_EXT0_AKM09911
+static int akm09911_initialization(struct lsm6dsm_sensor_data *sdata);
+
+#define ST_LSM6DSM_EXT0_ADDR			0x0c
+#define ST_LSM6DSM_EXT0_ADDR2			0x0d
+#define ST_LSM6DSM_EXT0_WAI_ADDR		0x01
+#define ST_LSM6DSM_EXT0_WAI_VALUE		0x05
+#define ST_LSM6DSM_EXT0_RESET_ADDR		0x32
+#define ST_LSM6DSM_EXT0_RESET_MASK		0x01
+#define ST_LSM6DSM_EXT0_FULLSCALE_ADDR		0x00
+#define ST_LSM6DSM_EXT0_FULLSCALE_MASK		0x00
+#define ST_LSM6DSM_EXT0_FULLSCALE_VALUE		0x00
+#define ST_LSM6DSM_EXT0_ODR_ADDR		0x31
+#define ST_LSM6DSM_EXT0_ODR_MASK		0x1f
+#define ST_LSM6DSM_EXT0_ODR0_HZ			10
+#define ST_LSM6DSM_EXT0_ODR0_VALUE		0x02
+#define ST_LSM6DSM_EXT0_ODR1_HZ			20
+#define ST_LSM6DSM_EXT0_ODR1_VALUE		0x04
+#define ST_LSM6DSM_EXT0_ODR2_HZ			50
+#define ST_LSM6DSM_EXT0_ODR2_VALUE		0x06
+#define ST_LSM6DSM_EXT0_ODR3_HZ			100
+#define ST_LSM6DSM_EXT0_ODR3_VALUE		0x08
+#define ST_LSM6DSM_EXT0_PW_ADDR			ST_LSM6DSM_EXT0_ODR_ADDR
+#define ST_LSM6DSM_EXT0_PW_MASK			ST_LSM6DSM_EXT0_ODR_MASK
+#define ST_LSM6DSM_EXT0_PW_OFF			0x00
+#define ST_LSM6DSM_EXT0_PW_ON			ST_LSM6DSM_EXT0_ODR0_VALUE
+#define ST_LSM6DSM_EXT0_GAIN_VALUE		6000
+#define ST_LSM6DSM_EXT0_OUT_X_L_ADDR		0x11
+#define ST_LSM6DSM_EXT0_OUT_Y_L_ADDR		0x13
+#define ST_LSM6DSM_EXT0_OUT_Z_L_ADDR		0x15
+#define ST_LSM6DSM_EXT0_READ_DATA_LEN		6
+#define ST_LSM6DSM_EXT0_SENSITIVITY_ADDR	0x60
+#define ST_LSM6DSM_EXT0_SENSITIVITY_LEN		3
+#define ST_LSM6DSM_EXT0_STD			0
+#define ST_LSM6DSM_EXT0_BOOT_FUNCTION		(&akm09911_initialization)
+#define ST_LSM6DSM_EXT0_DATA_STATUS		0x18
+#define ST_LSM6DSM_SELFTEST_EXT0_MIN		(-30)
+#define ST_LSM6DSM_SELFTEST_EXT0_MAX		30
+#define ST_LSM6DSM_SELFTEST_EXT0_MIN_Z		(-400)
+#define ST_LSM6DSM_SELFTEST_EXT0_MAX_Z		(-50)
+#endif /* CONFIG_ST_LSM6DSM_IIO_EXT0_AKM09911 */
+
+#ifdef CONFIG_ST_LSM6DSM_IIO_EXT0_AKM09912
+static int akm09912_initialization(struct lsm6dsm_sensor_data *sdata);
+
+#define ST_LSM6DSM_EXT0_ADDR			0x0c
+#define ST_LSM6DSM_EXT0_ADDR2			0x0d
+#define ST_LSM6DSM_EXT0_WAI_ADDR		0x01
+#define ST_LSM6DSM_EXT0_WAI_VALUE		0x04
+#define ST_LSM6DSM_EXT0_RESET_ADDR		0x32
+#define ST_LSM6DSM_EXT0_RESET_MASK		0x01
+#define ST_LSM6DSM_EXT0_FULLSCALE_ADDR		0x00
+#define ST_LSM6DSM_EXT0_FULLSCALE_MASK		0x00
+#define ST_LSM6DSM_EXT0_FULLSCALE_VALUE		0x00
+#define ST_LSM6DSM_EXT0_ODR_ADDR		0x31
+#define ST_LSM6DSM_EXT0_ODR_MASK		0x1f
+#define ST_LSM6DSM_EXT0_ODR0_HZ			10
+#define ST_LSM6DSM_EXT0_ODR0_VALUE		0x02
+#define ST_LSM6DSM_EXT0_ODR1_HZ			20
+#define ST_LSM6DSM_EXT0_ODR1_VALUE		0x04
+#define ST_LSM6DSM_EXT0_ODR2_HZ			50
+#define ST_LSM6DSM_EXT0_ODR2_VALUE		0x06
+#define ST_LSM6DSM_EXT0_ODR3_HZ			100
+#define ST_LSM6DSM_EXT0_ODR3_VALUE		0x08
+#define ST_LSM6DSM_EXT0_PW_ADDR			ST_LSM6DSM_EXT0_ODR_ADDR
+#define ST_LSM6DSM_EXT0_PW_MASK			ST_LSM6DSM_EXT0_ODR_MASK
+#define ST_LSM6DSM_EXT0_PW_OFF			0x00
+#define ST_LSM6DSM_EXT0_PW_ON			ST_LSM6DSM_EXT0_ODR0_VALUE
+#define ST_LSM6DSM_EXT0_GAIN_VALUE		1500
+#define ST_LSM6DSM_EXT0_OUT_X_L_ADDR		0x11
+#define ST_LSM6DSM_EXT0_OUT_Y_L_ADDR		0x13
+#define ST_LSM6DSM_EXT0_OUT_Z_L_ADDR		0x15
+#define ST_LSM6DSM_EXT0_READ_DATA_LEN		6
+#define ST_LSM6DSM_EXT0_SENSITIVITY_ADDR	0x60
+#define ST_LSM6DSM_EXT0_SENSITIVITY_LEN		3
+#define ST_LSM6DSM_EXT0_STD			0
+#define ST_LSM6DSM_EXT0_BOOT_FUNCTION		(&akm09912_initialization)
+#define ST_LSM6DSM_EXT0_DATA_STATUS		0x18
+#define ST_LSM6DSM_SELFTEST_EXT0_MIN		(-200)
+#define ST_LSM6DSM_SELFTEST_EXT0_MAX		200
+#define ST_LSM6DSM_SELFTEST_EXT0_MIN_Z		(-1600)
+#define ST_LSM6DSM_SELFTEST_EXT0_MAX_Z		(-400)
+#endif /* CONFIG_ST_LSM6DSM_IIO_EXT0_AKM09912 */
+
+#ifdef CONFIG_ST_LSM6DSM_IIO_EXT0_AKM09916
+#define ST_LSM6DSM_EXT0_ADDR			0x0c
+#define ST_LSM6DSM_EXT0_ADDR2			0x0c
+#define ST_LSM6DSM_EXT0_WAI_ADDR		0x01
+#define ST_LSM6DSM_EXT0_WAI_VALUE		0x09
+#define ST_LSM6DSM_EXT0_RESET_ADDR		0x32
+#define ST_LSM6DSM_EXT0_RESET_MASK		0x01
+#define ST_LSM6DSM_EXT0_FULLSCALE_ADDR		0x00
+#define ST_LSM6DSM_EXT0_FULLSCALE_MASK		0x00
+#define ST_LSM6DSM_EXT0_FULLSCALE_VALUE		0x00
+#define ST_LSM6DSM_EXT0_ODR_ADDR		0x31
+#define ST_LSM6DSM_EXT0_ODR_MASK		0x1f
+#define ST_LSM6DSM_EXT0_ODR0_HZ			10
+#define ST_LSM6DSM_EXT0_ODR0_VALUE		0x02
+#define ST_LSM6DSM_EXT0_ODR1_HZ			20
+#define ST_LSM6DSM_EXT0_ODR1_VALUE		0x04
+#define ST_LSM6DSM_EXT0_ODR2_HZ			50
+#define ST_LSM6DSM_EXT0_ODR2_VALUE		0x06
+#define ST_LSM6DSM_EXT0_ODR3_HZ			100
+#define ST_LSM6DSM_EXT0_ODR3_VALUE		0x08
+#define ST_LSM6DSM_EXT0_PW_ADDR			ST_LSM6DSM_EXT0_ODR_ADDR
+#define ST_LSM6DSM_EXT0_PW_MASK			ST_LSM6DSM_EXT0_ODR_MASK
+#define ST_LSM6DSM_EXT0_PW_OFF			0x00
+#define ST_LSM6DSM_EXT0_PW_ON			ST_LSM6DSM_EXT0_ODR0_VALUE
+#define ST_LSM6DSM_EXT0_GAIN_VALUE		1500
+#define ST_LSM6DSM_EXT0_OUT_X_L_ADDR		0x11
+#define ST_LSM6DSM_EXT0_OUT_Y_L_ADDR		0x13
+#define ST_LSM6DSM_EXT0_OUT_Z_L_ADDR		0x15
+#define ST_LSM6DSM_EXT0_READ_DATA_LEN		6
+#define ST_LSM6DSM_EXT0_SENSITIVITY_ADDR	0x60
+#define ST_LSM6DSM_EXT0_SENSITIVITY_LEN		3
+#define ST_LSM6DSM_EXT0_STD			0
+#define ST_LSM6DSM_EXT0_BOOT_FUNCTION		NULL
+#define ST_LSM6DSM_EXT0_DATA_STATUS		0x18
+#define ST_LSM6DSM_SELFTEST_EXT0_MIN		(-200)
+#define ST_LSM6DSM_SELFTEST_EXT0_MAX		200
+#define ST_LSM6DSM_SELFTEST_EXT0_MIN_Z		(-1000)
+#define ST_LSM6DSM_SELFTEST_EXT0_MAX_Z		(-200)
+#endif /* CONFIG_ST_LSM6DSM_IIO_EXT0_AKM09916 */
+
+#ifdef CONFIG_ST_LSM6DSM_IIO_EXT0_LPS22HB
+static int lps22hb_initialization(struct lsm6dsm_sensor_data *sdata);
+
+#define ST_LSM6DSM_EXT0_ADDR			0x5d
+#define ST_LSM6DSM_EXT0_ADDR2			0x5c
+#define ST_LSM6DSM_EXT0_WAI_ADDR		0x0f
+#define ST_LSM6DSM_EXT0_WAI_VALUE		0xb1
+#define ST_LSM6DSM_EXT0_RESET_ADDR		0x11
+#define ST_LSM6DSM_EXT0_RESET_MASK		0x80
+#define ST_LSM6DSM_EXT0_FULLSCALE_ADDR		0x00
+#define ST_LSM6DSM_EXT0_FULLSCALE_MASK		0x00
+#define ST_LSM6DSM_EXT0_FULLSCALE_VALUE		0x00
+#define ST_LSM6DSM_EXT0_ODR_ADDR		0x10
+#define ST_LSM6DSM_EXT0_ODR_MASK		0x70
+#define ST_LSM6DSM_EXT0_ODR0_HZ			1
+#define ST_LSM6DSM_EXT0_ODR0_VALUE		0x01
+#define ST_LSM6DSM_EXT0_ODR1_HZ			10
+#define ST_LSM6DSM_EXT0_ODR1_VALUE		0x02
+#define ST_LSM6DSM_EXT0_ODR2_HZ			25
+#define ST_LSM6DSM_EXT0_ODR2_VALUE		0x03
+#define ST_LSM6DSM_EXT0_ODR3_HZ			50
+#define ST_LSM6DSM_EXT0_ODR3_VALUE		0x04
+#define ST_LSM6DSM_EXT0_PW_ADDR			ST_LSM6DSM_EXT0_ODR_ADDR
+#define ST_LSM6DSM_EXT0_PW_MASK			ST_LSM6DSM_EXT0_ODR_MASK
+#define ST_LSM6DSM_EXT0_PW_OFF			0x00
+#define ST_LSM6DSM_EXT0_PW_ON			ST_LSM6DSM_EXT0_ODR0_VALUE
+#define ST_LSM6DSM_EXT0_GAIN_VALUE		244
+#define ST_LSM6DSM_EXT0_OUT_P_L_ADDR		0x28
+#define ST_LSM6DSM_EXT0_OUT_T_L_ADDR		0x2b
+#define ST_LSM6DSM_EXT0_READ_DATA_LEN		5
+#define ST_LSM6DSM_EXT0_BDU_ADDR		0x10
+#define ST_LSM6DSM_EXT0_BDU_MASK		0x02
+#define ST_LSM6DSM_EXT0_STD			0
+#define ST_LSM6DSM_EXT0_BOOT_FUNCTION		(&lps22hb_initialization)
+#endif /* CONFIG_ST_LSM6DSM_IIO_EXT0_LPS22HB */
+
+#ifdef CONFIG_ST_LSM6DSM_IIO_EXT0_LIS2MDL
+static int lis2mdl_initialization(struct lsm6dsm_sensor_data *sdata);
+
+#define ST_LSM6DSM_EXT0_ADDR			0x1e
+#define ST_LSM6DSM_EXT0_ADDR2			0x1e
+#define ST_LSM6DSM_EXT0_WAI_ADDR		0x4f
+#define ST_LSM6DSM_EXT0_WAI_VALUE		0x40
+#define ST_LSM6DSM_EXT0_RESET_ADDR		0x60
+#define ST_LSM6DSM_EXT0_RESET_MASK		0x20
+#define ST_LSM6DSM_EXT0_ODR_ADDR		0x60
+#define ST_LSM6DSM_EXT0_ODR_MASK		0x0c
+#define ST_LSM6DSM_EXT0_ODR0_HZ			10
+#define ST_LSM6DSM_EXT0_ODR0_VALUE		0x00
+#define ST_LSM6DSM_EXT0_ODR1_HZ			20
+#define ST_LSM6DSM_EXT0_ODR1_VALUE		0x01
+#define ST_LSM6DSM_EXT0_ODR2_HZ			50
+#define ST_LSM6DSM_EXT0_ODR2_VALUE		0x02
+#define ST_LSM6DSM_EXT0_ODR3_HZ			100
+#define ST_LSM6DSM_EXT0_ODR3_VALUE		0x03
+#define ST_LSM6DSM_EXT0_PW_ADDR			0x60
+#define ST_LSM6DSM_EXT0_PW_MASK			0x03
+#define ST_LSM6DSM_EXT0_PW_OFF			0x02
+#define ST_LSM6DSM_EXT0_PW_ON			0x00
+#define ST_LSM6DSM_EXT0_GAIN_VALUE		1500
+#define ST_LSM6DSM_EXT0_OUT_X_L_ADDR		0x68
+#define ST_LSM6DSM_EXT0_OUT_Y_L_ADDR		0x6a
+#define ST_LSM6DSM_EXT0_OUT_Z_L_ADDR		0x6c
+#define ST_LSM6DSM_EXT0_READ_DATA_LEN		6
+#define ST_LSM6DSM_EXT0_BDU_ADDR		0x62
+#define ST_LSM6DSM_EXT0_BDU_MASK		0x10
+#define ST_LSM6DSM_EXT0_STD			0
+#define ST_LSM6DSM_EXT0_TEMP_COMP_ADDR		0x60
+#define ST_LSM6DSM_EXT0_TEMP_COMP_MASK		0x80
+#define ST_LSM6DSM_EXT0_OFF_CANC_ADDR		0x61
+#define ST_LSM6DSM_EXT0_OFF_CANC_MASK		0x02
+#define ST_LSM6DSM_EXT0_BOOT_FUNCTION		(&lis2mdl_initialization)
+#endif /* CONFIG_ST_LSM6DSM_IIO_EXT0_LIS2MDL */
+
+/* SENSORS SUFFIX NAMES */
+#define ST_LSM6DSM_EXT0_SUFFIX_NAME		"magn"
+#define ST_LSM6DSM_EXT1_SUFFIX_NAME		"press"
+
+#if defined(CONFIG_ST_LSM6DSM_IIO_EXT0_LIS3MDL) || \
+			defined(CONFIG_ST_LSM6DSM_IIO_EXT0_AKM09912) || \
+			defined(CONFIG_ST_LSM6DSM_IIO_EXT0_AKM09916) || \
+			defined(CONFIG_ST_LSM6DSM_IIO_EXT0_AKM09911)
+#define ST_LSM6DSM_EXT0_HAS_SELFTEST		1
+#endif /* CONFIG_ST_LSM6DSM_IIO_EXT0_MAGN */
+
+#if defined(CONFIG_ST_LSM6DSM_IIO_EXT0_LIS3MDL) || \
+    defined(CONFIG_ST_LSM6DSM_IIO_EXT0_AKM09912) || \
+    defined(CONFIG_ST_LSM6DSM_IIO_EXT0_AKM09916) || \
+    defined(CONFIG_ST_LSM6DSM_IIO_EXT0_AKM09911) || \
+    defined(CONFIG_ST_LSM6DSM_IIO_EXT0_LPS22HB)
+#define ST_LSM6DSM_EXT0_HAS_FULLSCALE		1
+#endif
+
+#if defined(CONFIG_ST_LSM6DSM_IIO_EXT0_AKM09912) || \
+			defined(CONFIG_ST_LSM6DSM_IIO_EXT0_AKM09916) || \
+			defined(CONFIG_ST_LSM6DSM_IIO_EXT0_AKM09911)
+#define ST_LSM6DSM_EXT0_IS_AKM			1
+#define ST_LSM6DSM_SELFTEST_STATUS_REG		0x10
+#define ST_LSM6DSM_SELFTEST_ADDR		0x31
+#define ST_LSM6DSM_SELFTEST_ENABLE		0x10
+#endif /* CONFIG_ST_LSM6DSM_IIO_EXT0_AKM0099xx */
+
+struct st_lsm6dsm_i2c_master_odr_reg {
+	unsigned int hz;
+	u8 value;
+};
+
+struct st_lsm6dsm_i2c_master_odr_table {
+	u8 addr;
+	u8 mask;
+	struct st_lsm6dsm_i2c_master_odr_reg odr_avl[ST_LSM6DSM_ODR_LIST_NUM];
+};
+
+static int st_lsm6dsm_i2c_master_read_raw(struct iio_dev *indio_dev,
+		struct iio_chan_spec const *ch, int *val, int *val2, long mask);
+
+#ifdef CONFIG_ST_LSM6DSM_IIO_EXT0_LPS22HB
+static const struct iio_chan_spec st_lsm6dsm_ext0_ch[] = {
+	ST_LSM6DSM_LSM_CHANNELS(IIO_PRESSURE, 0, 0, IIO_NO_MOD, IIO_LE,
+				24, 24, ST_LSM6DSM_EXT0_OUT_P_L_ADDR, 'u'),
+	ST_LSM6DSM_LSM_CHANNELS(IIO_TEMP, 0, 1, IIO_NO_MOD, IIO_LE,
+				16, 16, ST_LSM6DSM_EXT0_OUT_T_L_ADDR, 's'),
+	ST_LSM6DSM_FLUSH_CHANNEL(IIO_PRESSURE),
+	IIO_CHAN_SOFT_TIMESTAMP(2)
+};
+#else /* CONFIG_ST_LSM6DSM_IIO_EXT0_LPS22HB */
+static const struct iio_chan_spec st_lsm6dsm_ext0_ch[] = {
+	ST_LSM6DSM_LSM_CHANNELS(IIO_MAGN, 1, 0, IIO_MOD_X, IIO_LE,
+				16, 16, ST_LSM6DSM_EXT0_OUT_X_L_ADDR, 's'),
+	ST_LSM6DSM_LSM_CHANNELS(IIO_MAGN, 1, 1, IIO_MOD_Y, IIO_LE,
+				16, 16, ST_LSM6DSM_EXT0_OUT_Y_L_ADDR, 's'),
+	ST_LSM6DSM_LSM_CHANNELS(IIO_MAGN, 1, 2, IIO_MOD_Z, IIO_LE,
+				16, 16, ST_LSM6DSM_EXT0_OUT_Z_L_ADDR, 's'),
+	ST_LSM6DSM_FLUSH_CHANNEL(IIO_MAGN),
+	IIO_CHAN_SOFT_TIMESTAMP(3)
+};
+#endif /* CONFIG_ST_LSM6DSM_IIO_EXT0_LPS22HB */
+
+static int st_lsm6dsm_i2c_master_set_odr(struct lsm6dsm_sensor_data *sdata,
+						unsigned int odr, bool force);
+
+static int st_lsm6dsm_i2c_master_write(struct lsm6dsm_data *cdata,
+		u8 reg_addr, int len, u8 *data, bool en_sensor_hub, bool transfer_lock);
+static int st_lsm6dsm_i2c_master_read(struct lsm6dsm_data *cdata,
+		u8 reg_addr, int len, u8 *data, bool en_sensor_hub,
+				bool transfer_lock, bool read_status_end, u8 offset);
+
+#ifdef ST_LSM6DSM_EXT0_HAS_SELFTEST
+static ssize_t st_lsm6dsm_i2c_master_sysfs_get_selftest_available(
+		struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t st_lsm6dsm_i2c_master_sysfs_get_selftest_status(
+		struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t st_lsm6dsm_i2c_master_sysfs_start_selftest(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size);
+#endif /* ST_LSM6DSM_EXT0_HAS_SELFTEST	*/
+
+static ssize_t st_lsm6dsm_i2c_master_sysfs_sampling_frequency_avail(
+		struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return scnprintf(buf, PAGE_SIZE,
+			"%d %d %d %d\n", 13, 26, 52, 104);
+}
+
+static ssize_t st_lsm6dsm_i2c_master_sysfs_get_sampling_frequency(
+		struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct lsm6dsm_sensor_data *sdata = iio_priv(dev_get_drvdata(dev));
+
+	return sprintf(buf, "%d\n", sdata->cdata->v_odr[sdata->sindex]);
+}
+
+static ssize_t st_lsm6dsm_i2c_master_sysfs_set_sampling_frequency(
+			struct device *dev, struct device_attribute *attr,
+						const char *buf, size_t size)
+{
+	int err;
+	unsigned int odr;
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct lsm6dsm_sensor_data *sdata = iio_priv(indio_dev);
+
+	err = kstrtoint(buf, 10, &odr);
+	if (err < 0)
+		return err;
+
+	mutex_lock(&indio_dev->mlock);
+	mutex_lock(&sdata->cdata->odr_lock);
+
+	if (sdata->cdata->v_odr[sdata->sindex] != odr)
+		err = st_lsm6dsm_i2c_master_set_odr(sdata, odr, false);
+
+	mutex_unlock(&sdata->cdata->odr_lock);
+	mutex_unlock(&indio_dev->mlock);
+
+	return err < 0 ? err : size;
+}
+
+static IIO_DEV_ATTR_SAMP_FREQ(S_IWUSR | S_IRUGO,
+			st_lsm6dsm_i2c_master_sysfs_get_sampling_frequency,
+			st_lsm6dsm_i2c_master_sysfs_set_sampling_frequency);
+
+static IIO_DEV_ATTR_SAMP_FREQ_AVAIL(
+			st_lsm6dsm_i2c_master_sysfs_sampling_frequency_avail);
+
+static ST_LSM6DSM_HWFIFO_ENABLED();
+static ST_LSM6DSM_HWFIFO_WATERMARK();
+static ST_LSM6DSM_HWFIFO_WATERMARK_MIN();
+static ST_LSM6DSM_HWFIFO_WATERMARK_MAX();
+static ST_LSM6DSM_HWFIFO_FLUSH();
+
+#ifdef ST_LSM6DSM_EXT0_HAS_SELFTEST
+static IIO_DEVICE_ATTR(selftest_available, S_IRUGO,
+			st_lsm6dsm_i2c_master_sysfs_get_selftest_available,
+			NULL, 0);
+
+static IIO_DEVICE_ATTR(selftest, S_IWUSR | S_IRUGO,
+			st_lsm6dsm_i2c_master_sysfs_get_selftest_status,
+			st_lsm6dsm_i2c_master_sysfs_start_selftest, 0);
+#endif /* ST_LSM6DSM_EXT0_HAS_SELFTEST	*/
+
+static struct attribute *st_lsm6dsm_ext0_attributes[] = {
+	&iio_dev_attr_sampling_frequency_available.dev_attr.attr,
+	&iio_dev_attr_sampling_frequency.dev_attr.attr,
+	&iio_dev_attr_hwfifo_enabled.dev_attr.attr,
+	&iio_dev_attr_hwfifo_watermark.dev_attr.attr,
+	&iio_dev_attr_hwfifo_watermark_min.dev_attr.attr,
+	&iio_dev_attr_hwfifo_watermark_max.dev_attr.attr,
+	&iio_dev_attr_hwfifo_flush.dev_attr.attr,
+#ifdef ST_LSM6DSM_EXT0_HAS_SELFTEST
+	&iio_dev_attr_selftest_available.dev_attr.attr,
+	&iio_dev_attr_selftest.dev_attr.attr,
+#endif /* ST_LSM6DSM_EXT0_HAS_SELFTEST	*/
+	NULL,
+};
+
+static const struct attribute_group st_lsm6dsm_ext0_attribute_group = {
+	.attrs = st_lsm6dsm_ext0_attributes,
+};
+
+static const struct iio_info st_lsm6dsm_ext0_info = {
+	.attrs = &st_lsm6dsm_ext0_attribute_group,
+	.read_raw = &st_lsm6dsm_i2c_master_read_raw,
+};
+
+struct st_lsm6dsm_iio_info_data {
+	char suffix_name[20];
+	struct iio_info *info;
+	struct iio_chan_spec *channels;
+	int num_channels;
+};
+
+struct st_lsm6dsm_reg {
+	u8 addr;
+	u8 mask;
+	u8 def_value;
+};
+
+struct st_lsm6dsm_power_reg {
+	u8 addr;
+	u8 mask;
+	u8 off_value;
+	u8 on_value;
+	bool isodr;
+};
+
+struct st_lsm6dsm_custom_function {
+	int (*boot_initialization)(struct lsm6dsm_sensor_data *sdata);
+};
+
+static struct st_lsm6dsm_exs_list {
+	struct st_lsm6dsm_reg wai;
+	struct st_lsm6dsm_reg reset;
+	struct st_lsm6dsm_reg fullscale;
+	struct st_lsm6dsm_i2c_master_odr_table odr;
+	struct st_lsm6dsm_power_reg power;
+	u8 fullscale_value;
+	u8 samples_to_discard;
+	u8 read_data_len;
+	u8 num_data_channels;
+	bool available;
+	unsigned int gain;
+	u8 i2c_addr;
+	struct st_lsm6dsm_iio_info_data data;
+	struct st_lsm6dsm_custom_function cf;
+} st_lsm6dsm_exs_list[] = {
+	{
+		.wai = {
+			.addr = ST_LSM6DSM_EXT0_WAI_ADDR,
+			.def_value = ST_LSM6DSM_EXT0_WAI_VALUE,
+		},
+		.reset = {
+			.addr = ST_LSM6DSM_EXT0_RESET_ADDR,
+			.mask = ST_LSM6DSM_EXT0_RESET_MASK,
+		},
+#ifdef ST_LSM6DSM_EXT0_HAS_FULLSCALE
+		.fullscale = {
+			.addr = ST_LSM6DSM_EXT0_FULLSCALE_ADDR,
+			.mask = ST_LSM6DSM_EXT0_FULLSCALE_MASK,
+			.def_value = ST_LSM6DSM_EXT0_FULLSCALE_VALUE,
+		},
+#endif
+		.odr = {
+			.addr = ST_LSM6DSM_EXT0_ODR_ADDR,
+			.mask = ST_LSM6DSM_EXT0_ODR_MASK,
+			.odr_avl = {
+				{
+				.hz = ST_LSM6DSM_EXT0_ODR0_HZ,
+				.value = ST_LSM6DSM_EXT0_ODR0_VALUE,
+				},
+				{
+				.hz = ST_LSM6DSM_EXT0_ODR1_HZ,
+				.value = ST_LSM6DSM_EXT0_ODR1_VALUE,
+				},
+				{
+				.hz = ST_LSM6DSM_EXT0_ODR2_HZ,
+				.value = ST_LSM6DSM_EXT0_ODR2_VALUE,
+				},
+				{
+				.hz = ST_LSM6DSM_EXT0_ODR3_HZ,
+				.value = ST_LSM6DSM_EXT0_ODR3_VALUE,
+				},
+			},
+		},
+		.power = {
+			.addr = ST_LSM6DSM_EXT0_PW_ADDR,
+			.mask = ST_LSM6DSM_EXT0_PW_MASK,
+			.off_value = ST_LSM6DSM_EXT0_PW_OFF,
+			.on_value = ST_LSM6DSM_EXT0_PW_ON,
+		},
+		.samples_to_discard = ST_LSM6DSM_EXT0_STD,
+		.read_data_len = ST_LSM6DSM_EXT0_READ_DATA_LEN,
+		.num_data_channels = 3,
+		.available = false,
+		.gain = ST_LSM6DSM_EXT0_GAIN_VALUE,
+		.i2c_addr = ST_LSM6DSM_EXT0_ADDR,
+		.data = {
+			.suffix_name = ST_LSM6DSM_EXT0_SUFFIX_NAME,
+			.info = (struct iio_info *)&st_lsm6dsm_ext0_info,
+			.channels = (struct iio_chan_spec *)&st_lsm6dsm_ext0_ch,
+			.num_channels = ARRAY_SIZE(st_lsm6dsm_ext0_ch),
+		},
+		.cf.boot_initialization = ST_LSM6DSM_EXT0_BOOT_FUNCTION,
+	}
+};
+
+static inline void st_lsm6dsm_master_wait_completed(struct lsm6dsm_data *cdata)
+{
+	msleep((1000U / cdata->trigger_odr) + 2);
+}
+
+static int st_lsm6dsm_i2c_master_read(struct lsm6dsm_data *cdata,
+		u8 reg_addr, int len, u8 *data, bool en_sensor_hub,
+			bool transfer_lock, bool read_status_end, u8 offset)
+{
+	int err;
+	u8 slave_conf[3];
+
+	slave_conf[0] = (st_lsm6dsm_exs_list[EXT0_INDEX].i2c_addr << 1) |
+							ST_LSM6DSM_SLVX_READ;
+	slave_conf[1] = reg_addr;
+	slave_conf[2] = (len & 0x07);
+
+	if (transfer_lock)
+		mutex_lock(&cdata->i2c_transfer_lock);
+
+	err = st_lsm6dsm_write_embedded_registers(cdata,
+					ST_LSM6DSM_SLV2_ADDR_ADDR, slave_conf,
+					ARRAY_SIZE(slave_conf));
+	if (err < 0)
+		goto i2c_master_read_unlock_mutex;
+
+	if (en_sensor_hub) {
+		err = st_lsm6dsm_enable_sensor_hub(cdata, true,
+						ST_MASK_ID_SENSOR_HUB_ASYNC_OP);
+		if (err < 0)
+			goto i2c_master_read_unlock_mutex;
+	}
+
+	st_lsm6dsm_master_wait_completed(cdata);
+
+	err = cdata->tf->read(cdata, ST_LSM6DSM_SLV0_OUT_ADDR +
+					offset, len & 0x07, data, true);
+	if (err < 0)
+		goto i2c_master_read_unlock_mutex;
+
+#ifdef ST_LSM6DSM_EXT0_IS_AKM
+	if (read_status_end) {
+		slave_conf[0] = (st_lsm6dsm_exs_list[EXT0_INDEX].i2c_addr << 1) | 0x01;
+		slave_conf[1] = ST_LSM6DSM_EXT0_DATA_STATUS;
+		slave_conf[2] = 0x01;
+
+		err = st_lsm6dsm_write_embedded_registers(cdata,
+					ST_LSM6DSM_SLV2_ADDR_ADDR, slave_conf,
+					ARRAY_SIZE(slave_conf));
+		if (err < 0)
+			goto i2c_master_read_unlock_mutex;
+	}
+#endif /* ST_LSM6DSM_EXT0_IS_AKM */
+
+	if (en_sensor_hub) {
+		err = st_lsm6dsm_enable_sensor_hub(cdata, false,
+						ST_MASK_ID_SENSOR_HUB_ASYNC_OP);
+		if (err < 0)
+			goto i2c_master_read_unlock_mutex;
+	}
+
+i2c_master_read_unlock_mutex:
+	if (transfer_lock)
+		mutex_unlock(&cdata->i2c_transfer_lock);
+
+	return err < 0 ? err : len & 0x07;
+}
+
+static int st_lsm6dsm_i2c_master_write(struct lsm6dsm_data *cdata,
+		u8 reg_addr, int len, u8 *data, bool en_sensor_hub, bool transfer_lock)
+{
+	int err, i = 0;
+	u8 slave0_conf[2];
+
+	if (transfer_lock)
+		mutex_lock(&cdata->i2c_transfer_lock);
+
+	while (i < len) {
+		slave0_conf[0] = (st_lsm6dsm_exs_list[EXT0_INDEX].i2c_addr << 1);
+		slave0_conf[1] = reg_addr + i;
+
+		err = st_lsm6dsm_write_embedded_registers(cdata,
+						ST_LSM6DSM_SLV0_ADDR_ADDR,
+						slave0_conf,
+						ARRAY_SIZE(slave0_conf));
+		if (err < 0)
+			goto i2c_master_write_unlock_mutex;
+
+		slave0_conf[0] = data[i];
+
+		err = st_lsm6dsm_write_embedded_registers(cdata,
+						ST_LSM6DSM_DATAWRITE_SLV0,
+						slave0_conf, 1);
+		if (err < 0)
+			goto i2c_master_write_unlock_mutex;
+
+		if (en_sensor_hub) {
+			err = st_lsm6dsm_enable_sensor_hub(cdata, true,
+						ST_MASK_ID_SENSOR_HUB_ASYNC_OP);
+			if (err < 0)
+				goto i2c_master_write_unlock_mutex;
+		}
+
+		st_lsm6dsm_master_wait_completed(cdata);
+
+		if (en_sensor_hub) {
+			err = st_lsm6dsm_enable_sensor_hub(cdata, false,
+						ST_MASK_ID_SENSOR_HUB_ASYNC_OP);
+			if (err < 0)
+				goto i2c_master_write_unlock_mutex;
+		}
+
+		i++;
+	}
+
+	slave0_conf[0] = (st_lsm6dsm_exs_list[EXT0_INDEX].i2c_addr << 1) | ST_LSM6DSM_EN_BIT;
+	slave0_conf[1] = st_lsm6dsm_exs_list[EXT0_INDEX].wai.addr;
+
+	st_lsm6dsm_write_embedded_registers(cdata,
+						ST_LSM6DSM_SLV0_ADDR_ADDR,
+						slave0_conf,
+						ARRAY_SIZE(slave0_conf));
+
+i2c_master_write_unlock_mutex:
+	if (transfer_lock)
+		mutex_unlock(&cdata->i2c_transfer_lock);
+
+	return err < 0 ? err : len;
+}
+
+static int st_lsm6dsm_i2c_master_write_data_with_mask(
+		struct lsm6dsm_data *cdata, u8 reg_addr, u8 mask, u8 data)
+{
+	int err;
+	u8 new_data = 0x00, old_data = 0x00;
+
+	mutex_lock(&cdata->i2c_transfer_lock);
+	disable_irq(cdata->irq);
+
+	err = st_lsm6dsm_enable_sensor_hub(cdata, true,
+						ST_MASK_ID_SENSOR_HUB_ASYNC_OP);
+	if (err < 0) {
+		enable_irq(cdata->irq);
+		mutex_unlock(&cdata->i2c_transfer_lock);
+		return err;
+	}
+
+	err = st_lsm6dsm_i2c_master_read(cdata, reg_addr, 1,
+					&old_data, false, false, true,
+					st_lsm6dsm_exs_list[0].read_data_len);
+	if (err < 0) {
+		enable_irq(cdata->irq);
+		mutex_unlock(&cdata->i2c_transfer_lock);
+		return err;
+	}
+
+	new_data = ((old_data & (~mask)) | ((data << __ffs(mask)) & mask));
+
+	if (new_data != old_data)
+		err = st_lsm6dsm_i2c_master_write(cdata, reg_addr,
+						1, &new_data, false, false);
+
+	st_lsm6dsm_enable_sensor_hub(cdata, false,
+						ST_MASK_ID_SENSOR_HUB_ASYNC_OP);
+
+	enable_irq(cdata->irq);
+	mutex_unlock(&cdata->i2c_transfer_lock);
+
+	return err;
+}
+
+#ifdef CONFIG_ST_LSM6DSM_IIO_EXT0_LIS3MDL
+static int lis3mdl_initialization(struct lsm6dsm_sensor_data *sdata)
+{
+
+	return st_lsm6dsm_i2c_master_write_data_with_mask(
+				sdata->cdata,
+				ST_LSM6DSM_EXT0_BDU_ADDR,
+				ST_LSM6DSM_EXT0_BDU_MASK, ST_LSM6DSM_EN_BIT);
+}
+#endif /* CONFIG_ST_LSM6DSM_IIO_EXT0_LIS3MDL */
+
+#ifdef CONFIG_ST_LSM6DSM_IIO_EXT0_AKM09911
+static int akm09911_initialization(struct lsm6dsm_sensor_data *sdata)
+{
+	int err; u8 data[ST_LSM6DSM_EXT0_SENSITIVITY_LEN];
+
+	err = st_lsm6dsm_i2c_master_read(sdata->cdata,
+				ST_LSM6DSM_EXT0_SENSITIVITY_ADDR,
+				ST_LSM6DSM_EXT0_SENSITIVITY_LEN,
+				data, true, true, false,
+				st_lsm6dsm_exs_list[0].read_data_len);
+	if (err < 0)
+		return err;
+
+	/* gain expressed in nT/LSB */
+	sdata->c_gain[0] = (((((int)data[0]) * 1000) >> 7) + 1000);
+	sdata->c_gain[1] = (((((int)data[1]) * 1000) >> 7) + 1000);
+	sdata->c_gain[2] = (((((int)data[2]) * 1000) >> 7) + 1000);
+
+	/* gain expressed in G/LSB */
+	sdata->c_gain[0] *= 10;
+	sdata->c_gain[1] *= 10;
+	sdata->c_gain[2] *= 10;
+
+	return 0;
+}
+#endif /* CONFIG_ST_LSM6DSM_IIO_EXT0_AKM09911 */
+
+#ifdef CONFIG_ST_LSM6DSM_IIO_EXT0_AKM09912
+static int akm09912_initialization(struct lsm6dsm_sensor_data *sdata)
+{
+	int err; u8 data[ST_LSM6DSM_EXT0_SENSITIVITY_LEN];
+
+	err = st_lsm6dsm_i2c_master_read(sdata->cdata,
+				ST_LSM6DSM_EXT0_SENSITIVITY_ADDR,
+				ST_LSM6DSM_EXT0_SENSITIVITY_LEN,
+				data, true, true, false,
+				st_lsm6dsm_exs_list[0].read_data_len);
+	if (err < 0)
+		return err;
+
+	/* gain expressed in nT/LSB */
+	sdata->c_gain[0] = (((((int)data[0] - 128) * 500) >> 7) + 1000);
+	sdata->c_gain[1] = (((((int)data[1] - 128) * 500) >> 7) + 1000);
+	sdata->c_gain[2] = (((((int)data[2] - 128) * 500) >> 7) + 1000);
+
+	/* gain expressed in G/LSB */
+	sdata->c_gain[0] *= 10;
+	sdata->c_gain[1] *= 10;
+	sdata->c_gain[2] *= 10;
+
+	return 0;
+}
+#endif /* CONFIG_ST_LSM6DSM_IIO_EXT0_AKM09912 */
+
+#ifdef CONFIG_ST_LSM6DSM_IIO_EXT0_LPS22HB
+static int lps22hb_initialization(struct lsm6dsm_sensor_data *sdata)
+{
+
+	return st_lsm6dsm_i2c_master_write_data_with_mask(
+				sdata->cdata,
+				ST_LSM6DSM_EXT0_BDU_ADDR,
+				ST_LSM6DSM_EXT0_BDU_MASK, ST_LSM6DSM_EN_BIT);
+}
+#endif /* CONFIG_ST_LSM6DSM_IIO_EXT0_LPS22HB */
+
+#ifdef CONFIG_ST_LSM6DSM_IIO_EXT0_LIS2MDL
+static int lis2mdl_initialization(struct lsm6dsm_sensor_data *sdata)
+{
+	int err;
+
+	err = st_lsm6dsm_i2c_master_write_data_with_mask(sdata->cdata,
+						ST_LSM6DSM_EXT0_TEMP_COMP_ADDR,
+						ST_LSM6DSM_EXT0_TEMP_COMP_MASK,
+						1);
+	if (err < 0)
+		return err;
+
+	err = st_lsm6dsm_i2c_master_write_data_with_mask(sdata->cdata,
+						ST_LSM6DSM_EXT0_OFF_CANC_ADDR,
+						ST_LSM6DSM_EXT0_OFF_CANC_MASK,
+						1);
+	if (err < 0)
+		return err;
+
+	return st_lsm6dsm_i2c_master_write_data_with_mask(sdata->cdata,
+						ST_LSM6DSM_EXT0_BDU_ADDR,
+						ST_LSM6DSM_EXT0_BDU_MASK,
+						ST_LSM6DSM_EN_BIT);
+}
+#endif /* CONFIG_ST_LSM6DSM_IIO_EXT0_LIS2MDL */
+
+#ifdef ST_LSM6DSM_EXT0_HAS_SELFTEST
+static ssize_t st_lsm6dsm_i2c_master_sysfs_get_selftest_available(
+		struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "absolute\n");
+}
+
+static ssize_t st_lsm6dsm_i2c_master_sysfs_get_selftest_status(
+		struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int8_t result;
+	char *message;
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct lsm6dsm_sensor_data *sdata = iio_priv(indio_dev);
+
+	mutex_lock(&sdata->cdata->odr_lock);
+	result = sdata->cdata->ext0_selftest_status;
+	mutex_unlock(&sdata->cdata->odr_lock);
+
+	if (result == 0)
+		message = ST_LSM6DSM_SELFTEST_NA_MS;
+	else if (result < 0)
+		message = ST_LSM6DSM_SELFTEST_FAIL_MS;
+	else if (result > 0)
+		message = ST_LSM6DSM_SELFTEST_PASS_MS;
+
+	return sprintf(buf, "%s\n", message);
+}
+
+static ssize_t st_lsm6dsm_i2c_master_sysfs_start_selftest(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	int err;
+	int x_selftest = 0, y_selftest = 0, z_selftest = 0;
+	u8 outdata[8], reg_addr, reg_status = 0, temp_reg_status;
+#ifdef CONFIG_ST_LSM6DSM_IIO_EXT0_LIS3MDL
+	int i, x = 0, y = 0, z = 0;
+	u8 reg_status2 = 0, reg_status3 = 0;
+	u8 reg_addr2, reg_addr3, temp_reg_status2, temp_reg_status3;
+#endif /* CONFIG_ST_LSM6DSM_IIO_EXT0_LIS3MDL */
+#ifdef ST_LSM6DSM_EXT0_IS_AKM
+	u8 temp, sh_config[3], timeout = 0;
+#endif /* ST_LSM6DSM_EXT0_IS_AKM */
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct lsm6dsm_sensor_data *sdata = iio_priv(indio_dev);
+
+	mutex_lock(&sdata->cdata->odr_lock);
+	sdata->cdata->ext0_selftest_status = 0;
+
+	if (sdata->cdata->sensors_enabled > 0) {
+		mutex_unlock(&sdata->cdata->odr_lock);
+		return -EBUSY;
+	}
+
+	if (strncmp(buf, "absolute", size - 2) != 0) {
+		mutex_unlock(&sdata->cdata->odr_lock);
+		return -EINVAL;
+	}
+
+	err = st_lsm6dsm_enable_sensor_hub(sdata->cdata, true, ST_MASK_ID_EXT0);
+	if (err < 0) {
+		mutex_unlock(&sdata->cdata->odr_lock);
+		return err;
+	}
+
+#ifdef CONFIG_ST_LSM6DSM_IIO_EXT0_LIS3MDL
+	reg_addr = ST_LSM6DSM_SELFTEST_ADDR1;
+	temp_reg_status = ST_LSM6DSM_SELFTEST_ADDR1_VALUE;
+	reg_addr2 = ST_LSM6DSM_SELFTEST_ADDR2;
+	temp_reg_status2 = ST_LSM6DSM_SELFTEST_ADDR2_VALUE;
+	reg_addr3 = ST_LSM6DSM_SELFTEST_ADDR3;
+	temp_reg_status3 = ST_LSM6DSM_SELFTEST_ADDR3_VALUE;
+#endif /* CONFIG_ST_LSM6DSM_IIO_EXT0_LIS3MDL */
+
+#ifdef ST_LSM6DSM_EXT0_IS_AKM
+	reg_addr = ST_LSM6DSM_SELFTEST_ADDR;
+	temp_reg_status = ST_LSM6DSM_SELFTEST_ENABLE;
+#endif /* ST_LSM6DSM_EXT0_IS_AKM */
+
+	err = st_lsm6dsm_i2c_master_read(sdata->cdata, reg_addr, 1,
+					&reg_status, false, true, false,
+					st_lsm6dsm_exs_list[0].read_data_len);
+	if (err < 0)
+		goto disable_sensor_hub;
+
+#ifdef ST_LSM6DSM_EXT0_IS_AKM
+	/* SLAVE 1 is disabled for a while, dummy write to wai reg */
+	sh_config[0] = (st_lsm6dsm_exs_list[EXT0_INDEX].i2c_addr << 1) | 0x01;
+	sh_config[1] = st_lsm6dsm_exs_list[EXT0_INDEX].wai.addr;
+	sh_config[2] = 1;
+
+	err = st_lsm6dsm_write_embedded_registers(sdata->cdata,
+					ST_LSM6DSM_SLV1_ADDR_ADDR,
+					sh_config, ARRAY_SIZE(sh_config));
+	if (err < 0)
+		goto disable_sensor_hub;
+
+	/* SLAVE 2 is disabled for a while, dummy read of wai reg */
+	sh_config[0] = (st_lsm6dsm_exs_list[EXT0_INDEX].i2c_addr << 1) | 0x01;
+	sh_config[1] = st_lsm6dsm_exs_list[EXT0_INDEX].wai.addr;
+	sh_config[2] = 1;
+
+	err = st_lsm6dsm_write_embedded_registers(sdata->cdata,
+					ST_LSM6DSM_SLV2_ADDR_ADDR,
+					sh_config, ARRAY_SIZE(sh_config));
+	if (err < 0)
+		goto disable_sensor_hub;
+#endif /* ST_LSM6DSM_EXT0_IS_AKM */
+
+#ifdef CONFIG_ST_LSM6DSM_IIO_EXT0_LIS3MDL
+	err = st_lsm6dsm_i2c_master_read(sdata->cdata, reg_addr2, 1,
+					&reg_status2, false, true, false,
+					st_lsm6dsm_exs_list[0].read_data_len);
+	if (err < 0)
+		goto disable_sensor_hub;
+
+	err = st_lsm6dsm_i2c_master_read(sdata->cdata, reg_addr3, 1,
+					&reg_status3, false, true, false,
+					st_lsm6dsm_exs_list[0].read_data_len);
+	if (err < 0)
+		goto disable_sensor_hub;
+#endif /* CONFIG_ST_LSM6DSM_IIO_EXT0_LIS3MDL */
+
+	err = st_lsm6dsm_i2c_master_write(sdata->cdata, reg_addr, 1,
+					&temp_reg_status, false, true);
+	if (err < 0)
+		goto disable_sensor_hub;
+
+#ifdef CONFIG_ST_LSM6DSM_IIO_EXT0_LIS3MDL
+	err = st_lsm6dsm_i2c_master_write(sdata->cdata, reg_addr2, 1,
+					&temp_reg_status2, false, true);
+	if (err < 0)
+		goto restore_status_reg;
+
+	err = st_lsm6dsm_i2c_master_write(sdata->cdata, reg_addr3, 1,
+					&temp_reg_status3, false, true);
+	if (err < 0)
+		goto restore_status_reg2;
+
+	/* get data with selftest disabled */
+	msleep(100);
+
+	for (i = 0; i < 10; i++) {
+		err = sdata->cdata->tf->read(sdata->cdata, sdata->data_out_reg,
+			st_lsm6dsm_exs_list[0].read_data_len, outdata, true);
+		if (err < 0) {
+			i--;
+			continue;
+		}
+
+		x += ((s16)*(u16 *)&outdata[0]) / 10;
+		y += ((s16)*(u16 *)&outdata[2]) / 10;
+		z += ((s16)*(u16 *)&outdata[4]) / 10;
+
+		msleep((1000U / sdata->cdata->trigger_odr) + 2);
+	}
+
+	temp_reg_status = ST_LSM6DSM_SELFTEST_ENABLE;
+
+	err = st_lsm6dsm_i2c_master_write(sdata->cdata, reg_addr, 1,
+					&temp_reg_status, false, true);
+	if (err < 0)
+		goto restore_status_reg3;
+
+	/* get data with selftest disabled */
+	msleep(100);
+
+	for (i = 0; i < 10; i++) {
+		err = sdata->cdata->tf->read(sdata->cdata, sdata->data_out_reg,
+			st_lsm6dsm_exs_list[0].read_data_len, outdata, true);
+		if (err < 0) {
+			i--;
+			continue;
+		}
+
+		x_selftest += ((s16)*(u16 *)&outdata[0]) / 10;
+		y_selftest += ((s16)*(u16 *)&outdata[2]) / 10;
+		z_selftest += ((s16)*(u16 *)&outdata[4]) / 10;
+
+		msleep((1000U / sdata->cdata->trigger_odr) + 2);
+	}
+
+	err = st_lsm6dsm_i2c_master_write(sdata->cdata, reg_addr3, 1,
+						&reg_status3, false, true);
+	if (err < 0)
+		goto restore_status_reg3;
+
+	err = st_lsm6dsm_i2c_master_write(sdata->cdata, reg_addr2, 1,
+						&reg_status2, false, true);
+	if (err < 0)
+		goto restore_status_reg2;
+
+	err = st_lsm6dsm_i2c_master_write(sdata->cdata, reg_addr, 1,
+						&reg_status, false, true);
+	if (err < 0)
+		goto restore_status_reg;
+
+	err = st_lsm6dsm_enable_sensor_hub(sdata->cdata,
+						false, ST_MASK_ID_EXT0);
+	if (err < 0)
+		goto disable_sensor_hub;
+
+	if ((abs(x_selftest - x) < ST_LSM6DSM_SELFTEST_EXT0_MIN) ||
+			(abs(x_selftest - x) > ST_LSM6DSM_SELFTEST_EXT0_MAX)) {
+		sdata->cdata->ext0_selftest_status = -1;
+		mutex_unlock(&sdata->cdata->odr_lock);
+		return size;
+	}
+
+	if ((abs(y_selftest - y) < ST_LSM6DSM_SELFTEST_EXT0_MIN) ||
+			(abs(y_selftest - y) > ST_LSM6DSM_SELFTEST_EXT0_MAX)) {
+		sdata->cdata->ext0_selftest_status = -1;
+		mutex_unlock(&sdata->cdata->odr_lock);
+		return size;
+	}
+
+	if ((abs(z_selftest - z) < ST_LSM6DSM_SELFTEST_EXT0_MIN_Z) ||
+			(abs(z_selftest - z) > ST_LSM6DSM_SELFTEST_EXT0_MAX_Z)) {
+		sdata->cdata->ext0_selftest_status = -1;
+		mutex_unlock(&sdata->cdata->odr_lock);
+		return size;
+	}
+#endif /* CONFIG_ST_LSM6DSM_IIO_EXT0_LIS3MDL */
+
+#ifdef ST_LSM6DSM_EXT0_IS_AKM
+	do {
+		msleep(1000U / sdata->cdata->trigger_odr);
+
+		err = st_lsm6dsm_i2c_master_read(sdata->cdata,
+					ST_LSM6DSM_SELFTEST_STATUS_REG, 1,
+					&temp, false, true, false, 1);
+		if (err < 0)
+			goto restore_status_reg;
+
+		timeout++;
+	} while (((temp & 0x01) == 0) && (timeout < 5));
+
+	if (timeout >= 5) {
+		err = -EINVAL;
+		goto restore_status_reg;
+	}
+
+	err = st_lsm6dsm_i2c_master_read(sdata->cdata,
+			st_lsm6dsm_exs_list[0].data.channels[0].address,
+			st_lsm6dsm_exs_list[0].read_data_len,
+			outdata, false, true, true, 1);
+	if (err < 0)
+		goto restore_status_reg;
+
+#ifdef ST_LSM6DSM_EXT0_IS_AKM
+	/* SLAVE 2 recovering */
+	sh_config[0] = (st_lsm6dsm_exs_list[EXT0_INDEX].i2c_addr << 1) | 0x01;
+	sh_config[1] = st_lsm6dsm_exs_list[0].data.channels[0].address;
+	sh_config[2] = st_lsm6dsm_exs_list[0].read_data_len;
+
+	err = st_lsm6dsm_write_embedded_registers(sdata->cdata,
+					ST_LSM6DSM_SLV1_ADDR_ADDR,
+					sh_config, ARRAY_SIZE(sh_config));
+	if (err < 0)
+		goto restore_status_reg;
+#endif /* ST_LSM6DSM_EXT0_IS_AKM */
+
+	err = st_lsm6dsm_i2c_master_write(sdata->cdata, reg_addr, 1,
+						&reg_status, false, true);
+	if (err < 0)
+		goto restore_status_reg;
+
+	err = st_lsm6dsm_enable_sensor_hub(sdata->cdata,
+						false, ST_MASK_ID_EXT0);
+	if (err < 0)
+		goto disable_sensor_hub;
+
+	x_selftest = ((s16)*(u16 *)&outdata[0]);
+	y_selftest = ((s16)*(u16 *)&outdata[2]);
+	z_selftest = ((s16)*(u16 *)&outdata[4]);
+
+#if defined(CONFIG_ST_LSM6DSM_IIO_EXT0_AKM09912) || \
+			defined(CONFIG_ST_LSM6DSM_IIO_EXT0_AKM09911)
+	x_selftest *= sdata->c_gain[0];
+	y_selftest *= sdata->c_gain[1];
+	z_selftest *= sdata->c_gain[2];
+
+	x_selftest /= 10000;
+	y_selftest /= 10000;
+	z_selftest /= 10000;
+#endif /* CONFIG_ST_LSM6DSM_IIO_EXT0_AKM0991X */
+
+	if ((x_selftest < ST_LSM6DSM_SELFTEST_EXT0_MIN) ||
+			(x_selftest > ST_LSM6DSM_SELFTEST_EXT0_MAX)) {
+		sdata->cdata->ext0_selftest_status = -1;
+		mutex_unlock(&sdata->cdata->odr_lock);
+		return size;
+	}
+
+	if ((y_selftest < ST_LSM6DSM_SELFTEST_EXT0_MIN) ||
+			(y_selftest > ST_LSM6DSM_SELFTEST_EXT0_MAX)) {
+		sdata->cdata->ext0_selftest_status = -1;
+		mutex_unlock(&sdata->cdata->odr_lock);
+		return size;
+	}
+
+	if ((z_selftest < ST_LSM6DSM_SELFTEST_EXT0_MIN_Z) ||
+			(z_selftest > ST_LSM6DSM_SELFTEST_EXT0_MAX_Z)) {
+		sdata->cdata->ext0_selftest_status = -1;
+		mutex_unlock(&sdata->cdata->odr_lock);
+		return size;
+	}
+#endif /* ST_LSM6DSM_EXT0_IS_AKM */
+
+	sdata->cdata->ext0_selftest_status = 1;
+
+	mutex_unlock(&sdata->cdata->odr_lock);
+
+	return size;
+
+#ifdef CONFIG_ST_LSM6DSM_IIO_EXT0_LIS3MDL
+restore_status_reg3:
+	st_lsm6dsm_i2c_master_write(sdata->cdata, reg_addr3, 1,
+						&reg_status3, false, true);
+restore_status_reg2:
+	st_lsm6dsm_i2c_master_write(sdata->cdata, reg_addr2, 1,
+						&reg_status2, false, true);
+#endif /* CONFIG_ST_LSM6DSM_IIO_EXT0_LIS3MDL */
+restore_status_reg:
+	st_lsm6dsm_i2c_master_write(sdata->cdata, reg_addr, 1,
+						&reg_status, false, true);
+disable_sensor_hub:
+	st_lsm6dsm_enable_sensor_hub(sdata->cdata, false, ST_MASK_ID_EXT0);
+	mutex_unlock(&sdata->cdata->odr_lock);
+	return err;
+}
+#endif /* ST_LSM6DSM_EXT0_HAS_SELFTEST	*/
+
+static int st_lsm6dsm_i2c_master_set_odr(struct lsm6dsm_sensor_data *sdata,
+						unsigned int odr, bool force)
+{
+	int i, err, err2;
+	u8 value, mask, addr;
+	bool scan_odr = true;
+	unsigned int current_odr = sdata->cdata->v_odr[sdata->sindex];
+	unsigned int current_hw_odr = sdata->cdata->hw_odr[sdata->sindex];
+
+	if (odr == 0) {
+		if (force)
+			scan_odr = false;
+		else
+			return -EINVAL;
+	}
+	if (scan_odr) {
+		switch (odr) {
+		case 13:
+		case 26:
+		case 52:
+		case 104:
+			break;
+		default:
+			return -EINVAL;
+		}
+
+		for (i = 0; i < ST_LSM6DSM_ODR_LIST_NUM; i++) {
+			if (st_lsm6dsm_exs_list[0].odr.odr_avl[i].hz >= odr)
+				break;
+		}
+		if (i == ST_LSM6DSM_ODR_LIST_NUM)
+			i--;
+
+		if (!force) {
+			if ((sdata->cdata->sensors_enabled & BIT(sdata->sindex)) == 0) {
+				sdata->cdata->v_odr[sdata->sindex] = odr;
+				return 0;
+			}
+		}
+
+		addr = st_lsm6dsm_exs_list[0].odr.addr;
+		mask = st_lsm6dsm_exs_list[0].odr.mask;
+		value = st_lsm6dsm_exs_list[0].odr.odr_avl[i].value;
+	} else {
+		if (st_lsm6dsm_exs_list[0].power.isodr) {
+			addr = st_lsm6dsm_exs_list[0].power.addr;
+			mask = st_lsm6dsm_exs_list[0].power.mask;
+			value = st_lsm6dsm_exs_list[0].power.off_value;
+		} else
+			goto skip_i2c_write;
+	}
+
+	sdata->cdata->samples_to_discard[ST_MASK_ID_EXT0] =
+				st_lsm6dsm_exs_list[0].samples_to_discard;
+
+	err = st_lsm6dsm_i2c_master_write_data_with_mask(sdata->cdata,
+							addr, mask, value);
+	if (err < 0)
+		return err;
+
+skip_i2c_write:
+	if (odr == 0)
+		sdata->cdata->hw_odr[sdata->sindex] = 0;
+	else
+		sdata->cdata->hw_odr[sdata->sindex] = odr;
+
+	if (!force) {
+		sdata->cdata->v_odr[sdata->sindex] = odr;
+
+		err = st_lsm6dsm_enable_sensor_hub(sdata->cdata,
+							true, ST_MASK_ID_EXT0);
+		if (err < 0) {
+			sdata->cdata->hw_odr[sdata->sindex] = current_hw_odr;
+			sdata->cdata->v_odr[sdata->sindex] = current_odr;
+			do {
+				err2 = st_lsm6dsm_enable_sensor_hub(sdata->cdata,
+							false, ST_MASK_ID_EXT0);
+				msleep(200);
+			} while (err2 < 0);
+
+			return err;
+		}
+	}
+
+	return 0;
+}
+
+static int st_lsm6dsm_i2c_master_set_enable(
+			struct lsm6dsm_sensor_data *sdata, bool enable, bool buffer)
+{
+	int err;
+	u8 reg_value;
+
+	/* If odr != power this part should enable/disable sensor */
+	if (!st_lsm6dsm_exs_list[0].power.isodr) {
+		if (enable)
+			reg_value = st_lsm6dsm_exs_list[0].power.on_value;
+		else
+			reg_value = st_lsm6dsm_exs_list[0].power.off_value;
+
+		err = st_lsm6dsm_i2c_master_write_data_with_mask(sdata->cdata,
+					st_lsm6dsm_exs_list[0].power.addr,
+					st_lsm6dsm_exs_list[0].power.mask,
+					reg_value);
+		if (err < 0)
+			return err;
+	}
+
+	err =  st_lsm6dsm_enable_sensor_hub(sdata->cdata,
+						enable, ST_MASK_ID_EXT0);
+	if (err < 0)
+		return err;
+
+	err = st_lsm6dsm_i2c_master_set_odr(sdata,
+			enable ? sdata->cdata->v_odr[sdata->sindex] : 0, true);
+	if (err < 0)
+		goto disable_sensorhub;
+
+	if (buffer) {
+		err = st_lsm6dsm_set_drdy_irq(sdata, enable);
+		if (err < 0)
+			goto restore_odr;
+
+		if (enable)
+			sdata->cdata->sensors_enabled |= BIT(sdata->sindex);
+		else
+			sdata->cdata->sensors_enabled &= ~BIT(sdata->sindex);
+	}
+
+	return 0;
+
+restore_odr:
+	st_lsm6dsm_i2c_master_set_odr(sdata,
+			enable ? 0 : sdata->cdata->v_odr[sdata->sindex], true);
+disable_sensorhub:
+	st_lsm6dsm_enable_sensor_hub(sdata->cdata, !enable, ST_MASK_ID_EXT0);
+
+	return err;
+}
+
+static int st_lsm6dsm_i2c_master_read_raw(struct iio_dev *indio_dev,
+		struct iio_chan_spec const *ch, int *val, int *val2, long mask)
+{
+	int err;
+	u8 outdata[(ch->scan_type.storagebits >> 3)];
+	struct lsm6dsm_sensor_data *sdata = iio_priv(indio_dev);
+
+	switch (mask) {
+	case IIO_CHAN_INFO_RAW:
+		mutex_lock(&indio_dev->mlock);
+
+		if (indio_dev->currentmode == INDIO_BUFFER_TRIGGERED) {
+			mutex_unlock(&indio_dev->mlock);
+			return -EBUSY;
+		}
+
+		mutex_lock(&sdata->cdata->odr_lock);
+
+		err = st_lsm6dsm_i2c_master_set_enable(sdata, true, false);
+		if (err < 0) {
+			mutex_unlock(&sdata->cdata->odr_lock);
+			mutex_unlock(&indio_dev->mlock);
+			return err;
+		}
+
+		st_lsm6dsm_master_wait_completed(sdata->cdata);
+
+		msleep((1000U / sdata->cdata->trigger_odr) + 2);
+
+		err = sdata->cdata->tf->read(sdata->cdata, sdata->data_out_reg,
+				ch->scan_type.storagebits >> 3, outdata, true);
+		if (err < 0) {
+			st_lsm6dsm_i2c_master_set_enable(sdata, false, false);
+			mutex_unlock(&sdata->cdata->odr_lock);
+			mutex_unlock(&indio_dev->mlock);
+			return err;
+		}
+
+		err = st_lsm6dsm_i2c_master_set_enable(sdata, false, false);
+		if (err < 0) {
+			mutex_unlock(&sdata->cdata->odr_lock);
+			mutex_unlock(&indio_dev->mlock);
+			return err;
+		}
+
+		if ((ch->scan_type.storagebits >> 3) > 2)
+			*val = (s32)get_unaligned_le32(outdata);
+		else
+			*val = (s16)get_unaligned_le16(outdata);
+
+		*val = *val >> ch->scan_type.shift;
+
+		mutex_unlock(&sdata->cdata->odr_lock);
+		mutex_unlock(&indio_dev->mlock);
+
+		return IIO_VAL_INT;
+	case IIO_CHAN_INFO_SCALE:
+		*val = 0;
+		*val2 = sdata->c_gain[ch->scan_index];
+
+		if (ch->type == IIO_TEMP) {
+			*val = 1;
+			*val2 = 0;
+			return IIO_VAL_INT;
+		}
+
+		return IIO_VAL_INT_PLUS_MICRO;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int st_lsm6dsm_i2c_master_buffer_preenable(struct iio_dev *indio_dev)
+{
+#ifdef CONFIG_ST_LSM6DSM_XL_DATA_INJECTION
+	struct lsm6dsm_sensor_data *sdata = iio_priv(indio_dev);
+
+	if (sdata->cdata->injection_mode)
+		return -EBUSY;
+#endif /* CONFIG_ST_LSM6DSM_XL_DATA_INJECTION */
+
+	return 0;
+}
+
+static int st_lsm6dsm_i2c_master_buffer_postenable(struct iio_dev *indio_dev)
+{
+	int err;
+	struct lsm6dsm_sensor_data *sdata = iio_priv(indio_dev);
+
+	sdata->cdata->fifo_output[sdata->sindex].initialized = false;
+
+	if ((sdata->cdata->hwfifo_enabled[ST_MASK_ID_EXT0]) &&
+		(indio_dev->buffer->length < 2 * ST_LSM6DSM_MAX_FIFO_LENGHT))
+		return -EINVAL;
+
+	err = iio_triggered_buffer_postenable(indio_dev);
+	if (err < 0)
+		return err;
+
+	mutex_lock(&sdata->cdata->odr_lock);
+
+	err = st_lsm6dsm_i2c_master_set_enable(sdata, true, true);
+	if (err < 0) {
+		mutex_unlock(&sdata->cdata->odr_lock);
+		return err;
+	}
+
+	mutex_unlock(&sdata->cdata->odr_lock);
+
+	return 0;
+}
+
+static int st_lsm6dsm_i2c_master_buffer_predisable(struct iio_dev *indio_dev)
+{
+	return iio_triggered_buffer_predisable(indio_dev);
+}
+
+static int st_lsm6dsm_i2c_master_buffer_postdisable(struct iio_dev *indio_dev)
+{
+	int err;
+	struct lsm6dsm_sensor_data *sdata = iio_priv(indio_dev);
+
+	mutex_lock(&sdata->cdata->odr_lock);
+
+	err = st_lsm6dsm_i2c_master_set_enable(sdata, false, true);
+
+	mutex_unlock(&sdata->cdata->odr_lock);
+
+	return err < 0 ? err : 0;
+}
+
+static const struct iio_trigger_ops st_lsm6dsm_i2c_master_trigger_ops = {
+	.set_trigger_state = &st_lsm6dsm_trig_set_state,
+};
+
+int st_lsm6dsm_i2c_master_allocate_trigger(struct lsm6dsm_data *cdata)
+{
+	int err;
+
+	cdata->trig[ST_MASK_ID_EXT0] = iio_trigger_alloc("%s-trigger",
+				cdata->indio_dev[ST_MASK_ID_EXT0]->name);
+	if (!cdata->trig[ST_MASK_ID_EXT0]) {
+		dev_err(cdata->dev, "failed to allocate iio trigger.\n");
+		return -ENOMEM;
+	}
+
+	iio_trigger_set_drvdata(cdata->trig[ST_MASK_ID_EXT0],
+					cdata->indio_dev[ST_MASK_ID_EXT0]);
+	cdata->trig[ST_MASK_ID_EXT0]->ops = &st_lsm6dsm_i2c_master_trigger_ops;
+	cdata->trig[ST_MASK_ID_EXT0]->dev.parent = cdata->dev;
+
+	err = iio_trigger_register(cdata->trig[ST_MASK_ID_EXT0]);
+	if (err < 0) {
+		dev_err(cdata->dev, "failed to register iio trigger.\n");
+		goto deallocate_trigger;
+	}
+
+	cdata->indio_dev[ST_MASK_ID_EXT0]->trig = cdata->trig[ST_MASK_ID_EXT0];
+
+	return 0;
+
+deallocate_trigger:
+	iio_trigger_free(cdata->trig[ST_MASK_ID_EXT0]);
+	return err;
+}
+
+static void st_lsm6dsm_i2c_master_deallocate_trigger(struct lsm6dsm_data *cdata)
+{
+	iio_trigger_unregister(cdata->trig[ST_MASK_ID_EXT0]);
+}
+
+static const struct iio_buffer_setup_ops st_lsm6dsm_i2c_master_buffer_setup_ops = {
+	.preenable = &st_lsm6dsm_i2c_master_buffer_preenable,
+	.postenable = &st_lsm6dsm_i2c_master_buffer_postenable,
+	.predisable = &st_lsm6dsm_i2c_master_buffer_predisable,
+	.postdisable = &st_lsm6dsm_i2c_master_buffer_postdisable,
+};
+
+static inline irqreturn_t st_lsm6dsm_i2c_master_handler_empty(int irq, void *p)
+{
+	return IRQ_HANDLED;
+}
+
+static int st_lsm6dsm_i2c_master_allocate_buffer(struct lsm6dsm_data *cdata)
+{
+	return iio_triggered_buffer_setup(cdata->indio_dev[ST_MASK_ID_EXT0],
+				&st_lsm6dsm_i2c_master_handler_empty, NULL,
+				&st_lsm6dsm_i2c_master_buffer_setup_ops);
+}
+
+static void st_lsm6dsm_i2c_master_deallocate_buffer(struct lsm6dsm_data *cdata)
+{
+	iio_triggered_buffer_cleanup(cdata->indio_dev[ST_MASK_ID_EXT0]);
+}
+
+static int st_lsm6dsm_i2c_master_send_sensor_hub_parameters(
+					struct lsm6dsm_sensor_data *sdata)
+{
+	int err;
+	u8 sh_config[3];
+
+	/* SLAVE 0 is used by write */
+	sh_config[0] = (st_lsm6dsm_exs_list[EXT0_INDEX].i2c_addr << 1) | ST_LSM6DSM_EN_BIT;
+	sh_config[1] = st_lsm6dsm_exs_list[EXT0_INDEX].wai.addr;
+	sh_config[2] = 0x20;
+
+	err = st_lsm6dsm_write_embedded_registers(sdata->cdata,
+					ST_LSM6DSM_SLV0_ADDR_ADDR, sh_config,
+					ARRAY_SIZE(sh_config));
+	if (err < 0)
+		return err;
+
+	/* SLAVE 1 is used to read output data */
+	sh_config[0] = (st_lsm6dsm_exs_list[EXT0_INDEX].i2c_addr << 1) | ST_LSM6DSM_EN_BIT;
+	sh_config[1] = st_lsm6dsm_exs_list[0].data.channels[0].address;
+	sh_config[2] = st_lsm6dsm_exs_list[0].read_data_len;
+
+	err = st_lsm6dsm_write_embedded_registers(sdata->cdata,
+					ST_LSM6DSM_SLV1_ADDR_ADDR,
+					sh_config, ARRAY_SIZE(sh_config));
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+static int st_lsm6dsm_i2c_master_init_sensor(struct lsm6dsm_sensor_data *sdata)
+{
+	int err, ext_num = 0;
+
+	err = st_lsm6dsm_i2c_master_send_sensor_hub_parameters(sdata);
+	if (err < 0)
+		return err;
+
+	sdata->c_gain[0] = st_lsm6dsm_exs_list[ext_num].gain;
+	sdata->c_gain[1] = st_lsm6dsm_exs_list[ext_num].gain;
+	sdata->c_gain[2] = st_lsm6dsm_exs_list[ext_num].gain;
+
+	if ((st_lsm6dsm_exs_list[ext_num].power.addr ==
+				st_lsm6dsm_exs_list[ext_num].odr.addr) &&
+			(st_lsm6dsm_exs_list[ext_num].power.mask ==
+					st_lsm6dsm_exs_list[ext_num].odr.mask))
+		st_lsm6dsm_exs_list[ext_num].power.isodr = true;
+	else
+		st_lsm6dsm_exs_list[ext_num].power.isodr = false;
+
+	err = st_lsm6dsm_i2c_master_write_data_with_mask(sdata->cdata,
+					st_lsm6dsm_exs_list[ext_num].reset.addr,
+					st_lsm6dsm_exs_list[ext_num].reset.mask,
+					ST_LSM6DSM_EN_BIT);
+	if (err < 0)
+		return err;
+
+	usleep_range(200, 1000);
+
+	if (st_lsm6dsm_exs_list[ext_num].fullscale.addr > 0) {
+		err = st_lsm6dsm_i2c_master_write_data_with_mask(sdata->cdata,
+			st_lsm6dsm_exs_list[ext_num].fullscale.addr,
+			st_lsm6dsm_exs_list[ext_num].fullscale.mask,
+			st_lsm6dsm_exs_list[ext_num].fullscale.def_value);
+		if (err < 0)
+			return err;
+	}
+
+	if (st_lsm6dsm_exs_list[0].cf.boot_initialization != NULL) {
+		err = st_lsm6dsm_exs_list[0].cf.boot_initialization(sdata);
+		if (err < 0)
+			return err;
+	}
+
+	err = st_lsm6dsm_i2c_master_set_enable(sdata, false, false);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+static int st_lsm6dsm_i2c_master_allocate_device(struct lsm6dsm_data *cdata)
+{
+	int err;
+	struct lsm6dsm_sensor_data *sdata_ext;
+
+	sdata_ext = iio_priv(cdata->indio_dev[ST_MASK_ID_EXT0]);
+	sdata_ext->num_data_channels =
+				st_lsm6dsm_exs_list[0].num_data_channels;
+
+	cdata->indio_dev[ST_MASK_ID_EXT0]->name = kasprintf(GFP_KERNEL,
+				"%s_%s", cdata->name,
+				st_lsm6dsm_exs_list[0].data.suffix_name);
+
+	cdata->indio_dev[ST_MASK_ID_EXT0]->info =
+				st_lsm6dsm_exs_list[0].data.info;
+	cdata->indio_dev[ST_MASK_ID_EXT0]->channels =
+				st_lsm6dsm_exs_list[0].data.channels;
+	cdata->indio_dev[ST_MASK_ID_EXT0]->num_channels =
+				st_lsm6dsm_exs_list[0].data.num_channels;
+
+	cdata->indio_dev[ST_MASK_ID_EXT0]->modes = INDIO_DIRECT_MODE;
+	sdata_ext->data_out_reg = ST_LSM6DSM_SLV0_OUT_ADDR;
+	err = st_lsm6dsm_i2c_master_init_sensor(sdata_ext);
+	if (err < 0)
+		goto iio_device_free;
+
+	err = st_lsm6dsm_i2c_master_allocate_buffer(cdata);
+	if (err < 0)
+		goto iio_device_free;
+
+	err = st_lsm6dsm_i2c_master_allocate_trigger(cdata);
+	if (err < 0)
+		goto iio_deallocate_buffer;
+
+	err = iio_device_register(cdata->indio_dev[ST_MASK_ID_EXT0]);
+	if (err < 0)
+		goto iio_deallocate_trigger;
+
+	return 0;
+
+iio_deallocate_trigger:
+	st_lsm6dsm_i2c_master_deallocate_trigger(cdata);
+iio_deallocate_buffer:
+	st_lsm6dsm_i2c_master_deallocate_buffer(cdata);
+iio_device_free:
+	iio_device_free(cdata->indio_dev[ST_MASK_ID_EXT0]);
+
+	return err;
+}
+
+static void st_lsm6dsm_i2c_master_deallocate_device(struct lsm6dsm_data *cdata)
+{
+	iio_device_unregister(cdata->indio_dev[ST_MASK_ID_EXT0]);
+	st_lsm6dsm_i2c_master_deallocate_trigger(cdata);
+	st_lsm6dsm_i2c_master_deallocate_buffer(cdata);
+	iio_device_free(cdata->indio_dev[ST_MASK_ID_EXT0]);
+}
+
+int st_lsm6dsm_i2c_master_probe(struct lsm6dsm_data *cdata)
+{
+	int err, i;
+	u8 sh_config[3];
+	u8 wai, i2c_address;
+	struct lsm6dsm_sensor_data *sdata_ext;
+
+	mutex_init(&cdata->i2c_transfer_lock);
+	cdata->v_odr[ST_MASK_ID_EXT0] = 13;
+	cdata->ext0_available = false;
+	cdata->ext0_selftest_status = false;
+
+#ifdef CONFIG_ST_LSM6DSM_ENABLE_INTERNAL_PULLUP
+	err = st_lsm6dsm_write_data_with_mask(cdata,
+					ST_LSM6DSM_INTER_PULLUP_ADDR,
+					ST_LSM6DSM_INTER_PULLUP_MASK,
+					ST_LSM6DSM_EN_BIT, true);
+	if (err < 0)
+		return err;
+#endif /* CONFIG_ST_LSM6DSM_ENABLE_INTERNAL_PULLUP */
+
+	err = st_lsm6dsm_write_data_with_mask(cdata,
+					ST_LSM6DSM_FUNC_MAX_RATE_ADDR,
+					ST_LSM6DSM_FUNC_MAX_RATE_MASK, 1, true);
+	if (err < 0)
+		return err;
+
+	cdata->indio_dev[ST_MASK_ID_EXT0] = iio_device_alloc(sizeof(*sdata_ext));
+	if (!cdata->indio_dev[ST_MASK_ID_EXT0])
+		return -ENOMEM;
+
+	sdata_ext = iio_priv(cdata->indio_dev[ST_MASK_ID_EXT0]);
+	sdata_ext->cdata = cdata;
+	sdata_ext->sindex = ST_MASK_ID_EXT0;
+	cdata->samples_to_discard_2[ST_MASK_ID_EXT0] = 0;
+	sdata_ext->cdata->fifo_output[ST_MASK_ID_EXT0].sip = 0;
+	sdata_ext->cdata->fifo_output[ST_MASK_ID_EXT0].timestamp_p = 0;
+
+	for (i = 0; i < 2; i++) {
+		if (i == 0)
+			i2c_address = ST_LSM6DSM_EXT0_ADDR;
+		else
+			i2c_address = ST_LSM6DSM_EXT0_ADDR2;
+
+		/* to check if sensor is available use SLAVE0 first time */
+		sh_config[0] = (i2c_address << 1) | 0x01;
+		sh_config[1] = st_lsm6dsm_exs_list[EXT0_INDEX].wai.addr;
+		sh_config[2] = 0x01;
+
+		err = st_lsm6dsm_write_embedded_registers(cdata,
+					ST_LSM6DSM_SLV0_ADDR_ADDR, sh_config,
+					ARRAY_SIZE(sh_config));
+		if (err < 0)
+			return err;
+
+		err = st_lsm6dsm_enable_sensor_hub(cdata, true,
+					ST_MASK_ID_SENSOR_HUB_ASYNC_OP);
+		if (err < 0)
+			return err;
+
+		msleep(100);
+
+		st_lsm6dsm_master_wait_completed(cdata);
+
+		err = cdata->tf->read(cdata, ST_LSM6DSM_SLV0_OUT_ADDR,
+								1, &wai, true);
+		if (err < 0) {
+			err = st_lsm6dsm_enable_sensor_hub(cdata, false,
+					ST_MASK_ID_SENSOR_HUB_ASYNC_OP);
+			if (err < 0)
+				return err;
+
+			continue;
+		}
+
+		err = st_lsm6dsm_enable_sensor_hub(cdata, false,
+					ST_MASK_ID_SENSOR_HUB_ASYNC_OP);
+		if (err < 0)
+			return err;
+
+		st_lsm6dsm_exs_list[EXT0_INDEX].i2c_addr = i2c_address;
+		break;
+	}
+	if (i == 2)
+		goto ext0_sensor_not_available;
+
+	/* after wai check SLAVE0 is used for write, SLAVE1 for async read
+	   and SLAVE2 to read sensor output data */
+
+	if (wai != st_lsm6dsm_exs_list[EXT0_INDEX].wai.def_value) {
+		dev_err(cdata->dev, "wai value of external sensor 0 mismatch\n");
+		return err;
+	}
+
+	err = st_lsm6dsm_i2c_master_allocate_device(cdata);
+	if (err < 0)
+		return err;
+
+	cdata->ext0_available = true;
+
+	return 0;
+
+ext0_sensor_not_available:
+	dev_err(cdata->dev, "external sensor 0 not available\n");
+
+	return err;
+}
+EXPORT_SYMBOL(st_lsm6dsm_i2c_master_probe);
+
+int st_lsm6dsm_i2c_master_exit(struct lsm6dsm_data *cdata)
+{
+	if (cdata->ext0_available)
+		st_lsm6dsm_i2c_master_deallocate_device(cdata);
+
+	return 0;
+}
+EXPORT_SYMBOL(st_lsm6dsm_i2c_master_exit);
+
+MODULE_AUTHOR("Denis Ciocca <denis.ciocca@st.com>");
+MODULE_DESCRIPTION("STMicroelectronics lsm6dsm i2c master driver");
+MODULE_LICENSE("GPL v2");
diff -Naur A/drivers/iio/imu/st_lsm6dsm/st_lsm6dsm_spi.c B/drivers/iio/imu/st_lsm6dsm/st_lsm6dsm_spi.c
--- A/drivers/iio/imu/st_lsm6dsm/st_lsm6dsm_spi.c	1970-01-01 05:30:00.000000000 +0530
+++ B/drivers/iio/imu/st_lsm6dsm/st_lsm6dsm_spi.c	2022-08-09 13:36:04.270484049 +0530
@@ -0,0 +1,199 @@
+/*
+ * STMicroelectronics lsm6dsm spi driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Denis Ciocca <denis.ciocca@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/of.h>
+#include <linux/iio/iio.h>
+
+#include "st_lsm6dsm.h"
+
+#define ST_SENSORS_SPI_READ			0x80
+
+static int st_lsm6dsm_spi_read(struct lsm6dsm_data *cdata,
+				u8 reg_addr, int len, u8 *data, bool b_lock)
+{
+	int err;
+
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = cdata->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = cdata->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+	if (b_lock)
+		mutex_lock(&cdata->bank_registers_lock);
+
+	mutex_lock(&cdata->tb.buf_lock);
+	cdata->tb.tx_buf[0] = reg_addr | ST_SENSORS_SPI_READ;
+
+	err = spi_sync_transfer(to_spi_device(cdata->dev),
+						xfers, ARRAY_SIZE(xfers));
+	if (err)
+		goto acc_spi_read_error;
+
+	memcpy(data, cdata->tb.rx_buf, len*sizeof(u8));
+	mutex_unlock(&cdata->tb.buf_lock);
+	if (b_lock)
+		mutex_unlock(&cdata->bank_registers_lock);
+
+	return len;
+
+acc_spi_read_error:
+	mutex_unlock(&cdata->tb.buf_lock);
+	if (b_lock)
+		mutex_unlock(&cdata->bank_registers_lock);
+
+	return err;
+}
+
+static int st_lsm6dsm_spi_write(struct lsm6dsm_data *cdata,
+				u8 reg_addr, int len, u8 *data, bool b_lock)
+{
+	int err;
+
+	struct spi_transfer xfers = {
+		.tx_buf = cdata->tb.tx_buf,
+		.bits_per_word = 8,
+		.len = len + 1,
+	};
+
+	if (len >= ST_LSM6DSM_RX_MAX_LENGTH)
+		return -ENOMEM;
+
+	if (b_lock)
+		mutex_lock(&cdata->bank_registers_lock);
+
+	mutex_lock(&cdata->tb.buf_lock);
+	cdata->tb.tx_buf[0] = reg_addr;
+
+	memcpy(&cdata->tb.tx_buf[1], data, len);
+
+	err = spi_sync_transfer(to_spi_device(cdata->dev), &xfers, 1);
+	mutex_unlock(&cdata->tb.buf_lock);
+	if (b_lock)
+		mutex_unlock(&cdata->bank_registers_lock);
+
+	return err;
+}
+
+static const struct st_lsm6dsm_transfer_function st_lsm6dsm_tf_spi = {
+	.write = st_lsm6dsm_spi_write,
+	.read = st_lsm6dsm_spi_read,
+};
+
+static int st_lsm6dsm_spi_probe(struct spi_device *spi)
+{
+	int err;
+	struct lsm6dsm_data *cdata;
+
+	cdata = kmalloc(sizeof(*cdata), GFP_KERNEL);
+	if (!cdata)
+		return -ENOMEM;
+
+	cdata->dev = &spi->dev;
+	cdata->name = spi->modalias;
+	spi_set_drvdata(spi, cdata);
+
+	cdata->tf = &st_lsm6dsm_tf_spi;
+
+	err = st_lsm6dsm_common_probe(cdata, spi->irq);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(cdata);
+	return err;
+}
+
+static int st_lsm6dsm_spi_remove(struct spi_device *spi)
+{
+	struct lsm6dsm_data *cdata = spi_get_drvdata(spi);
+
+	st_lsm6dsm_common_remove(cdata, spi->irq);
+	kfree(cdata);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int st_lsm6dsm_suspend(struct device *dev)
+{
+	struct lsm6dsm_data *cdata = spi_get_drvdata(to_spi_device(dev));
+
+	return st_lsm6dsm_common_suspend(cdata);
+}
+
+static int st_lsm6dsm_resume(struct device *dev)
+{
+	struct lsm6dsm_data *cdata = spi_get_drvdata(to_spi_device(dev));
+
+	return st_lsm6dsm_common_resume(cdata);
+}
+
+static const struct dev_pm_ops st_lsm6dsm_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(st_lsm6dsm_suspend, st_lsm6dsm_resume)
+};
+
+#define ST_LSM6DSM_PM_OPS		(&st_lsm6dsm_pm_ops)
+#else /* CONFIG_PM */
+#define ST_LSM6DSM_PM_OPS		NULL
+#endif /* CONFIG_PM */
+
+static const struct spi_device_id st_lsm6dsm_id_table[] = {
+	{ LSM6DSM_DEV_NAME },
+	{ },
+};
+MODULE_DEVICE_TABLE(spi, st_lsm6dsm_id_table);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lsm6dsm_of_match[] = {
+	{
+		.compatible = "st,lsm6dsm",
+		.data = LSM6DSM_DEV_NAME,
+	},
+	{
+		.compatible = "st,lsm6dsl",
+		.data = LSM6DSL_DEV_NAME,
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, lsm6dsm_of_match);
+#else /* CONFIG_OF */
+#define lsm6dsm_of_match		NULL
+#endif /* CONFIG_OF */
+
+static struct spi_driver st_lsm6dsm_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "st-lsm6dsm-spi",
+		.pm = ST_LSM6DSM_PM_OPS,
+		.of_match_table = of_match_ptr(lsm6dsm_of_match),
+	},
+	.probe = st_lsm6dsm_spi_probe,
+	.remove = st_lsm6dsm_spi_remove,
+	.id_table = st_lsm6dsm_id_table,
+};
+module_spi_driver(st_lsm6dsm_driver);
+
+MODULE_AUTHOR("Denis Ciocca <denis.ciocca@st.com>");
+MODULE_DESCRIPTION("STMicroelectronics lsm6dsm spi driver");
+MODULE_LICENSE("GPL v2");
diff -Naur A/drivers/iio/imu/st_lsm6dsm/st_lsm6dsm_trigger.c B/drivers/iio/imu/st_lsm6dsm/st_lsm6dsm_trigger.c
--- A/drivers/iio/imu/st_lsm6dsm/st_lsm6dsm_trigger.c	1970-01-01 05:30:00.000000000 +0530
+++ B/drivers/iio/imu/st_lsm6dsm/st_lsm6dsm_trigger.c	2022-08-09 13:36:04.270484049 +0530
@@ -0,0 +1,209 @@
+/*
+ * STMicroelectronics lsm6dsm trigger driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Denis Ciocca <denis.ciocca@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/trigger.h>
+#include <linux/interrupt.h>
+#include <linux/iio/events.h>
+
+#include "st_lsm6dsm.h"
+
+#define ST_LSM6DSM_DIS_BIT				0x00
+#define ST_LSM6DSM_SRC_FUNC_ADDR			0x53
+/* Commented by Akshay
+#define ST_LSM6DSM_SRC2_FUNC_ADDR			0x54
+#define ST_LSM6DSM_WRIST_TILT_IA			0x55
+#define ST_LSM6DSM_WAKE_UP_SRC				0x1b
+#define ST_LSM6DSM_TAP_SRC				0x1c
+#define ST_LSM6DSM_STAP_EVENT			BIT(5)
+#define ST_LSM6DSM_DTAP_EVENT			BIT(4)
+*/
+#define ST_LSM6DSM_FIFO_DATA_AVL_ADDR			0x3b
+#define ST_LSM6DSM_ACCEL_DATA_AVL_ADDR			0x1e
+
+#define ST_LSM6DSM_ACCEL_DATA_AVL			0x01
+#define ST_LSM6DSM_GYRO_DATA_AVL			0x02
+#define ST_LSM6DSM_SRC_STEP_DETECTOR_DATA_AVL		0x10
+#define ST_LSM6DSM_SRC_SIGN_MOTION_DATA_AVL		0x40
+#define ST_LSM6DSM_SRC_TILT_DATA_AVL			0x20
+/* Commented by Akshay
+#define ST_LSM6DSM_SRC_WTILT_DATA_AVL			0x01
+*/
+#define ST_LSM6DSM_SRC_STEP_COUNTER_DATA_AVL		0x80
+#define ST_LSM6DSM_SRC_STEP_COUNTER_DATA_OVR		0x08
+#define ST_LSM6DSM_FIFO_DATA_AVL			0x80
+#define ST_LSM6DSM_FIFO_DATA_OVR			0x40
+
+static irqreturn_t lsm6dsm_irq_management(int irq, void *private)
+{
+	int err;
+	bool push;
+	bool force_read_accel = false;
+	struct lsm6dsm_data *cdata = private;
+	u8 src_accel_gyro = 0, src_dig_func = 0;
+
+	cdata->timestamp = ktime_get_boottime_ns();
+
+	if ((cdata->sensors_enabled & ~cdata->sensors_use_fifo) &
+			(BIT(ST_MASK_ID_ACCEL) | BIT(ST_MASK_ID_GYRO) |
+						BIT(ST_MASK_ID_EXT0))) {
+		err = cdata->tf->read(cdata, ST_LSM6DSM_ACCEL_DATA_AVL_ADDR,
+						1, &src_accel_gyro, true);
+		if (err < 0)
+			goto read_fifo_status;
+
+		if (src_accel_gyro & ST_LSM6DSM_ACCEL_DATA_AVL) {
+#ifdef CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT
+			if ((cdata->sensors_enabled & ~cdata->sensors_use_fifo)
+						& BIT(ST_MASK_ID_EXT0)) {
+				cdata->nofifo_decimation[ST_MASK_ID_EXT0].num_samples++;
+				force_read_accel = true;
+
+				if ((cdata->nofifo_decimation[ST_MASK_ID_EXT0].num_samples %
+						cdata->nofifo_decimation[ST_MASK_ID_EXT0].decimator) == 0) {
+					push = true;
+					cdata->nofifo_decimation[ST_MASK_ID_EXT0].num_samples = 0;
+				} else
+					push = false;
+
+					lsm6dsm_read_output_data(cdata, ST_MASK_ID_EXT0, push);
+			}
+#endif /* CONFIG_ST_LSM6DSM_IIO_MASTER_SUPPORT */
+
+			if ((cdata->sensors_enabled & ~cdata->sensors_use_fifo) &
+							BIT(ST_MASK_ID_ACCEL)) {
+				cdata->nofifo_decimation[ST_MASK_ID_ACCEL].num_samples++;
+
+				if ((cdata->nofifo_decimation[ST_MASK_ID_ACCEL].num_samples %
+						cdata->nofifo_decimation[ST_MASK_ID_ACCEL].decimator) == 0) {
+					push = true;
+					cdata->nofifo_decimation[ST_MASK_ID_ACCEL].num_samples = 0;
+				} else
+					push = false;
+
+				lsm6dsm_read_output_data(cdata, ST_MASK_ID_ACCEL, push);
+			} else {
+				if (force_read_accel)
+					lsm6dsm_read_output_data(cdata, ST_MASK_ID_ACCEL, false);
+			}
+		}
+
+		if (src_accel_gyro & ST_LSM6DSM_GYRO_DATA_AVL) {
+			if ((cdata->sensors_enabled & ~cdata->sensors_use_fifo) & BIT(ST_MASK_ID_GYRO))
+				lsm6dsm_read_output_data(cdata, ST_MASK_ID_GYRO, true);
+		}
+	}
+
+read_fifo_status:
+	if (cdata->sensors_use_fifo)
+		st_lsm6dsm_read_fifo(cdata, false);
+
+	err = cdata->tf->read(cdata, ST_LSM6DSM_SRC_FUNC_ADDR,
+						1, &src_dig_func, true);
+	if (err < 0)
+		goto exit_irq;
+
+	if ((src_dig_func & ST_LSM6DSM_SRC_STEP_DETECTOR_DATA_AVL) &&
+				(cdata->sensors_enabled & BIT(ST_MASK_ID_STEP_DETECTOR))) {
+		st_lsm6dsm_push_data_with_timestamp(cdata,
+			ST_MASK_ID_STEP_DETECTOR, NULL, cdata->timestamp);
+	}
+
+	if ((src_dig_func & ST_LSM6DSM_SRC_SIGN_MOTION_DATA_AVL) &&
+				(cdata->sensors_enabled & BIT(ST_MASK_ID_SIGN_MOTION))) {
+		iio_push_event(cdata->indio_dev[ST_MASK_ID_SIGN_MOTION],
+				IIO_UNMOD_EVENT_CODE(IIO_SIGN_MOTION,
+				0, IIO_EV_TYPE_THRESH, IIO_EV_DIR_EITHER),
+				cdata->timestamp);
+	}
+
+	if (src_dig_func & ST_LSM6DSM_SRC_STEP_COUNTER_DATA_OVR)
+		cdata->num_steps += (1 << 16);
+
+	if (src_dig_func & ST_LSM6DSM_SRC_STEP_COUNTER_DATA_AVL)
+		iio_trigger_poll_chained(cdata->trig[ST_MASK_ID_STEP_COUNTER]);
+
+	if ((src_dig_func & ST_LSM6DSM_SRC_TILT_DATA_AVL) &&
+				(cdata->sensors_enabled & BIT(ST_MASK_ID_TILT))) {
+		st_lsm6dsm_push_data_with_timestamp(cdata,
+				ST_MASK_ID_TILT, NULL, cdata->timestamp);
+	}
+
+exit_irq:
+	return IRQ_HANDLED;
+}
+
+int st_lsm6dsm_allocate_triggers(struct lsm6dsm_data *cdata,
+				const struct iio_trigger_ops *trigger_ops)
+{
+	int err, i, n;
+
+	for (i = 0; i < ST_INDIO_DEV_NUM; i++) {
+		cdata->trig[i] = iio_trigger_alloc("%s-trigger",
+						cdata->indio_dev[i]->name);
+		if (!cdata->trig[i]) {
+			dev_err(cdata->dev,
+					"failed to allocate iio trigger.\n");
+			err = -ENOMEM;
+			goto deallocate_trigger;
+		}
+		iio_trigger_set_drvdata(cdata->trig[i], cdata->indio_dev[i]);
+		cdata->trig[i]->ops = trigger_ops;
+		cdata->trig[i]->dev.parent = cdata->dev;
+	}
+
+	err = request_threaded_irq(cdata->irq, NULL, lsm6dsm_irq_management,
+					IRQF_TRIGGER_HIGH | IRQF_ONESHOT,
+					cdata->name, cdata);
+	if (err)
+		goto deallocate_trigger;
+
+	for (n = 0; n < ST_INDIO_DEV_NUM; n++) {
+		err = iio_trigger_register(cdata->trig[n]);
+		if (err < 0) {
+			dev_err(cdata->dev,
+					"failed to register iio trigger.\n");
+			goto free_irq;
+		}
+		cdata->indio_dev[n]->trig = cdata->trig[n];
+	}
+
+	return 0;
+
+free_irq:
+	free_irq(cdata->irq, cdata);
+	for (n--; n >= 0; n--)
+		iio_trigger_unregister(cdata->trig[n]);
+deallocate_trigger:
+	for (i--; i >= 0; i--)
+		iio_trigger_free(cdata->trig[i]);
+
+	return err;
+}
+EXPORT_SYMBOL(st_lsm6dsm_allocate_triggers);
+
+void st_lsm6dsm_deallocate_triggers(struct lsm6dsm_data *cdata)
+{
+	int i;
+
+	free_irq(cdata->irq, cdata);
+
+	for (i = 0; i < ST_INDIO_DEV_NUM; i++)
+		iio_trigger_unregister(cdata->trig[i]);
+}
+EXPORT_SYMBOL(st_lsm6dsm_deallocate_triggers);
+
+MODULE_AUTHOR("Denis Ciocca <denis.ciocca@st.com>");
+MODULE_DESCRIPTION("STMicroelectronics lsm6dsm trigger driver");
+MODULE_LICENSE("GPL v2");
diff -Naur A/drivers/iio/magnetometer/Kconfig B/drivers/iio/magnetometer/Kconfig
--- A/drivers/iio/magnetometer/Kconfig	2022-06-30 18:05:15.000000000 +0530
+++ B/drivers/iio/magnetometer/Kconfig	2022-08-09 13:36:04.270484049 +0530
@@ -92,6 +92,30 @@
 	  To compile this driver as a module, choose M here: the module
 	  will be called mag3110.
 
+config ST_MAG40_IIO
+        tristate "STMicroelectronics LIS2MDL/LSM303AH/LSM303AGR/ISM303DAC/IIS2MDC sensor"
+        depends on (I2C || SPI) && SYSFS
+        select IIO_BUFFER
+        select IIO_TRIGGERED_BUFFER
+        select ST_MAG40_I2C_IIO if (I2C)
+        select ST_MAG40_SPI_IIO if (SPI)
+        help
+          Say yes here to build support for STMicroelectronics magnetometers:
+          LIS2MDL, LSM303AH, LSM303AGR, ISM303DAC, IIS2MDC.
+
+          To compile this driver as a module, choose M here. The module
+          will be called st_mag40.
+
+config ST_MAG40_I2C_IIO
+        tristate
+        depends on ST_MAG40_IIO
+        depends on I2C
+
+config ST_MAG40_SPI_IIO
+        tristate
+        depends on ST_MAG40_IIO
+        depends on SPI
+
 config HID_SENSOR_MAGNETOMETER_3D
 	depends on HID_SENSOR_HUB
 	select IIO_BUFFER
diff -Naur A/drivers/iio/magnetometer/Makefile B/drivers/iio/magnetometer/Makefile
--- A/drivers/iio/magnetometer/Makefile	2022-06-30 18:05:15.000000000 +0530
+++ B/drivers/iio/magnetometer/Makefile	2022-08-09 13:36:04.270484049 +0530
@@ -21,9 +21,16 @@
 obj-$(CONFIG_IIO_ST_MAGN_I2C_3AXIS) += st_magn_i2c.o
 obj-$(CONFIG_IIO_ST_MAGN_SPI_3AXIS) += st_magn_spi.o
 
+ifdef CONFIG_ST_MAG40_IIO
+st_mag40-y				+= st_mag40_buffer.o st_mag40_core.o
+obj-$(CONFIG_ST_MAG40_IIO)		+= st_mag40.o
+obj-$(CONFIG_ST_MAG40_I2C_IIO)		+= st_mag40_i2c.o
+obj-$(CONFIG_ST_MAG40_SPI_IIO)		+= st_mag40_spi.o
+else # CONFIG_ST_MAG40_IIO
 obj-$(CONFIG_SENSORS_HMC5843)		+= hmc5843_core.o
 obj-$(CONFIG_SENSORS_HMC5843_I2C)	+= hmc5843_i2c.o
 obj-$(CONFIG_SENSORS_HMC5843_SPI)	+= hmc5843_spi.o
+endif # CONFIG_ST_MAG40_IIO
 
 obj-$(CONFIG_SENSORS_RM3100)		+= rm3100-core.o
 obj-$(CONFIG_SENSORS_RM3100_I2C)	+= rm3100-i2c.o
diff -Naur A/drivers/iio/magnetometer/st_mag40_buffer.c B/drivers/iio/magnetometer/st_mag40_buffer.c
--- A/drivers/iio/magnetometer/st_mag40_buffer.c	1970-01-01 05:30:00.000000000 +0530
+++ B/drivers/iio/magnetometer/st_mag40_buffer.c	2022-08-09 13:36:04.270484049 +0530
@@ -0,0 +1,184 @@
+/*
+ * STMicroelectronics st_mag40 driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Matteo Dameno <matteo.dameno@st.com>
+ * Armando Visconti <armando.visconti@st.com>
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/stat.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/buffer.h>
+#include <linux/iio/trigger_consumer.h>
+#include <linux/iio/triggered_buffer.h>
+
+#include "st_mag40_core.h"
+
+#define ST_MAG40_EWMA_DIV			128
+static inline s64 st_mag40_ewma(s64 old, s64 new, int weight)
+{
+	s64 diff, incr;
+
+	diff = new - old;
+	incr = div_s64((ST_MAG40_EWMA_DIV - weight) * diff,
+			ST_MAG40_EWMA_DIV);
+
+	return old + incr;
+}
+
+static irqreturn_t st_mag40_trigger_irq_handler(int irq, void *private)
+{
+	struct st_mag40_data *cdata = private;
+	s64 ts;
+	u8 weight = (cdata->odr >= 50) ? 96 : 0;
+
+	ts = st_mag40_get_timestamp();
+	cdata->delta_ts = st_mag40_ewma(cdata->delta_ts, ts - cdata->ts_irq, weight);
+	cdata->ts_irq = ts;
+
+	return IRQ_WAKE_THREAD;
+}
+
+static irqreturn_t st_mag40_trigger_thread_handler(int irq, void *private)
+{
+	struct st_mag40_data *cdata = private;
+	u8 status;
+	int err;
+
+	err = cdata->tf->read(cdata, ST_MAG40_STATUS_ADDR,
+			      sizeof(status), &status);
+	if (err < 0)
+		return IRQ_HANDLED;
+
+	if (!(status & ST_MAG40_AVL_DATA_MASK))
+		return IRQ_NONE;
+
+	iio_trigger_poll_chained(cdata->iio_trig);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t st_mag40_buffer_thread_handler(int irq, void *p)
+{
+	u8 buffer[ALIGN(ST_MAG40_OUT_LEN, sizeof(s64)) + sizeof(s64)];
+	struct iio_poll_func *pf = p;
+	struct iio_dev *iio_dev = pf->indio_dev;
+	struct st_mag40_data *cdata = iio_priv(iio_dev);
+	int err;
+
+	err = cdata->tf->read(cdata, ST_MAG40_OUTX_L_ADDR,
+			      ST_MAG40_OUT_LEN, buffer);
+	if (err < 0)
+		goto out;
+
+	/* discard samples generated during the turn-on time */
+	if (cdata->samples_to_discard > 0) {
+		cdata->samples_to_discard--;
+		goto out;
+	}
+
+	iio_push_to_buffers_with_timestamp(iio_dev, buffer, cdata->ts);
+	cdata->ts += cdata->delta_ts;
+
+out:
+	iio_trigger_notify_done(cdata->iio_trig);
+
+	return IRQ_HANDLED;
+}
+
+static int st_mag40_buffer_preenable(struct iio_dev *indio_dev)
+{
+	struct st_mag40_data *cdata = iio_priv(indio_dev);
+
+	return st_mag40_set_enable(cdata, true);
+}
+
+static int st_mag40_buffer_postdisable(struct iio_dev *indio_dev)
+{
+	struct st_mag40_data *cdata = iio_priv(indio_dev);
+	int err;
+
+	err = st_mag40_set_enable(cdata, false);
+
+	return err < 0 ? err : 0;
+}
+
+static const struct iio_buffer_setup_ops st_mag40_buffer_setup_ops = {
+	.preenable = st_mag40_buffer_preenable,
+	.postenable = iio_triggered_buffer_postenable,
+	.predisable = iio_triggered_buffer_predisable,
+	.postdisable = st_mag40_buffer_postdisable,
+};
+
+int st_mag40_trig_set_state(struct iio_trigger *trig, bool state)
+{
+	return 0;
+}
+
+int st_mag40_allocate_ring(struct iio_dev *iio_dev)
+{
+	return  iio_triggered_buffer_setup(iio_dev, NULL,
+					   st_mag40_buffer_thread_handler,
+					   &st_mag40_buffer_setup_ops);
+}
+
+void st_mag40_deallocate_ring(struct iio_dev *iio_dev)
+{
+	iio_triggered_buffer_cleanup(iio_dev);
+}
+
+static const struct iio_trigger_ops st_mag40_trigger_ops = {
+	
+	.set_trigger_state = st_mag40_trig_set_state,
+};
+
+int st_mag40_allocate_trigger(struct iio_dev *iio_dev)
+{
+	struct st_mag40_data *cdata = iio_priv(iio_dev);
+	int err;
+
+	err = devm_request_threaded_irq(cdata->dev, cdata->irq,
+					st_mag40_trigger_irq_handler, st_mag40_trigger_thread_handler,
+					IRQF_TRIGGER_HIGH | IRQF_ONESHOT,
+					cdata->name, cdata);
+	if (err)
+		return err;
+
+	cdata->iio_trig = devm_iio_trigger_alloc(cdata->dev, "%s-trigger",
+						 iio_dev->name);
+	if (!cdata->iio_trig) {
+		dev_err(cdata->dev, "failed to allocate iio trigger.\n");
+		return -ENOMEM;
+	}
+	iio_trigger_set_drvdata(cdata->iio_trig, iio_dev);
+	cdata->iio_trig->ops = &st_mag40_trigger_ops;
+	cdata->iio_trig->dev.parent = cdata->dev;
+
+	err = iio_trigger_register(cdata->iio_trig);
+	if (err < 0) {
+		dev_err(cdata->dev, "failed to register iio trigger.\n");
+		return err;
+	}
+	iio_dev->trig = cdata->iio_trig;
+
+	return 0;
+}
+
+void st_mag40_deallocate_trigger(struct st_mag40_data *cdata)
+{
+	iio_trigger_unregister(cdata->iio_trig);
+}
+
+MODULE_DESCRIPTION("STMicroelectronics st_mag40 driver");
+MODULE_AUTHOR("Armando Visconti <armando.visconti@st.com>");
+MODULE_AUTHOR("Lorenzo Bianconi <lorenzo.bianconi@st.com>");
+MODULE_LICENSE("GPL v2");
diff -Naur A/drivers/iio/magnetometer/st_mag40_core.c B/drivers/iio/magnetometer/st_mag40_core.c
--- A/drivers/iio/magnetometer/st_mag40_core.c	1970-01-01 05:30:00.000000000 +0530
+++ B/drivers/iio/magnetometer/st_mag40_core.c	2022-08-09 13:36:04.270484049 +0530
@@ -0,0 +1,375 @@
+/*
+ * STMicroelectronics st_mag40 driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Matteo Dameno <matteo.dameno@st.com>
+ * Armando Visconti <armando.visconti@st.com>
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/mutex.h>
+#include <linux/interrupt.h>
+#include <linux/gpio.h>
+#include <linux/irq.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/sysfs.h>
+#include <linux/iio/trigger.h>
+#include <linux/delay.h>
+#include <linux/iio/buffer.h>
+#include <linux/iio/events.h>
+#include <asm/unaligned.h>
+
+#include "st_mag40_core.h"
+
+struct st_mag40_odr_reg {
+	u32 hz;
+	u8 value;
+};
+
+#define ST_MAG40_ODR_TABLE_SIZE		4
+static const struct st_mag40_odr_table_t {
+	u8 addr;
+	u8 mask;
+	struct st_mag40_odr_reg odr_avl[ST_MAG40_ODR_TABLE_SIZE];
+} st_mag40_odr_table = {
+	.addr = ST_MAG40_ODR_ADDR,
+	.mask = ST_MAG40_ODR_MASK,
+	.odr_avl[0] = { .hz = 10, .value = ST_MAG40_CFG_REG_A_ODR_10Hz, },
+	.odr_avl[1] = { .hz = 20, .value = ST_MAG40_CFG_REG_A_ODR_20Hz, },
+	.odr_avl[2] = { .hz = 50, .value = ST_MAG40_CFG_REG_A_ODR_50Hz, },
+	.odr_avl[3] = { .hz = 100, .value = ST_MAG40_CFG_REG_A_ODR_100Hz, },
+};
+
+#define ST_MAG40_ADD_CHANNEL(device_type, modif, index, mod, 	\
+			     endian, sbits, rbits, addr, s) 	\
+{								\
+	.type = device_type,					\
+	.modified = modif,					\
+	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |		\
+			      BIT(IIO_CHAN_INFO_SCALE),		\
+	.scan_index = index,					\
+	.channel2 = mod,					\
+	.address = addr,					\
+	.scan_type = {						\
+		.sign = s,					\
+		.realbits = rbits,				\
+		.shift = sbits - rbits,				\
+		.storagebits = sbits,				\
+		.endianness = endian,				\
+	},							\
+}
+
+static const struct iio_chan_spec st_mag40_channels[] = {
+	ST_MAG40_ADD_CHANNEL(IIO_MAGN, 1, 0, IIO_MOD_X, IIO_LE, 16, 16,
+				ST_MAG40_OUTX_L_ADDR, 's'),
+	ST_MAG40_ADD_CHANNEL(IIO_MAGN, 1, 1, IIO_MOD_Y, IIO_LE, 16, 16,
+				ST_MAG40_OUTY_L_ADDR, 's'),
+	ST_MAG40_ADD_CHANNEL(IIO_MAGN, 1, 2, IIO_MOD_Z, IIO_LE, 16, 16,
+				ST_MAG40_OUTZ_L_ADDR, 's'),
+	IIO_CHAN_SOFT_TIMESTAMP(3),
+};
+
+int st_mag40_write_register(struct st_mag40_data *cdata, u8 reg_addr,
+			    u8 mask, u8 data)
+{
+	int err;
+	u8 val;
+
+	mutex_lock(&cdata->lock);
+
+	err = cdata->tf->read(cdata, reg_addr, sizeof(val), &val);
+	if (err < 0)
+		goto unlock;
+
+	val = ((val & ~mask) | ((data << __ffs(mask)) & mask));
+
+	err = cdata->tf->write(cdata, reg_addr, sizeof(val), &val);
+
+unlock:
+	mutex_unlock(&cdata->lock);
+
+	return err < 0 ? err : 0;
+}
+
+static int st_mag40_write_odr(struct st_mag40_data *cdata, uint32_t odr)
+{
+	int err, i;
+
+	for (i = 0; i < ST_MAG40_ODR_TABLE_SIZE; i++)
+		if (st_mag40_odr_table.odr_avl[i].hz >= odr)
+			break;
+
+	if (i == ST_MAG40_ODR_TABLE_SIZE)
+		return -EINVAL;
+
+	err = st_mag40_write_register(cdata, st_mag40_odr_table.addr,
+				      st_mag40_odr_table.mask,
+				      st_mag40_odr_table.odr_avl[i].value);
+	if (err < 0)
+		return err;
+
+	cdata->odr = odr;
+	cdata->samples_to_discard = ST_MAG40_TURNON_TIME_SAMPLES_NUM;
+
+	return 0;
+}
+
+int st_mag40_set_enable(struct st_mag40_data *cdata, bool state)
+{
+	u8 mode;
+
+	mode = state ? ST_MAG40_CFG_REG_A_MD_CONT : ST_MAG40_CFG_REG_A_MD_IDLE;
+
+	if (state) {
+		cdata->ts = cdata->ts_irq = st_mag40_get_timestamp();
+		cdata->delta_ts = div_s64(1000000000LL, cdata->odr);
+	}
+
+	return st_mag40_write_register(cdata, ST_MAG40_EN_ADDR,
+				       ST_MAG40_EN_MASK, mode);
+}
+
+int st_mag40_init_sensors(struct st_mag40_data *cdata)
+{
+	int err;
+
+	/*
+	 * Enable block data update feature.
+	 */
+	err = st_mag40_write_register(cdata, ST_MAG40_CFG_REG_C_ADDR,
+				      ST_MAG40_CFG_REG_C_BDU_MASK, 1);
+	if (err < 0)
+		return err;
+
+	/* added data ready interrupt enabling */
+	err = st_mag40_write_register(cdata, ST_MAG40_INT_DRDY_ADDR,
+                                      ST_MAG40_INT_DRDY_MASK, 1);
+
+	/*
+	 * Enable the temperature compensation feature
+	 */
+	err = st_mag40_write_register(cdata, ST_MAG40_CFG_REG_A_ADDR,
+				      ST_MAG40_TEMP_COMP_EN, 1);
+	if (err < 0)
+		return err;
+
+	err = st_mag40_write_register(cdata, ST_MAG40_CFG_REG_B_ADDR,
+				      ST_MAG40_CFG_REG_B_OFF_CANC_MASK, 1);
+
+	return err < 0 ? err : 0;
+}
+
+static ssize_t st_mag40_get_sampling_frequency(struct device *dev,
+					       struct device_attribute *attr,
+					       char *buf)
+{
+	struct st_mag40_data *cdata = iio_priv(dev_get_drvdata(dev));
+
+	return sprintf(buf, "%d\n", cdata->odr);
+}
+
+static ssize_t st_mag40_set_sampling_frequency(struct device * dev,
+					       struct device_attribute * attr,
+					       const char *buf, size_t count)
+{
+	struct iio_dev *iio_dev = dev_get_drvdata(dev);
+	struct st_mag40_data *cdata = iio_priv(iio_dev);
+	unsigned int odr;
+	int err;
+
+	err = kstrtoint(buf, 10, &odr);
+	if (err < 0)
+		return err;
+
+	err = st_mag40_write_odr(cdata, odr);
+
+	return err < 0 ? err : count;
+}
+
+static ssize_t
+st_mag40_get_sampling_frequency_avail(struct device *dev,
+				      struct device_attribute *attr,
+				      char *buf)
+{
+	int i, len = 0;
+
+	for (i = 0; i < ST_MAG40_ODR_TABLE_SIZE; i++)
+		len += scnprintf(buf + len, PAGE_SIZE - len, "%d ",
+				 st_mag40_odr_table.odr_avl[i].hz);
+	buf[len - 1] = '\n';
+
+	return len;
+}
+
+static int st_mag40_read_oneshot(struct st_mag40_data *cdata,
+				 u8 addr, int *val)
+{
+	u8 data[2];
+	int err;
+
+	err = st_mag40_set_enable(cdata, true);
+	if (err < 0)
+		return err;
+
+	msleep(40);
+
+	err = cdata->tf->read(cdata, addr, sizeof(data), data);
+	if (err < 0)
+		return err;
+
+	*val = (s16)get_unaligned_le16(data);
+
+	err = st_mag40_set_enable(cdata, false);
+
+	return err < 0 ? err : IIO_VAL_INT;
+}
+
+static int st_mag40_read_raw(struct iio_dev *iio_dev,
+			     struct iio_chan_spec const *ch,
+			     int *val, int *val2, long mask)
+{
+	struct st_mag40_data *cdata = iio_priv(iio_dev);
+	int ret;
+
+	mutex_lock(&iio_dev->mlock);
+
+	if (iio_buffer_enabled(iio_dev)) {
+		mutex_unlock(&iio_dev->mlock);
+		return -EBUSY;
+	}
+
+	switch (mask) {
+	case IIO_CHAN_INFO_RAW:
+		ret = st_mag40_read_oneshot(cdata, ch->address, val);
+		break;
+	case IIO_CHAN_INFO_SCALE:
+		*val = 0;
+		*val2 = 1500;
+		ret = IIO_VAL_INT_PLUS_MICRO;
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	mutex_unlock(&iio_dev->mlock);
+
+	return ret;
+}
+
+static IIO_DEV_ATTR_SAMP_FREQ(S_IWUSR | S_IRUGO,
+			      st_mag40_get_sampling_frequency,
+			      st_mag40_set_sampling_frequency);
+static IIO_DEV_ATTR_SAMP_FREQ_AVAIL(st_mag40_get_sampling_frequency_avail);
+
+static struct attribute *st_mag40_attributes[] = {
+	&iio_dev_attr_sampling_frequency_available.dev_attr.attr,
+	&iio_dev_attr_sampling_frequency.dev_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group st_mag40_attribute_group = {
+	.attrs = st_mag40_attributes,
+};
+
+static const struct iio_info st_mag40_info = {
+	
+	.attrs = &st_mag40_attribute_group,
+	.read_raw = &st_mag40_read_raw,
+};
+
+int st_mag40_common_probe(struct iio_dev *iio_dev)
+{
+	struct st_mag40_data *cdata = iio_priv(iio_dev);
+	int32_t err;
+	u8 wai;
+
+	mutex_init(&cdata->lock);
+
+	err = cdata->tf->read(cdata, ST_MAG40_WHO_AM_I_ADDR,
+			      sizeof(wai), &wai);
+	if (err < 0) {
+		dev_err(cdata->dev, "failed to read Who-Am-I register.\n");
+
+		return err;
+	}
+
+	if (wai != ST_MAG40_WHO_AM_I_DEF) {
+		dev_err(cdata->dev, "Who-Am-I value not valid. (%02x)\n", wai);
+		return -ENODEV;
+	}
+
+	cdata->odr = st_mag40_odr_table.odr_avl[0].hz;
+
+	iio_dev->channels = st_mag40_channels;
+	iio_dev->num_channels = ARRAY_SIZE(st_mag40_channels);
+	iio_dev->info = &st_mag40_info;
+	iio_dev->modes = INDIO_DIRECT_MODE;
+
+	err = st_mag40_init_sensors(cdata);
+	if (err < 0)
+		return err;
+
+	if (cdata->irq > 0) {
+		err = st_mag40_allocate_ring(iio_dev);
+		if (err < 0)
+			return err;
+
+		err = st_mag40_allocate_trigger(iio_dev);
+		if (err < 0)
+			goto deallocate_ring;
+	}
+
+	err = devm_iio_device_register(cdata->dev, iio_dev);
+	if (err)
+		goto iio_trigger_deallocate;
+
+	return 0;
+
+iio_trigger_deallocate:
+	st_mag40_deallocate_trigger(cdata);
+
+deallocate_ring:
+	st_mag40_deallocate_ring(iio_dev);
+
+	return err;
+}
+EXPORT_SYMBOL(st_mag40_common_probe);
+
+void st_mag40_common_remove(struct iio_dev *iio_dev)
+{
+	struct st_mag40_data *cdata = iio_priv(iio_dev);
+
+	if (cdata->irq > 0) {
+		st_mag40_deallocate_trigger(cdata);
+		st_mag40_deallocate_ring(iio_dev);
+	}
+}
+EXPORT_SYMBOL(st_mag40_common_remove);
+
+#ifdef CONFIG_PM
+int st_mag40_common_suspend(struct st_mag40_data *cdata)
+{
+	return 0;
+}
+EXPORT_SYMBOL(st_mag40_common_suspend);
+
+int st_mag40_common_resume(struct st_mag40_data *cdata)
+{
+	return 0;
+}
+EXPORT_SYMBOL(st_mag40_common_resume);
+#endif /* CONFIG_PM */
+
+MODULE_DESCRIPTION("STMicroelectronics st_mag40 driver");
+MODULE_AUTHOR("Armando Visconti <armando.visconti@st.com>");
+MODULE_AUTHOR("Lorenzo Bianconi <lorenzo.bianconi@st.com>");
+MODULE_LICENSE("GPL v2");
diff -Naur A/drivers/iio/magnetometer/st_mag40_core.h B/drivers/iio/magnetometer/st_mag40_core.h
--- A/drivers/iio/magnetometer/st_mag40_core.h	1970-01-01 05:30:00.000000000 +0530
+++ B/drivers/iio/magnetometer/st_mag40_core.h	2022-08-09 13:36:04.270484049 +0530
@@ -0,0 +1,143 @@
+/*
+ * STMicroelectronics st_mag40 driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Matteo Dameno <matteo.dameno@st.com>
+ * Armando Visconti <armando.visconti@st.com>
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#ifndef __ST_MAG40_H
+#define __ST_MAG40_H
+
+#include <linux/types.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/trigger.h>
+
+#define ST_MAG40_DEV_NAME			"st_mag40"
+#define LIS2MDL_DEV_NAME			"lis2mdl_magn"
+#define LSM303AH_DEV_NAME			"lsm303ah_magn"
+#define LSM303AGR_DEV_NAME			"lsm303agr_magn"
+#define ISM303DAC_DEV_NAME			"ism303dac_magn"
+#define IIS2MDC_DEV_NAME			"iis2mdc_magn"
+
+/* Power Modes */
+enum {
+	ST_MAG40_LWC_MODE = 0,
+	ST_MAG40_NORMAL_MODE,
+	ST_MAG40_MODE_COUNT,
+};
+
+#define ST_MAG40_WHO_AM_I_ADDR				0x4f
+#define ST_MAG40_WHO_AM_I_DEF				0x40
+
+/* Magnetometer control registers */
+#define ST_MAG40_CFG_REG_A_ADDR				0x60
+#define ST_MAG40_TEMP_COMP_EN				0x80
+#define ST_MAG40_CFG_REG_A_ODR_MASK			0x0c
+#define ST_MAG40_CFG_REG_A_ODR_10Hz			0x00
+#define ST_MAG40_CFG_REG_A_ODR_20Hz			0x01
+#define ST_MAG40_CFG_REG_A_ODR_50Hz			0x02
+#define ST_MAG40_CFG_REG_A_ODR_100Hz			0x03
+#define ST_MAG40_CFG_REG_A_ODR_COUNT			4
+#define ST_MAG40_CFG_REG_A_MD_MASK			0x03
+#define ST_MAG40_CFG_REG_A_MD_CONT			0x00
+#define ST_MAG40_CFG_REG_A_MD_IDLE			0x03
+
+#define ST_MAG40_ODR_ADDR				ST_MAG40_CFG_REG_A_ADDR
+#define ST_MAG40_ODR_MASK				ST_MAG40_CFG_REG_A_ODR_MASK
+
+#define ST_MAG40_EN_ADDR				ST_MAG40_CFG_REG_A_ADDR
+#define ST_MAG40_EN_MASK				ST_MAG40_CFG_REG_A_MD_MASK
+
+#define ST_MAG40_CFG_REG_B_ADDR				0x61
+#define ST_MAG40_CFG_REG_B_OFF_CANC_MASK		0x02
+
+#define ST_MAG40_CFG_REG_C_ADDR				0x62
+#define ST_MAG40_CFG_REG_C_BDU_MASK			0x10
+#define ST_MAG40_CFG_REG_C_INT_MASK			0x01
+
+#define ST_MAG40_INT_DRDY_ADDR				ST_MAG40_CFG_REG_C_ADDR
+#define ST_MAG40_INT_DRDY_MASK				ST_MAG40_CFG_REG_C_INT_MASK
+
+#define ST_MAG40_STATUS_ADDR				0x67
+#define ST_MAG40_AVL_DATA_MASK				0x7
+
+/* Magnetometer output registers */
+#define ST_MAG40_OUTX_L_ADDR				0x68
+#define ST_MAG40_OUTY_L_ADDR				0x6A
+#define ST_MAG40_OUTZ_L_ADDR				0x6C
+
+#define ST_MAG40_BDU_ADDR				ST_MAG40_CTRL1_ADDR
+#define ST_MAG40_BDU_MASK				0x02
+
+#define ST_MAG40_TURNON_TIME_SAMPLES_NUM	2
+
+/* 3 axis of 16 bit each */
+#define ST_MAG40_OUT_LEN				6
+
+#define ST_MAG40_TX_MAX_LENGTH				16
+#define ST_MAG40_RX_MAX_LENGTH				16
+
+struct st_mag40_transfer_buffer {
+	u8 rx_buf[ST_MAG40_RX_MAX_LENGTH];
+	u8 tx_buf[ST_MAG40_TX_MAX_LENGTH] ____cacheline_aligned;
+};
+
+struct st_mag40_data;
+
+struct st_mag40_transfer_function {
+	int (*write)(struct st_mag40_data *cdata, u8 reg_addr, int len, u8 *data);
+	int (*read)(struct st_mag40_data *cdata, u8 reg_addr, int len, u8 *data);
+};
+
+struct st_mag40_data {
+	const char *name;
+	struct mutex lock;
+	u8 drdy_int_pin;
+	int irq;
+	s64 ts;
+	s64 ts_irq;
+	s64 delta_ts;
+
+	u16 odr;
+	u8 samples_to_discard;
+
+	struct device *dev;
+	struct iio_trigger *iio_trig;
+	const struct st_mag40_transfer_function *tf;
+	struct st_mag40_transfer_buffer tb;
+};
+
+static inline s64 st_mag40_get_timestamp(void)
+{
+//	struct timespec ts;
+    int64_t timestamp;
+//	get_monotonic_boottime(&ts);
+
+//	return timespec_to_ns(&ts);
+
+    timestamp = ktime_get_boottime_ns();
+	return timestamp;
+}
+
+int st_mag40_common_probe(struct iio_dev *iio_dev);
+void st_mag40_common_remove(struct iio_dev *iio_dev);
+
+#ifdef CONFIG_PM
+int st_mag40_common_suspend(struct st_mag40_data *cdata);
+int st_mag40_common_resume(struct st_mag40_data *cdata);
+#endif /* CONFIG_PM */
+
+int st_mag40_allocate_ring(struct iio_dev *iio_dev);
+int st_mag40_allocate_trigger(struct iio_dev *iio_dev);
+int st_mag40_trig_set_state(struct iio_trigger *trig, bool state);
+int st_mag40_set_enable(struct st_mag40_data *cdata, bool enable);
+void st_mag40_deallocate_ring(struct iio_dev *iio_dev);
+void st_mag40_deallocate_trigger(struct st_mag40_data *cdata);
+int st_mag40_write_register(struct st_mag40_data *cdata, u8 reg_addr, u8 mask, u8 data);
+
+#endif /* __ST_MAG40_H */
diff -Naur A/drivers/iio/magnetometer/st_mag40_i2c.c B/drivers/iio/magnetometer/st_mag40_i2c.c
--- A/drivers/iio/magnetometer/st_mag40_i2c.c	1970-01-01 05:30:00.000000000 +0530
+++ B/drivers/iio/magnetometer/st_mag40_i2c.c	2022-08-09 13:36:04.270484049 +0530
@@ -0,0 +1,179 @@
+/*
+ * STMicroelectronics st_mag40 driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Armando Visconti <armando.visconti@st.com>
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/types.h>
+
+#include "st_mag40_core.h"
+
+#define I2C_AUTO_INCREMENT	0x80
+
+static int st_mag40_i2c_read(struct st_mag40_data *cdata, u8 reg_addr,
+			     int len, u8 * data)
+{
+	struct i2c_client *client = to_i2c_client(cdata->dev);
+	struct i2c_msg msg[2];
+
+	if (len > 1)
+		reg_addr |= I2C_AUTO_INCREMENT;
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &reg_addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	return i2c_transfer(client->adapter, msg, 2);
+}
+
+static int st_mag40_i2c_write(struct st_mag40_data *cdata, u8 reg_addr,
+			      int len, u8 * data)
+{
+	struct i2c_client *client = to_i2c_client(cdata->dev);
+	struct i2c_msg msg;
+	u8 send[len + 1];
+
+	send[0] = reg_addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len;
+	msg.buf = send;
+
+	return i2c_transfer(client->adapter, &msg, 1);
+}
+
+static const struct st_mag40_transfer_function st_mag40_tf_i2c = {
+	.write = st_mag40_i2c_write,
+	.read = st_mag40_i2c_read,
+};
+
+static int st_mag40_i2c_probe(struct i2c_client *client,
+			      const struct i2c_device_id *id)
+{
+	struct st_mag40_data *cdata;
+	struct iio_dev *iio_dev;
+
+	iio_dev = devm_iio_device_alloc(&client->dev, sizeof(*cdata));
+	if (!iio_dev)
+		return -ENOMEM;
+
+	i2c_set_clientdata(client, iio_dev);
+	iio_dev->dev.parent = &client->dev;
+	iio_dev->name = client->name;
+
+	cdata = iio_priv(iio_dev);
+	cdata->dev = &client->dev;
+	cdata->name = client->name;
+	cdata->tf = &st_mag40_tf_i2c;
+	cdata->irq = client->irq;
+
+	return st_mag40_common_probe(iio_dev);
+}
+
+static int st_mag40_i2c_remove(struct i2c_client *client)
+{
+	struct iio_dev *iio_dev = i2c_get_clientdata(client);
+
+	st_mag40_common_remove(iio_dev);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int st_mag40_i2c_suspend(struct device *dev)
+{
+	struct iio_dev *iio_dev = dev_get_drvdata(dev);
+	struct st_mag40_data *cdata = iio_priv(iio_dev);
+
+	return st_mag40_common_suspend(cdata);
+}
+
+static int st_mag40_i2c_resume(struct device *dev)
+{
+	struct iio_dev *iio_dev = dev_get_drvdata(dev);
+	struct st_mag40_data *cdata = iio_priv(iio_dev);
+
+	return st_mag40_common_resume(cdata);
+}
+
+static const struct dev_pm_ops st_mag40_i2c_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(st_mag40_i2c_suspend, st_mag40_i2c_resume)
+};
+#endif /* CONFIG_PM */
+
+static const struct i2c_device_id st_mag40_ids[] = {
+	{ LSM303AH_DEV_NAME, 0 },
+	{ LSM303AGR_DEV_NAME, 0 },
+	{ LIS2MDL_DEV_NAME, 0 },
+	{ ISM303DAC_DEV_NAME, 0 },
+	{ IIS2MDC_DEV_NAME, 0 },
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, st_mag40_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id st_mag40_id_table[] = {
+	{
+		.compatible = "st,lsm303ah_magn",
+		.data = LSM303AH_DEV_NAME,
+	},
+	{
+		.compatible = "st,lsm303agr_magn",
+		.data = LSM303AGR_DEV_NAME,
+	},
+	{
+		.compatible = "st,lis2mdl_magn",
+		.data = LSM303AGR_DEV_NAME,
+	},
+	{
+		.compatible = "st,ism303dac_magn",
+		.data = ISM303DAC_DEV_NAME,
+	},
+	{
+		.compatible = "st,iis2mdc_magn",
+		.data = IIS2MDC_DEV_NAME,
+	},
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, st_mag40_id_table);
+#endif /* CONFIG_OF */
+
+static struct i2c_driver st_mag40_i2c_driver = {
+	.driver = {
+		   .owner = THIS_MODULE,
+		   .name = ST_MAG40_DEV_NAME,
+#ifdef CONFIG_PM
+		   .pm = &st_mag40_i2c_pm_ops,
+#endif
+#ifdef CONFIG_OF
+		   .of_match_table = st_mag40_id_table,
+#endif /* CONFIG_OF */
+		   },
+	.probe = st_mag40_i2c_probe,
+	.remove = st_mag40_i2c_remove,
+	.id_table = st_mag40_ids,
+};
+module_i2c_driver(st_mag40_i2c_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics st_mag40 i2c driver");
+MODULE_AUTHOR("Armando Visconti <armando.visconti@st.com>");
+MODULE_AUTHOR("Lorenzo Bianconi <lorenzo.bianconi@st.com>");
+MODULE_LICENSE("GPL v2");
diff -Naur A/drivers/iio/magnetometer/st_mag40_spi.c B/drivers/iio/magnetometer/st_mag40_spi.c
--- A/drivers/iio/magnetometer/st_mag40_spi.c	1970-01-01 05:30:00.000000000 +0530
+++ B/drivers/iio/magnetometer/st_mag40_spi.c	2022-08-09 13:36:04.270484049 +0530
@@ -0,0 +1,187 @@
+/*
+ * STMicroelectronics st_mag40 driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Armando Visconti <armando.visconti@st.com>
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/types.h>
+
+#include "st_mag40_core.h"
+
+#define ST_SENSORS_SPI_READ	0x80
+
+static int st_mag40_spi_read(struct st_mag40_data *cdata,
+			     u8 reg_addr, int len, u8 *data)
+{
+	int err;
+
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = cdata->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = cdata->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+	cdata->tb.tx_buf[0] = reg_addr | ST_SENSORS_SPI_READ;
+
+	err = spi_sync_transfer(to_spi_device(cdata->dev),
+						xfers, ARRAY_SIZE(xfers));
+	if (err)
+		return err;
+
+	memcpy(data, cdata->tb.rx_buf, len*sizeof(u8));
+
+	return len;
+}
+
+static int st_mag40_spi_write(struct st_mag40_data *cdata,
+			      u8 reg_addr, int len, u8 *data)
+{
+	struct spi_transfer xfers = {
+		.tx_buf = cdata->tb.tx_buf,
+		.bits_per_word = 8,
+		.len = len + 1,
+	};
+
+	if (len >= ST_MAG40_RX_MAX_LENGTH)
+		return -ENOMEM;
+
+	cdata->tb.tx_buf[0] = reg_addr;
+
+	memcpy(&cdata->tb.tx_buf[1], data, len);
+
+	return spi_sync_transfer(to_spi_device(cdata->dev), &xfers, 1);
+}
+
+static const struct st_mag40_transfer_function st_mag40_tf_spi = {
+	.write = st_mag40_spi_write,
+	.read = st_mag40_spi_read,
+};
+
+static int st_mag40_spi_probe(struct spi_device *spi)
+{
+	struct st_mag40_data *cdata;
+	struct iio_dev *iio_dev;
+
+	iio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*cdata));
+	if (!iio_dev)
+		return -ENOMEM;
+
+	spi_set_drvdata(spi, iio_dev);
+	iio_dev->dev.parent = &spi->dev;
+	iio_dev->name = spi->modalias;
+
+	cdata = iio_priv(iio_dev);
+	cdata->dev = &spi->dev;
+	cdata->name = spi->modalias;
+	cdata->tf = &st_mag40_tf_spi;
+	cdata->irq = spi->irq;
+
+	return st_mag40_common_probe(iio_dev);
+}
+
+static int st_mag40_spi_remove(struct spi_device *spi)
+{
+	struct iio_dev *iio_dev = spi_get_drvdata(spi);
+
+	st_mag40_common_remove(iio_dev);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int st_mag40_spi_suspend(struct device *dev)
+{
+	struct iio_dev *iio_dev = dev_get_drvdata(dev);
+	struct st_mag40_data *cdata = iio_priv(iio_dev);
+
+	return st_mag40_common_suspend(cdata);
+}
+
+static int st_mag40_spi_resume(struct device *dev)
+{
+	struct iio_dev *iio_dev = dev_get_drvdata(dev);
+	struct st_mag40_data *cdata = iio_priv(iio_dev);
+
+	return st_mag40_common_resume(cdata);
+}
+
+static const struct dev_pm_ops st_mag40_spi_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(st_mag40_spi_suspend, st_mag40_spi_resume)
+};
+#endif /* CONFIG_PM */
+
+static const struct spi_device_id st_mag40_ids[] = {
+	{ LSM303AH_DEV_NAME, 0 },
+	{ LSM303AGR_DEV_NAME, 0 },
+	{ LIS2MDL_DEV_NAME, 0 },
+	{ ISM303DAC_DEV_NAME, 0 },
+	{ IIS2MDC_DEV_NAME, 0 },
+	{}
+};
+
+MODULE_DEVICE_TABLE(spi, st_mag40_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id st_mag40_id_table[] = {
+	{
+		.compatible = "st,lsm303ah_magn",
+		.data = LSM303AH_DEV_NAME,
+	},
+	{
+		.compatible = "st,lsm303agr_magn",
+		.data = LSM303AGR_DEV_NAME,
+	},
+	{
+		.compatible = "st,lis2mdl_magn",
+		.data = LSM303AGR_DEV_NAME,
+	},
+	{
+		.compatible = "st,ism303dac_magn",
+		.data = ISM303DAC_DEV_NAME,
+	},
+	{
+		.compatible = "st,iis2mdc_magn",
+		.data = IIS2MDC_DEV_NAME,
+	},
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, st_mag40_id_table);
+#endif /* CONFIG_OF */
+
+static struct spi_driver st_mag40_spi_driver = {
+	.driver = {
+		   .owner = THIS_MODULE,
+		   .name = ST_MAG40_DEV_NAME,
+#ifdef CONFIG_PM
+		   .pm = &st_mag40_spi_pm_ops,
+#endif /* CONFIG_PM */
+#ifdef CONFIG_OF
+		   .of_match_table = st_mag40_id_table,
+#endif /* CONFIG_OF */
+		   },
+	.probe = st_mag40_spi_probe,
+	.remove = st_mag40_spi_remove,
+	.id_table = st_mag40_ids,
+};
+module_spi_driver(st_mag40_spi_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics st_mag40 spi driver");
+MODULE_AUTHOR("Armando Visconti <armando.visconti@st.com>");
+MODULE_AUTHOR("Lorenzo Bianconi <lorenzo.bianconi@st.com>");
+MODULE_LICENSE("GPL v2");
diff -Naur A/drivers/mmc/host/sdhci-esdhc-imx.c B/drivers/mmc/host/sdhci-esdhc-imx.c
--- A/drivers/mmc/host/sdhci-esdhc-imx.c	2022-06-30 18:05:15.000000000 +0530
+++ B/drivers/mmc/host/sdhci-esdhc-imx.c	2022-08-09 13:36:04.270484049 +0530
@@ -25,10 +25,14 @@
 #include <linux/pinctrl/consumer.h>
 #include <linux/platform_data/mmc-esdhc-imx.h>
 #include <linux/pm_runtime.h>
+#include <linux/gpio.h> 
 #include "sdhci-pltfm.h"
 #include "sdhci-esdhc.h"
 #include "cqhci.h"
 
+bool iw_esdhc_prop = false; /* Flag added for Rugged Telematics Device */
+
+#define WL_REG_ON_GPIO	132
 #define ESDHC_SYS_CTRL_DTOCV_MASK	0x0f
 #define	ESDHC_CTRL_D3CD			0x08
 #define ESDHC_BURST_LEN_EN_INCR		(1 << 27)
@@ -1448,6 +1452,11 @@
 	if (of_get_property(np, "fsl,wp-controller", NULL))
 		boarddata->wp_type = ESDHC_WP_CONTROLLER;
 
+	if (of_get_property(np, "iw-esdhc-prop", NULL))
+	{
+		iw_esdhc_prop = true;
+	}
+
 	/*
 	 * If we have this property, then activate WP check.
 	 * Retrieveing and requesting the actual WP GPIO will happen
@@ -1798,6 +1807,12 @@
 	pm_runtime_disable(dev);
 	pm_runtime_set_suspended(dev);
 
+	if(iw_esdhc_prop)
+	{
+		gpio_request(WL_REG_ON_GPIO, "WL_REG_ON");
+		gpio_direction_output(WL_REG_ON_GPIO, 0);
+		gpio_set_value(WL_REG_ON_GPIO, 0);
+	}
 
 	return ret;
 }
@@ -1832,6 +1847,14 @@
 
 	pm_runtime_mark_last_busy(dev);
 	pm_runtime_put_autosuspend(dev);
+
+	if(iw_esdhc_prop)
+	{
+		gpio_request(WL_REG_ON_GPIO,"WL_REG_ON");
+		gpio_direction_output(WL_REG_ON_GPIO, 0);
+		gpio_set_value(WL_REG_ON_GPIO, 1); 
+	}
+
 	return ret;
 }
 #endif
diff -Naur A/drivers/net/can/m_can/m_can.c B/drivers/net/can/m_can/m_can.c
--- A/drivers/net/can/m_can/m_can.c	2022-06-30 18:05:15.000000000 +0530
+++ B/drivers/net/can/m_can/m_can.c	2022-08-09 13:36:04.270484049 +0530
@@ -23,6 +23,7 @@
 #include <linux/pinctrl/consumer.h>
 
 #include "m_can.h"
+bool iw_mcan_prop = false; /* Flag added for Rugged Telematics Device */
 
 /* registers definition */
 enum m_can_reg {
@@ -40,7 +41,7 @@
 	M_CAN_TOCV	= 0x2c,
 	M_CAN_ECR	= 0x40,
 	M_CAN_PSR	= 0x44,
-/* TDCR Register only available for version >=3.1.x */
+	/* TDCR Register only available for version >=3.1.x */
 	M_CAN_TDCR	= 0x48,
 	M_CAN_IR	= 0x50,
 	M_CAN_IE	= 0x54,
@@ -207,14 +208,18 @@
 /* Interrupts for version 3.0.x */
 #define IR_ERR_LEC_30X	(IR_STE	| IR_FOE | IR_ACKE | IR_BE | IR_CRCE)
 #define IR_ERR_BUS_30X	(IR_ERR_LEC_30X | IR_WDI | IR_ELO | IR_BEU | \
-			 IR_BEC | IR_TOO | IR_MRAF | IR_TSW | IR_TEFL | \
-			 IR_RF1L | IR_RF0L)
+		IR_BEC | IR_TOO | IR_MRAF | IR_TSW | IR_TEFL | \
+		IR_RF1L | IR_RF0L)
 #define IR_ERR_ALL_30X	(IR_ERR_STATE | IR_ERR_BUS_30X)
 /* Interrupts for version >= 3.1.x */
+#ifdef CONFIG_MX6ULL_IWG26I
+#define IR_ERR_LEC_31X	(IR_PED | IR_PEA | IR_RF0N | IR_RF1N )
+#else /* CONFIG_MX6ULL_IWG26I */
 #define IR_ERR_LEC_31X	(IR_PED | IR_PEA)
+#endif /* CONFIG_MX6ULL_IWG26I */
 #define IR_ERR_BUS_31X      (IR_ERR_LEC_31X | IR_WDI | IR_ELO | IR_BEU | \
-			 IR_BEC | IR_TOO | IR_MRAF | IR_TSW | IR_TEFL | \
-			 IR_RF1L | IR_RF0L)
+		IR_BEC | IR_TOO | IR_MRAF | IR_TSW | IR_TEFL | \
+		IR_RF1L | IR_RF0L)
 #define IR_ERR_ALL_31X	(IR_ERR_STATE | IR_ERR_BUS_31X)
 
 /* Interrupt Line Select (ILS) */
@@ -239,6 +244,7 @@
 #define RXFS_FGI_SHIFT	8
 #define RXFS_FGI_MASK	0x3f00
 #define RXFS_FFL_MASK	0x7f
+#define RXFS_FFL_MASK_ELEMENTS	0x7f
 
 /* Rx Buffer / FIFO Element Size Configuration (RXESC) */
 #define M_CAN_RXESC_8BYTES	0x0
@@ -326,31 +332,31 @@
 }
 
 static inline void m_can_write(struct m_can_classdev *cdev, enum m_can_reg reg,
-			       u32 val)
+		u32 val)
 {
 	cdev->ops->write_reg(cdev, reg, val);
 }
 
 static u32 m_can_fifo_read(struct m_can_classdev *cdev,
-			   u32 fgi, unsigned int offset)
+		u32 fgi, unsigned int offset)
 {
 	u32 addr_offset = cdev->mcfg[MRAM_RXF0].off + fgi * RXF0_ELEMENT_SIZE +
-			  offset;
+		offset;
 
 	return cdev->ops->read_fifo(cdev, addr_offset);
 }
 
 static void m_can_fifo_write(struct m_can_classdev *cdev,
-			     u32 fpi, unsigned int offset, u32 val)
+		u32 fpi, unsigned int offset, u32 val)
 {
 	u32 addr_offset = cdev->mcfg[MRAM_TXB].off + fpi * TXB_ELEMENT_SIZE +
-			  offset;
+		offset;
 
 	cdev->ops->write_fifo(cdev, addr_offset, val);
 }
 
 static inline void m_can_fifo_write_no_off(struct m_can_classdev *cdev,
-					   u32 fpi, u32 val)
+		u32 fpi, u32 val)
 {
 	cdev->ops->write_fifo(cdev, fpi, val);
 }
@@ -358,14 +364,14 @@
 static u32 m_can_txe_fifo_read(struct m_can_classdev *cdev, u32 fgi, u32 offset)
 {
 	u32 addr_offset = cdev->mcfg[MRAM_TXE].off + fgi * TXE_ELEMENT_SIZE +
-			  offset;
+		offset;
 
 	return cdev->ops->read_fifo(cdev, addr_offset);
 }
 
 static inline bool m_can_tx_fifo_full(struct m_can_classdev *cdev)
 {
-		return !!(m_can_read(cdev, M_CAN_TXFQS) & TXFQS_TFQF);
+	return !!(m_can_read(cdev, M_CAN_TXFQS) & TXFQS_TFQF);
 }
 
 void m_can_config_endisable(struct m_can_classdev *cdev, bool enable)
@@ -427,7 +433,7 @@
 		net->stats.tx_errors++;
 		if (cdev->version > 30)
 			putidx = ((m_can_read(cdev, M_CAN_TXFQS) &
-				   TXFQS_TFQPI_MASK) >> TXFQS_TFQPI_SHIFT);
+						TXFQS_TFQPI_MASK) >> TXFQS_TFQPI_SHIFT);
 
 		can_free_echo_skb(cdev->net, putidx);
 		cdev->tx_skb = NULL;
@@ -504,6 +510,11 @@
 		return 0;
 	}
 
+	if(iw_mcan_prop)
+	{
+		quota = rxfs & RXFS_FFL_MASK_ELEMENTS;
+	}
+
 	while ((rxfs & RXFS_FFL_MASK) && (quota > 0)) {
 		if (rxfs & RXFS_RFL)
 			netdev_warn(dev, "Rx FIFO 0 Message Lost\n");
@@ -545,7 +556,7 @@
 }
 
 static int m_can_handle_lec_err(struct net_device *dev,
-				enum m_can_lec_type lec_type)
+		enum m_can_lec_type lec_type)
 {
 	struct m_can_classdev *cdev = netdev_priv(dev);
 	struct net_device_stats *stats = &dev->stats;
@@ -566,32 +577,32 @@
 	cf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;
 
 	switch (lec_type) {
-	case LEC_STUFF_ERROR:
-		netdev_dbg(dev, "stuff error\n");
-		cf->data[2] |= CAN_ERR_PROT_STUFF;
-		break;
-	case LEC_FORM_ERROR:
-		netdev_dbg(dev, "form error\n");
-		cf->data[2] |= CAN_ERR_PROT_FORM;
-		break;
-	case LEC_ACK_ERROR:
-		netdev_dbg(dev, "ack error\n");
-		cf->data[3] = CAN_ERR_PROT_LOC_ACK;
-		break;
-	case LEC_BIT1_ERROR:
-		netdev_dbg(dev, "bit1 error\n");
-		cf->data[2] |= CAN_ERR_PROT_BIT1;
-		break;
-	case LEC_BIT0_ERROR:
-		netdev_dbg(dev, "bit0 error\n");
-		cf->data[2] |= CAN_ERR_PROT_BIT0;
-		break;
-	case LEC_CRC_ERROR:
-		netdev_dbg(dev, "CRC error\n");
-		cf->data[3] = CAN_ERR_PROT_LOC_CRC_SEQ;
-		break;
-	default:
-		break;
+		case LEC_STUFF_ERROR:
+			netdev_dbg(dev, "stuff error\n");
+			cf->data[2] |= CAN_ERR_PROT_STUFF;
+			break;
+		case LEC_FORM_ERROR:
+			netdev_dbg(dev, "form error\n");
+			cf->data[2] |= CAN_ERR_PROT_FORM;
+			break;
+		case LEC_ACK_ERROR:
+			netdev_dbg(dev, "ack error\n");
+			cf->data[3] = CAN_ERR_PROT_LOC_ACK;
+			break;
+		case LEC_BIT1_ERROR:
+			netdev_dbg(dev, "bit1 error\n");
+			cf->data[2] |= CAN_ERR_PROT_BIT1;
+			break;
+		case LEC_BIT0_ERROR:
+			netdev_dbg(dev, "bit0 error\n");
+			cf->data[2] |= CAN_ERR_PROT_BIT0;
+			break;
+		case LEC_CRC_ERROR:
+			netdev_dbg(dev, "CRC error\n");
+			cf->data[3] = CAN_ERR_PROT_LOC_CRC_SEQ;
+			break;
+		default:
+			break;
 	}
 
 	stats->rx_packets++;
@@ -602,7 +613,7 @@
 }
 
 static int __m_can_get_berr_counter(const struct net_device *dev,
-				    struct can_berr_counter *bec)
+		struct can_berr_counter *bec)
 {
 	struct m_can_classdev *cdev = netdev_priv(dev);
 	unsigned int ecr;
@@ -637,7 +648,7 @@
 }
 
 static int m_can_get_berr_counter(const struct net_device *dev,
-				  struct can_berr_counter *bec)
+		struct can_berr_counter *bec)
 {
 	struct m_can_classdev *cdev = netdev_priv(dev);
 	int err;
@@ -654,7 +665,7 @@
 }
 
 static int m_can_handle_state_change(struct net_device *dev,
-				     enum can_state new_state)
+		enum can_state new_state)
 {
 	struct m_can_classdev *cdev = netdev_priv(dev);
 	struct net_device_stats *stats = &dev->stats;
@@ -664,25 +675,25 @@
 	unsigned int ecr;
 
 	switch (new_state) {
-	case CAN_STATE_ERROR_ACTIVE:
-		/* error warning state */
-		cdev->can.can_stats.error_warning++;
-		cdev->can.state = CAN_STATE_ERROR_WARNING;
-		break;
-	case CAN_STATE_ERROR_PASSIVE:
-		/* error passive state */
-		cdev->can.can_stats.error_passive++;
-		cdev->can.state = CAN_STATE_ERROR_PASSIVE;
-		break;
-	case CAN_STATE_BUS_OFF:
-		/* bus-off state */
-		cdev->can.state = CAN_STATE_BUS_OFF;
-		m_can_disable_all_interrupts(cdev);
-		cdev->can.can_stats.bus_off++;
-		can_bus_off(dev);
-		break;
-	default:
-		break;
+		case CAN_STATE_ERROR_ACTIVE:
+			/* error warning state */
+			cdev->can.can_stats.error_warning++;
+			cdev->can.state = CAN_STATE_ERROR_WARNING;
+			break;
+		case CAN_STATE_ERROR_PASSIVE:
+			/* error passive state */
+			cdev->can.can_stats.error_passive++;
+			cdev->can.state = CAN_STATE_ERROR_PASSIVE;
+			break;
+		case CAN_STATE_BUS_OFF:
+			/* bus-off state */
+			cdev->can.state = CAN_STATE_BUS_OFF;
+			m_can_disable_all_interrupts(cdev);
+			cdev->can.can_stats.bus_off++;
+			can_bus_off(dev);
+			break;
+		default:
+			break;
 	}
 
 	/* propagate the error condition to the CAN stack */
@@ -693,32 +704,32 @@
 	__m_can_get_berr_counter(dev, &bec);
 
 	switch (new_state) {
-	case CAN_STATE_ERROR_ACTIVE:
-		/* error warning state */
-		cf->can_id |= CAN_ERR_CRTL;
-		cf->data[1] = (bec.txerr > bec.rxerr) ?
-			CAN_ERR_CRTL_TX_WARNING :
-			CAN_ERR_CRTL_RX_WARNING;
-		cf->data[6] = bec.txerr;
-		cf->data[7] = bec.rxerr;
-		break;
-	case CAN_STATE_ERROR_PASSIVE:
-		/* error passive state */
-		cf->can_id |= CAN_ERR_CRTL;
-		ecr = m_can_read(cdev, M_CAN_ECR);
-		if (ecr & ECR_RP)
-			cf->data[1] |= CAN_ERR_CRTL_RX_PASSIVE;
-		if (bec.txerr > 127)
-			cf->data[1] |= CAN_ERR_CRTL_TX_PASSIVE;
-		cf->data[6] = bec.txerr;
-		cf->data[7] = bec.rxerr;
-		break;
-	case CAN_STATE_BUS_OFF:
-		/* bus-off state */
-		cf->can_id |= CAN_ERR_BUSOFF;
-		break;
-	default:
-		break;
+		case CAN_STATE_ERROR_ACTIVE:
+			/* error warning state */
+			cf->can_id |= CAN_ERR_CRTL;
+			cf->data[1] = (bec.txerr > bec.rxerr) ?
+				CAN_ERR_CRTL_TX_WARNING :
+				CAN_ERR_CRTL_RX_WARNING;
+			cf->data[6] = bec.txerr;
+			cf->data[7] = bec.rxerr;
+			break;
+		case CAN_STATE_ERROR_PASSIVE:
+			/* error passive state */
+			cf->can_id |= CAN_ERR_CRTL;
+			ecr = m_can_read(cdev, M_CAN_ECR);
+			if (ecr & ECR_RP)
+				cf->data[1] |= CAN_ERR_CRTL_RX_PASSIVE;
+			if (bec.txerr > 127)
+				cf->data[1] |= CAN_ERR_CRTL_TX_PASSIVE;
+			cf->data[6] = bec.txerr;
+			cf->data[7] = bec.rxerr;
+			break;
+		case CAN_STATE_BUS_OFF:
+			/* bus-off state */
+			cf->can_id |= CAN_ERR_BUSOFF;
+			break;
+		default:
+			break;
 	}
 
 	stats->rx_packets++;
@@ -736,19 +747,19 @@
 	if (psr & PSR_EW && cdev->can.state != CAN_STATE_ERROR_WARNING) {
 		netdev_dbg(dev, "entered error warning state\n");
 		work_done += m_can_handle_state_change(dev,
-						       CAN_STATE_ERROR_WARNING);
+				CAN_STATE_ERROR_WARNING);
 	}
 
 	if (psr & PSR_EP && cdev->can.state != CAN_STATE_ERROR_PASSIVE) {
 		netdev_dbg(dev, "entered error passive state\n");
 		work_done += m_can_handle_state_change(dev,
-						       CAN_STATE_ERROR_PASSIVE);
+				CAN_STATE_ERROR_PASSIVE);
 	}
 
 	if (psr & PSR_BO && cdev->can.state != CAN_STATE_BUS_OFF) {
 		netdev_dbg(dev, "entered error bus off state\n");
 		work_done += m_can_handle_state_change(dev,
-						       CAN_STATE_BUS_OFF);
+				CAN_STATE_BUS_OFF);
 	}
 
 	return work_done;
@@ -778,7 +789,7 @@
 }
 
 static int m_can_handle_bus_errors(struct net_device *dev, u32 irqstatus,
-				   u32 psr)
+		u32 psr)
 {
 	struct m_can_classdev *cdev = netdev_priv(dev);
 	int work_done = 0;
@@ -788,7 +799,7 @@
 
 	/* handle lec errors on the bus */
 	if ((cdev->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING) &&
-	    is_lec_err(psr))
+			is_lec_err(psr))
 		work_done += m_can_handle_lec_err(dev, psr & LEC_UNUSED);
 
 	/* other unproccessed error interrupts */
@@ -818,7 +829,7 @@
 	 * In this case, reset MCAN_IR.MRAF. No further action is required.
 	 */
 	if (cdev->version <= 31 && irqstatus & IR_MRAF &&
-	    m_can_read(cdev, M_CAN_ECR) & ECR_RP) {
+			m_can_read(cdev, M_CAN_ECR) & ECR_RP) {
 		struct can_berr_counter bec;
 
 		__m_can_get_berr_counter(dev, &bec);
@@ -833,11 +844,23 @@
 	if (irqstatus & IR_ERR_STATE)
 		work_done += m_can_handle_state_errors(dev, psr);
 
-	if (irqstatus & IR_ERR_BUS_30X)
-		work_done += m_can_handle_bus_errors(dev, irqstatus, psr);
-
-	if (irqstatus & IR_RF0N)
-		work_done += m_can_do_rx_poll(dev, (quota - work_done));
+	if(iw_mcan_prop)
+	{
+		/* changes bus size from 30X to 31X*/
+		if (irqstatus & IR_ERR_BUS_31X)
+			work_done += m_can_handle_bus_errors(dev, irqstatus, psr);
+
+		if (irqstatus & IR_RF0W)
+			work_done += m_can_do_rx_poll(dev, (quota - work_done));
+	}
+	else /* iw_mcan_prop */
+	{
+		if (irqstatus & IR_ERR_BUS_30X)
+			work_done += m_can_handle_bus_errors(dev, irqstatus, psr);
+
+		if (irqstatus & IR_RF0N)
+			work_done += m_can_do_rx_poll(dev, (quota - work_done));
+	} /* iw_mcan_prop */
 end:
 	return work_done;
 }
@@ -884,7 +907,7 @@
 
 	/* Get Tx Event fifo element count */
 	txe_count = (m_can_txefs & TXEFS_EFFL_MASK)
-			>> TXEFS_EFFL_SHIFT;
+		>> TXEFS_EFFL_SHIFT;
 
 	/* Get and process all sent elements */
 	for (i = 0; i < txe_count; i++) {
@@ -894,11 +917,11 @@
 
 		/* get message marker */
 		msg_mark = (m_can_txe_fifo_read(cdev, fgi, 4) &
-			    TX_EVENT_MM_MASK) >> TX_EVENT_MM_SHIFT;
+				TX_EVENT_MM_MASK) >> TX_EVENT_MM_SHIFT;
 
 		/* ack txe element */
 		m_can_write(cdev, M_CAN_TXEFA, (TXEFA_EFAI_MASK &
-						(fgi << TXEFA_EFAI_SHIFT)));
+					(fgi << TXEFA_EFAI_SHIFT)));
 
 		/* update stats */
 		stats->tx_bytes += can_get_echo_skb(dev, msg_mark);
@@ -929,14 +952,28 @@
 	 * - state change IRQ
 	 * - bus error IRQ and bus error reporting
 	 */
-	if ((ir & IR_RF0N) || (ir & IR_ERR_ALL_30X)) {
-		cdev->irqstatus = ir;
-		m_can_disable_all_interrupts(cdev);
-		if (!cdev->is_peripheral)
-			napi_schedule(&cdev->napi);
-		else
-			m_can_rx_peripheral(dev);
+	if(iw_mcan_prop)
+	{
+		if ((ir & IR_RF0W) || (ir & IR_ERR_ALL_30X)) {
+			cdev->irqstatus = ir;
+			m_can_disable_all_interrupts(cdev);
+			if (!cdev->is_peripheral)
+				napi_schedule(&cdev->napi);
+			else
+				m_can_rx_peripheral(dev);
+		}
 	}
+	else /* iw_mcan_prop */
+	{
+		if ((ir & IR_RF0N) || (ir & IR_ERR_ALL_30X)) {
+			cdev->irqstatus = ir;
+			m_can_disable_all_interrupts(cdev);
+			if (!cdev->is_peripheral)
+				napi_schedule(&cdev->napi);
+			else
+				m_can_rx_peripheral(dev);
+		}
+	} /* iw_mcan_prop */
 
 	if (cdev->version == 30) {
 		if (ir & IR_TC) {
@@ -952,7 +989,7 @@
 			m_can_echo_tx_event(dev);
 			can_led_event(dev, CAN_LED_EVENT_TX);
 			if (netif_queue_stopped(dev) &&
-			    !m_can_tx_fifo_full(cdev))
+					!m_can_tx_fifo_full(cdev))
 				netif_wake_queue(dev);
 		}
 	}
@@ -1047,24 +1084,24 @@
 			 * Transmitter Delay Compensation Section
 			 */
 			tdco = (cdev->can.clock.freq / 1000) *
-			       ssp / dbt->bitrate;
+				ssp / dbt->bitrate;
 
 			/* Max valid TDCO value is 127 */
 			if (tdco > 127) {
 				netdev_warn(dev, "TDCO value of %u is beyond maximum. Using maximum possible value\n",
-					    tdco);
+						tdco);
 				tdco = 127;
 			}
 
 			reg_btp |= DBTP_TDC;
 			m_can_write(cdev, M_CAN_TDCR,
-				    tdco << TDCR_TDCO_SHIFT);
+					tdco << TDCR_TDCO_SHIFT);
 		}
 
 		reg_btp |= (brp << DBTP_DBRP_SHIFT) |
-			   (sjw << DBTP_DSJW_SHIFT) |
-			   (tseg1 << DBTP_DTSEG1_SHIFT) |
-			   (tseg2 << DBTP_DTSEG2_SHIFT);
+			(sjw << DBTP_DSJW_SHIFT) |
+			(tseg1 << DBTP_DTSEG1_SHIFT) |
+			(tseg2 << DBTP_DTSEG2_SHIFT);
 
 		m_can_write(cdev, M_CAN_DBTP, reg_btp);
 	}
@@ -1072,6 +1109,15 @@
 	return 0;
 }
 
+/*
+* Set the "iw_mcan_prop" flag to execute iWave specific changes
+*/
+void m_can_set_iw_mcan_prop_flag( void )
+{
+	iw_mcan_prop = true;
+}
+EXPORT_SYMBOL_GPL(m_can_set_iw_mcan_prop_flag);
+
 /* Configure M_CAN chip:
  * - set rx buffer/fifo element size
  * - configure rx fifo
@@ -1101,8 +1147,8 @@
 	} else {
 		/* TX FIFO is used for newer IP Core versions */
 		m_can_write(cdev, M_CAN_TXBC,
-			    (cdev->mcfg[MRAM_TXB].num << TXBC_TFQS_SHIFT) |
-			    (cdev->mcfg[MRAM_TXB].off));
+				(cdev->mcfg[MRAM_TXB].num << TXBC_TFQS_SHIFT) |
+				(cdev->mcfg[MRAM_TXB].off));
 	}
 
 	/* support 64 bytes payload */
@@ -1115,37 +1161,51 @@
 	} else {
 		/* Full TX Event FIFO is used */
 		m_can_write(cdev, M_CAN_TXEFC,
-			    ((cdev->mcfg[MRAM_TXE].num << TXEFC_EFS_SHIFT)
-			     & TXEFC_EFS_MASK) |
-			    cdev->mcfg[MRAM_TXE].off);
+				((cdev->mcfg[MRAM_TXE].num << TXEFC_EFS_SHIFT)
+				 & TXEFC_EFS_MASK) |
+				cdev->mcfg[MRAM_TXE].off);
 	}
 
-	/* rx fifo configuration, blocking mode, fifo size 1 */
-	m_can_write(cdev, M_CAN_RXF0C,
-		    (cdev->mcfg[MRAM_RXF0].num << RXFC_FS_SHIFT) |
-		     cdev->mcfg[MRAM_RXF0].off);
-
-	m_can_write(cdev, M_CAN_RXF1C,
-		    (cdev->mcfg[MRAM_RXF1].num << RXFC_FS_SHIFT) |
-		     cdev->mcfg[MRAM_RXF1].off);
+	if (iw_mcan_prop)
+	{
+		/* rx fifo configuration, blocking mode, fifo size 1 */
+		m_can_write(cdev, M_CAN_RXF0C,
+				(cdev->mcfg[MRAM_RXF0].num << RXFC_FS_SHIFT) |
+				cdev->mcfg[MRAM_RXF0].off | 0x81200000);
+
+		m_can_write(cdev, M_CAN_RXF1C,
+				(cdev->mcfg[MRAM_RXF1].num << RXFC_FS_SHIFT) |
+				cdev->mcfg[MRAM_RXF1].off| 0x81200000);
+	}
+	else /* iw_mcan_prop */
+	{
+		/* rx fifo configuration, blocking mode, fifo size 1 */
+		m_can_write(cdev, M_CAN_RXF0C,
+				(cdev->mcfg[MRAM_RXF0].num << RXFC_FS_SHIFT) |
+				cdev->mcfg[MRAM_RXF0].off);
+
+		m_can_write(cdev, M_CAN_RXF1C,
+				(cdev->mcfg[MRAM_RXF1].num << RXFC_FS_SHIFT) |
+				cdev->mcfg[MRAM_RXF1].off);
+	} /* iw_mcan_prop */
 
 	cccr = m_can_read(cdev, M_CAN_CCCR);
 	test = m_can_read(cdev, M_CAN_TEST);
 	test &= ~TEST_LBCK;
 	if (cdev->version == 30) {
-	/* Version 3.0.x */
+		/* Version 3.0.x */
 
 		cccr &= ~(CCCR_TEST | CCCR_MON |
-			(CCCR_CMR_MASK << CCCR_CMR_SHIFT) |
-			(CCCR_CME_MASK << CCCR_CME_SHIFT));
+				(CCCR_CMR_MASK << CCCR_CMR_SHIFT) |
+				(CCCR_CME_MASK << CCCR_CME_SHIFT));
 
 		if (cdev->can.ctrlmode & CAN_CTRLMODE_FD)
 			cccr |= CCCR_CME_CANFD_BRS << CCCR_CME_SHIFT;
 
 	} else {
-	/* Version 3.1.x or 3.2.x */
+		/* Version 3.1.x or 3.2.x */
 		cccr &= ~(CCCR_TEST | CCCR_MON | CCCR_BRSE | CCCR_FDOE |
-			  CCCR_NISO);
+				CCCR_NISO);
 
 		/* Only 3.2.x has NISO Bit implemented */
 		if (cdev->can.ctrlmode & CAN_CTRLMODE_FD_NON_ISO)
@@ -1174,10 +1234,10 @@
 	if (!(cdev->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING))
 		if (cdev->version == 30)
 			m_can_write(cdev, M_CAN_IE, IR_ALL_INT &
-				    ~(IR_ERR_LEC_30X));
+					~(IR_ERR_LEC_30X));
 		else
 			m_can_write(cdev, M_CAN_IE, IR_ALL_INT &
-				    ~(IR_ERR_LEC_31X));
+					~(IR_ERR_LEC_31X));
 	else
 		m_can_write(cdev, M_CAN_IE, IR_ALL_INT);
 
@@ -1208,13 +1268,13 @@
 static int m_can_set_mode(struct net_device *dev, enum can_mode mode)
 {
 	switch (mode) {
-	case CAN_MODE_START:
-		m_can_clean(dev);
-		m_can_start(dev);
-		netif_wake_queue(dev);
-		break;
-	default:
-		return -EOPNOTSUPP;
+		case CAN_MODE_START:
+			m_can_clean(dev);
+			m_can_start(dev);
+			netif_wake_queue(dev);
+			break;
+		default:
+			return -EOPNOTSUPP;
 	}
 
 	return 0;
@@ -1293,13 +1353,13 @@
 	/* return if unsupported version */
 	if (!m_can_version) {
 		dev_err(m_can_dev->dev, "Unsupported version number: %2d",
-			m_can_version);
+				m_can_version);
 		return -EINVAL;
 	}
 
 	if (!m_can_dev->is_peripheral)
 		netif_napi_add(dev, &m_can_dev->napi,
-			       m_can_poll, M_CAN_NAPI_WEIGHT);
+				m_can_poll, M_CAN_NAPI_WEIGHT);
 
 	/* Shared properties of all M_CAN versions */
 	m_can_dev->version = m_can_version;
@@ -1308,49 +1368,49 @@
 
 	/* Set M_CAN supported operations */
 	m_can_dev->can.ctrlmode_supported = CAN_CTRLMODE_LOOPBACK |
-					CAN_CTRLMODE_LISTENONLY |
-					CAN_CTRLMODE_BERR_REPORTING |
-					CAN_CTRLMODE_FD;
+		CAN_CTRLMODE_LISTENONLY |
+		CAN_CTRLMODE_BERR_REPORTING |
+		CAN_CTRLMODE_FD;
 
 	/* Set properties depending on M_CAN version */
 	switch (m_can_dev->version) {
-	case 30:
-		/* CAN_CTRLMODE_FD_NON_ISO is fixed with M_CAN IP v3.0.x */
-		can_set_static_ctrlmode(dev, CAN_CTRLMODE_FD_NON_ISO);
-		m_can_dev->can.bittiming_const = m_can_dev->bit_timing ?
-			m_can_dev->bit_timing : &m_can_bittiming_const_30X;
-
-		m_can_dev->can.data_bittiming_const = m_can_dev->data_timing ?
-						m_can_dev->data_timing :
-						&m_can_data_bittiming_const_30X;
-		break;
-	case 31:
-		/* CAN_CTRLMODE_FD_NON_ISO is fixed with M_CAN IP v3.1.x */
-		can_set_static_ctrlmode(dev, CAN_CTRLMODE_FD_NON_ISO);
-		m_can_dev->can.bittiming_const = m_can_dev->bit_timing ?
-			m_can_dev->bit_timing : &m_can_bittiming_const_31X;
-
-		m_can_dev->can.data_bittiming_const = m_can_dev->data_timing ?
-						m_can_dev->data_timing :
-						&m_can_data_bittiming_const_31X;
-		break;
-	case 32:
-		m_can_dev->can.bittiming_const = m_can_dev->bit_timing ?
-			m_can_dev->bit_timing : &m_can_bittiming_const_31X;
-
-		m_can_dev->can.data_bittiming_const = m_can_dev->data_timing ?
-						m_can_dev->data_timing :
-						&m_can_data_bittiming_const_31X;
-
-		m_can_dev->can.ctrlmode_supported |=
-						(m_can_niso_supported(m_can_dev)
-						? CAN_CTRLMODE_FD_NON_ISO
-						: 0);
-		break;
-	default:
-		dev_err(m_can_dev->dev, "Unsupported version number: %2d",
-			m_can_dev->version);
-		return -EINVAL;
+		case 30:
+			/* CAN_CTRLMODE_FD_NON_ISO is fixed with M_CAN IP v3.0.x */
+			can_set_static_ctrlmode(dev, CAN_CTRLMODE_FD_NON_ISO);
+			m_can_dev->can.bittiming_const = m_can_dev->bit_timing ?
+				m_can_dev->bit_timing : &m_can_bittiming_const_30X;
+
+			m_can_dev->can.data_bittiming_const = m_can_dev->data_timing ?
+				m_can_dev->data_timing :
+				&m_can_data_bittiming_const_30X;
+			break;
+		case 31:
+			/* CAN_CTRLMODE_FD_NON_ISO is fixed with M_CAN IP v3.1.x */
+			can_set_static_ctrlmode(dev, CAN_CTRLMODE_FD_NON_ISO);
+			m_can_dev->can.bittiming_const = m_can_dev->bit_timing ?
+				m_can_dev->bit_timing : &m_can_bittiming_const_31X;
+
+			m_can_dev->can.data_bittiming_const = m_can_dev->data_timing ?
+				m_can_dev->data_timing :
+				&m_can_data_bittiming_const_31X;
+			break;
+		case 32:
+			m_can_dev->can.bittiming_const = m_can_dev->bit_timing ?
+				m_can_dev->bit_timing : &m_can_bittiming_const_31X;
+
+			m_can_dev->can.data_bittiming_const = m_can_dev->data_timing ?
+				m_can_dev->data_timing :
+				&m_can_data_bittiming_const_31X;
+
+			m_can_dev->can.ctrlmode_supported |=
+				(m_can_niso_supported(m_can_dev)
+				 ? CAN_CTRLMODE_FD_NON_ISO
+				 : 0);
+			break;
+		default:
+			dev_err(m_can_dev->dev, "Unsupported version number: %2d",
+					m_can_dev->version);
+			return -EINVAL;
 	}
 
 	if (m_can_dev->ops->init)
@@ -1436,12 +1496,12 @@
 		/* message ram configuration */
 		m_can_fifo_write(cdev, 0, M_CAN_FIFO_ID, id);
 		m_can_fifo_write(cdev, 0, M_CAN_FIFO_DLC,
-				 can_len2dlc(cf->len) << 16);
+				can_len2dlc(cf->len) << 16);
 
 		for (i = 0; i < cf->len; i += 4)
 			m_can_fifo_write(cdev, 0,
-					 M_CAN_FIFO_DATA(i / 4),
-					 *(u32 *)(cf->data + i));
+					M_CAN_FIFO_DATA(i / 4),
+					*(u32 *)(cf->data + i));
 
 		can_put_echo_skb(skb, dev, 0);
 
@@ -1471,7 +1531,7 @@
 			/* This shouldn't happen */
 			netif_stop_queue(dev);
 			netdev_warn(dev,
-				    "TX queue active although FIFO is full.");
+					"TX queue active although FIFO is full.");
 
 			if (cdev->is_peripheral) {
 				kfree_skb(skb);
@@ -1484,7 +1544,7 @@
 
 		/* get put index for frame */
 		putidx = ((m_can_read(cdev, M_CAN_TXFQS) & TXFQS_TFQPI_MASK)
-				  >> TXFQS_TFQPI_SHIFT);
+				>> TXFQS_TFQPI_SHIFT);
 		/* Write ID Field to FIFO Element */
 		m_can_fifo_write(cdev, putidx, M_CAN_FIFO_ID, id);
 
@@ -1502,14 +1562,14 @@
 		 * sending the correct echo frame
 		 */
 		m_can_fifo_write(cdev, putidx, M_CAN_FIFO_DLC,
-				 ((putidx << TX_BUF_MM_SHIFT) &
-				  TX_BUF_MM_MASK) |
-				 (can_len2dlc(cf->len) << 16) |
-				 fdflags | TX_BUF_EFC);
+				((putidx << TX_BUF_MM_SHIFT) &
+				 TX_BUF_MM_MASK) |
+				(can_len2dlc(cf->len) << 16) |
+				fdflags | TX_BUF_EFC);
 
 		for (i = 0; i < cf->len; i += 4)
 			m_can_fifo_write(cdev, putidx, M_CAN_FIFO_DATA(i / 4),
-					 *(u32 *)(cf->data + i));
+					*(u32 *)(cf->data + i));
 
 		/* Push loopback echo.
 		 * Will be looped back on TX interrupt based on message marker
@@ -1521,7 +1581,7 @@
 
 		/* stop network queue if fifo full */
 		if (m_can_tx_fifo_full(cdev) ||
-		    m_can_next_echo_skb_occupied(dev, putidx))
+				m_can_next_echo_skb_occupied(dev, putidx))
 			netif_stop_queue(dev);
 	}
 
@@ -1531,14 +1591,14 @@
 static void m_can_tx_work_queue(struct work_struct *ws)
 {
 	struct m_can_classdev *cdev = container_of(ws, struct m_can_classdev,
-						tx_work);
+			tx_work);
 
 	m_can_tx_handler(cdev);
 	cdev->tx_skb = NULL;
 }
 
 static netdev_tx_t m_can_start_xmit(struct sk_buff *skb,
-				    struct net_device *dev)
+		struct net_device *dev)
 {
 	struct m_can_classdev *cdev = netdev_priv(dev);
 
@@ -1591,7 +1651,7 @@
 	if (cdev->is_peripheral) {
 		cdev->tx_skb = NULL;
 		cdev->tx_wq = alloc_workqueue("mcan_wq",
-					      WQ_FREEZABLE | WQ_MEM_RECLAIM, 0);
+				WQ_FREEZABLE | WQ_MEM_RECLAIM, 0);
 		if (!cdev->tx_wq) {
 			err = -ENOMEM;
 			goto out_wq_fail;
@@ -1600,11 +1660,11 @@
 		INIT_WORK(&cdev->tx_work, m_can_tx_work_queue);
 
 		err = request_threaded_irq(dev->irq, NULL, m_can_isr,
-					   IRQF_ONESHOT | IRQF_TRIGGER_FALLING,
-					   dev->name, dev);
+				IRQF_ONESHOT | IRQF_TRIGGER_FALLING,
+				dev->name, dev);
 	} else {
 		err = request_irq(dev->irq, m_can_isr, IRQF_SHARED, dev->name,
-				  dev);
+				dev);
 	}
 
 	if (err < 0) {
@@ -1650,41 +1710,41 @@
 }
 
 static void m_can_of_parse_mram(struct m_can_classdev *cdev,
-				const u32 *mram_config_vals)
+		const u32 *mram_config_vals)
 {
 	cdev->mcfg[MRAM_SIDF].off = mram_config_vals[0];
 	cdev->mcfg[MRAM_SIDF].num = mram_config_vals[1];
 	cdev->mcfg[MRAM_XIDF].off = cdev->mcfg[MRAM_SIDF].off +
-			cdev->mcfg[MRAM_SIDF].num * SIDF_ELEMENT_SIZE;
+		cdev->mcfg[MRAM_SIDF].num * SIDF_ELEMENT_SIZE;
 	cdev->mcfg[MRAM_XIDF].num = mram_config_vals[2];
 	cdev->mcfg[MRAM_RXF0].off = cdev->mcfg[MRAM_XIDF].off +
-			cdev->mcfg[MRAM_XIDF].num * XIDF_ELEMENT_SIZE;
+		cdev->mcfg[MRAM_XIDF].num * XIDF_ELEMENT_SIZE;
 	cdev->mcfg[MRAM_RXF0].num = mram_config_vals[3] &
-			(RXFC_FS_MASK >> RXFC_FS_SHIFT);
+		(RXFC_FS_MASK >> RXFC_FS_SHIFT);
 	cdev->mcfg[MRAM_RXF1].off = cdev->mcfg[MRAM_RXF0].off +
-			cdev->mcfg[MRAM_RXF0].num * RXF0_ELEMENT_SIZE;
+		cdev->mcfg[MRAM_RXF0].num * RXF0_ELEMENT_SIZE;
 	cdev->mcfg[MRAM_RXF1].num = mram_config_vals[4] &
-			(RXFC_FS_MASK >> RXFC_FS_SHIFT);
+		(RXFC_FS_MASK >> RXFC_FS_SHIFT);
 	cdev->mcfg[MRAM_RXB].off = cdev->mcfg[MRAM_RXF1].off +
-			cdev->mcfg[MRAM_RXF1].num * RXF1_ELEMENT_SIZE;
+		cdev->mcfg[MRAM_RXF1].num * RXF1_ELEMENT_SIZE;
 	cdev->mcfg[MRAM_RXB].num = mram_config_vals[5];
 	cdev->mcfg[MRAM_TXE].off = cdev->mcfg[MRAM_RXB].off +
-			cdev->mcfg[MRAM_RXB].num * RXB_ELEMENT_SIZE;
+		cdev->mcfg[MRAM_RXB].num * RXB_ELEMENT_SIZE;
 	cdev->mcfg[MRAM_TXE].num = mram_config_vals[6];
 	cdev->mcfg[MRAM_TXB].off = cdev->mcfg[MRAM_TXE].off +
-			cdev->mcfg[MRAM_TXE].num * TXE_ELEMENT_SIZE;
+		cdev->mcfg[MRAM_TXE].num * TXE_ELEMENT_SIZE;
 	cdev->mcfg[MRAM_TXB].num = mram_config_vals[7] &
-			(TXBC_NDTB_MASK >> TXBC_NDTB_SHIFT);
+		(TXBC_NDTB_MASK >> TXBC_NDTB_SHIFT);
 
 	dev_dbg(cdev->dev,
-		"sidf 0x%x %d xidf 0x%x %d rxf0 0x%x %d rxf1 0x%x %d rxb 0x%x %d txe 0x%x %d txb 0x%x %d\n",
-		cdev->mcfg[MRAM_SIDF].off, cdev->mcfg[MRAM_SIDF].num,
-		cdev->mcfg[MRAM_XIDF].off, cdev->mcfg[MRAM_XIDF].num,
-		cdev->mcfg[MRAM_RXF0].off, cdev->mcfg[MRAM_RXF0].num,
-		cdev->mcfg[MRAM_RXF1].off, cdev->mcfg[MRAM_RXF1].num,
-		cdev->mcfg[MRAM_RXB].off, cdev->mcfg[MRAM_RXB].num,
-		cdev->mcfg[MRAM_TXE].off, cdev->mcfg[MRAM_TXE].num,
-		cdev->mcfg[MRAM_TXB].off, cdev->mcfg[MRAM_TXB].num);
+			"sidf 0x%x %d xidf 0x%x %d rxf0 0x%x %d rxf1 0x%x %d rxb 0x%x %d txe 0x%x %d txb 0x%x %d\n",
+			cdev->mcfg[MRAM_SIDF].off, cdev->mcfg[MRAM_SIDF].num,
+			cdev->mcfg[MRAM_XIDF].off, cdev->mcfg[MRAM_XIDF].num,
+			cdev->mcfg[MRAM_RXF0].off, cdev->mcfg[MRAM_RXF0].num,
+			cdev->mcfg[MRAM_RXF1].off, cdev->mcfg[MRAM_RXF1].num,
+			cdev->mcfg[MRAM_RXB].off, cdev->mcfg[MRAM_RXB].num,
+			cdev->mcfg[MRAM_TXE].off, cdev->mcfg[MRAM_TXE].num,
+			cdev->mcfg[MRAM_TXB].off, cdev->mcfg[MRAM_TXB].num);
 }
 
 void m_can_init_ram(struct m_can_classdev *cdev)
@@ -1728,9 +1788,9 @@
 	int ret;
 
 	ret = fwnode_property_read_u32_array(dev_fwnode(dev),
-					     "bosch,mram-cfg",
-					     mram_config_vals,
-					     sizeof(mram_config_vals) / 4);
+			"bosch,mram-cfg",
+			mram_config_vals,
+			sizeof(mram_config_vals) / 4);
 	if (ret) {
 		dev_err(dev, "Could not get Message RAM configuration.");
 		goto out;
@@ -1782,7 +1842,7 @@
 	ret = register_m_can_dev(m_can_dev->net);
 	if (ret) {
 		dev_err(m_can_dev->dev, "registering %s failed (err=%d)\n",
-			m_can_dev->net->name, ret);
+				m_can_dev->net->name, ret);
 		goto clk_disable;
 	}
 
@@ -1791,7 +1851,7 @@
 	of_can_transceiver(m_can_dev->net);
 
 	dev_info(m_can_dev->dev, "%s device registered (irq=%d, version=%d)\n",
-		 KBUILD_MODNAME, m_can_dev->net->irq, m_can_dev->version);
+			KBUILD_MODNAME, m_can_dev->net->irq, m_can_dev->version);
 
 	/* Probe finished
 	 * Stop clocks. They will be reactivated once the M_CAN device is opened
diff -Naur A/drivers/net/can/m_can/m_can.h B/drivers/net/can/m_can/m_can.h
--- A/drivers/net/can/m_can/m_can.h	2022-06-30 18:05:15.000000000 +0530
+++ B/drivers/net/can/m_can/m_can.h	2022-08-09 13:36:04.270484049 +0530
@@ -28,6 +28,11 @@
 #include <linux/can/dev.h>
 #include <linux/pinctrl/consumer.h>
 
+#ifdef CONFIG_MX6ULL_IWG26I
+#include <linux/gpio.h>
+void m_can_set_iw_mcan_prop_flag( void );
+#endif /* CONFIG_MX6ULL_IWG26I */
+
 /* m_can lec values */
 enum m_can_lec_type {
 	LEC_NO_ERROR = 0,
diff -Naur A/drivers/net/can/m_can/tcan4x5x.c B/drivers/net/can/m_can/tcan4x5x.c
--- A/drivers/net/can/m_can/tcan4x5x.c	2022-06-30 18:05:15.000000000 +0530
+++ B/drivers/net/can/m_can/tcan4x5x.c	2022-08-09 13:36:04.270484049 +0530
@@ -81,10 +81,19 @@
 #define TCAN4X5X_MCAN_IR_RF0F BIT(2)
 #define TCAN4X5X_MCAN_IR_RF0W BIT(1)
 #define TCAN4X5X_MCAN_IR_RF0N BIT(0)
+#define TCAN4X5X_RESET_GPIO 22
+
+#ifdef CONFIG_MX6ULL_IWG26I
+#define TCAN4X5X_ENABLE_MCAN_INT \
+	(TCAN4X5X_MCAN_IR_TC | TCAN4X5X_MCAN_IR_RF0F | \
+	 TCAN4X5X_MCAN_IR_RF1F | TCAN4X5X_MCAN_IR_RF0W | \
+	 TCAN4X5X_MCAN_IR_RF1W)
+#else /* CONFIG_MX6ULL_IWG26I */
 #define TCAN4X5X_ENABLE_MCAN_INT \
 	(TCAN4X5X_MCAN_IR_TC | TCAN4X5X_MCAN_IR_RF0N | \
 	 TCAN4X5X_MCAN_IR_RF1N | TCAN4X5X_MCAN_IR_RF0F | \
 	 TCAN4X5X_MCAN_IR_RF1F)
+#endif /* CONFIG_MX6ULL_IWG26I */
 
 #define TCAN4X5X_MRAM_START 0x8000
 #define TCAN4X5X_MCAN_OFFSET 0x1000
@@ -110,6 +119,8 @@
 #define TCAN4X5X_WD_3_S_TIMER BIT(29)
 #define TCAN4X5X_WD_6_S_TIMER (BIT(28) | BIT(29))
 
+bool iw_tcan_prop = false; /* Flag added for Rugged Telematics Device */
+
 struct tcan4x5x_priv {
 	struct regmap *regmap;
 	struct spi_device *spi;
@@ -176,7 +187,7 @@
 		gpiod_set_value(priv->reset_gpio, 0);
 	} else {
 		ret = regmap_write(priv->regmap, TCAN4X5X_CONFIG,
-				   TCAN4X5X_SW_RESET);
+				TCAN4X5X_SW_RESET);
 		if (ret)
 			return ret;
 	}
@@ -187,8 +198,8 @@
 }
 
 static int regmap_spi_gather_write(void *context, const void *reg,
-				   size_t reg_len, const void *val,
-				   size_t val_len)
+		size_t reg_len, const void *val,
+		size_t val_len)
 {
 	struct device *dev = context;
 	struct spi_device *spi = to_spi_device(dev);
@@ -217,9 +228,9 @@
 }
 
 static int regmap_spi_async_write(void *context,
-				  const void *reg, size_t reg_len,
-				  const void *val, size_t val_len,
-				  struct regmap_async *a)
+		const void *reg, size_t reg_len,
+		const void *val, size_t val_len,
+		struct regmap_async *a)
 {
 	return -ENOTSUPP;
 }
@@ -230,8 +241,8 @@
 }
 
 static int tcan4x5x_regmap_read(void *context,
-				const void *reg, size_t reg_size,
-				void *val, size_t val_size)
+		const void *reg, size_t reg_size,
+		void *val, size_t val_size)
 {
 	struct device *dev = context;
 	struct spi_device *spi = to_spi_device(dev);
@@ -280,7 +291,7 @@
 }
 
 static int tcan4x5x_write_fifo(struct m_can_classdev *cdev,
-			       int addr_offset, int val)
+		int addr_offset, int val)
 {
 	struct tcan4x5x_priv *priv = cdev->device_data;
 
@@ -299,7 +310,7 @@
 }
 
 static int tcan4x5x_write_tcan_reg(struct m_can_classdev *cdev,
-				   int reg, int val)
+		int reg, int val)
 {
 	struct tcan4x5x_priv *priv = cdev->device_data;
 
@@ -311,22 +322,22 @@
 	int ret;
 
 	ret = tcan4x5x_write_tcan_reg(cdev, TCAN4X5X_STATUS,
-				      TCAN4X5X_CLEAR_ALL_INT);
+			TCAN4X5X_CLEAR_ALL_INT);
 	if (ret)
 		return ret;
 
 	ret = tcan4x5x_write_tcan_reg(cdev, TCAN4X5X_MCAN_INT_REG,
-				      TCAN4X5X_ENABLE_MCAN_INT);
+			TCAN4X5X_ENABLE_MCAN_INT);
 	if (ret)
 		return ret;
 
 	ret = tcan4x5x_write_tcan_reg(cdev, TCAN4X5X_INT_FLAGS,
-				      TCAN4X5X_CLEAR_ALL_INT);
+			TCAN4X5X_CLEAR_ALL_INT);
 	if (ret)
 		return ret;
 
 	ret = tcan4x5x_write_tcan_reg(cdev, TCAN4X5X_ERROR_STATUS,
-				      TCAN4X5X_CLEAR_ALL_INT);
+			TCAN4X5X_CLEAR_ALL_INT);
 	if (ret)
 		return ret;
 
@@ -345,12 +356,12 @@
 		return ret;
 
 	ret = tcan4x5x_write_tcan_reg(cdev, TCAN4X5X_INT_EN,
-				      TCAN4X5X_ENABLE_TCAN_INT);
+			TCAN4X5X_ENABLE_TCAN_INT);
 	if (ret)
 		return ret;
 
 	ret = regmap_update_bits(tcan4x5x->regmap, TCAN4X5X_CONFIG,
-				 TCAN4X5X_MODE_SEL_MASK, TCAN4X5X_MODE_NORMAL);
+			TCAN4X5X_MODE_SEL_MASK, TCAN4X5X_MODE_NORMAL);
 	if (ret)
 		return ret;
 
@@ -365,30 +376,36 @@
 	struct tcan4x5x_priv *tcan4x5x = cdev->device_data;
 	int ret;
 
-	tcan4x5x->device_wake_gpio = devm_gpiod_get(cdev->dev, "device-wake",
-						    GPIOD_OUT_HIGH);
-	if (IS_ERR(tcan4x5x->device_wake_gpio)) {
-		dev_err(cdev->dev, "device-wake gpio not defined\n");
-		return -EINVAL;
+	if (!iw_tcan_prop)
+	{
+		tcan4x5x->device_wake_gpio = devm_gpiod_get(cdev->dev, "device-wake",
+				GPIOD_OUT_HIGH);
+		if (IS_ERR(tcan4x5x->device_wake_gpio)) {
+			dev_err(cdev->dev, "device-wake gpio not defined\n");
+			return -EINVAL;
+		}
 	}
 
 	tcan4x5x->reset_gpio = devm_gpiod_get_optional(cdev->dev, "reset",
-						       GPIOD_OUT_LOW);
+			GPIOD_OUT_LOW);
 	if (IS_ERR(tcan4x5x->reset_gpio))
 		tcan4x5x->reset_gpio = NULL;
 
-	ret = tcan4x5x_reset(tcan4x5x);
-	if (ret)
-		return ret;
+	if (!iw_tcan_prop)
+	{
+		ret = tcan4x5x_reset(tcan4x5x);
+		if (ret)
+			return ret;
+	}
 
 	tcan4x5x->device_state_gpio = devm_gpiod_get_optional(cdev->dev,
-							      "device-state",
-							      GPIOD_IN);
+			"device-state",
+			GPIOD_IN);
 	if (IS_ERR(tcan4x5x->device_state_gpio))
 		tcan4x5x->device_state_gpio = NULL;
 
 	tcan4x5x->power = devm_regulator_get_optional(cdev->dev,
-						      "vsup");
+			"vsup");
 	if (PTR_ERR(tcan4x5x->power) == -EPROBE_DEFER)
 		return -EPROBE_DEFER;
 
@@ -411,12 +428,53 @@
 	.clear_interrupts = tcan4x5x_clear_interrupts,
 };
 
+/*
+* Added for the reset of TCAN4X5X chip
+*/
+static int tcan4x5x_wakeup_mode( void )
+{
+	usleep_range(10, 50);
+	gpio_request(TCAN4X5X_RESET_GPIO, "TCAN_ON");
+	gpio_direction_output(TCAN4X5X_RESET_GPIO, 0);
+	gpio_set_value(TCAN4X5X_RESET_GPIO, 0);
+	usleep_range(1, 50);
+
+	gpio_request(TCAN4X5X_RESET_GPIO, "TCAN_ON");
+	gpio_direction_output(TCAN4X5X_RESET_GPIO, 0);
+	gpio_set_value(TCAN4X5X_RESET_GPIO, 1);
+	usleep_range(1, 50);
+
+	gpio_request(TCAN4X5X_RESET_GPIO, "TCAN_ON");
+	gpio_direction_output(TCAN4X5X_RESET_GPIO, 0);
+	gpio_set_value(TCAN4X5X_RESET_GPIO, 0);
+	usleep_range(1, 50);
+
+	return 0;
+}
+
 static int tcan4x5x_can_probe(struct spi_device *spi)
 {
 	struct tcan4x5x_priv *priv;
 	struct m_can_classdev *mcan_class;
 	int freq, ret;
 
+	/* For finding the TCAN node */
+	struct device_node *tcan_node;
+	tcan_node = of_find_compatible_node(NULL, NULL, "ti,tcan4x5x");
+	if (!tcan_node) {
+		printk("%s : can't find TCAN node\n", __func__);
+		return -EINVAL;
+	}
+
+	/* For finding the iWave flag defined in Device Tree */
+	if (of_get_property(tcan_node, "iw-tcan-prop", NULL))
+	{
+		iw_tcan_prop = true;
+		m_can_set_iw_mcan_prop_flag();
+		tcan4x5x_wakeup_mode( );
+		msleep(100);
+	}
+
 	mcan_class = m_can_class_allocate_dev(&spi->dev);
 	if (!mcan_class)
 		return -ENOMEM;
@@ -466,7 +524,7 @@
 		goto out_clk;
 
 	priv->regmap = devm_regmap_init(&spi->dev, &tcan4x5x_bus,
-					&spi->dev, &tcan4x5x_regmap);
+			&spi->dev, &tcan4x5x_regmap);
 
 	tcan4x5x_power_enable(priv->power, 1);
 
@@ -493,10 +551,24 @@
 	return ret;
 }
 
+static int tcan4x5x_sleep_mode( struct tcan4x5x_priv *priv )
+{
+	struct tcan4x5x_priv *tcan4x5x =
+		(struct tcan4x5x_priv *)priv;
+	int ret;
+	ret = regmap_update_bits(tcan4x5x->regmap, TCAN4X5X_CONFIG,
+			TCAN4X5X_MODE_SEL_MASK, TCAN4X5X_MODE_SLEEP );
+	return ret;
+}
+
 static int tcan4x5x_can_remove(struct spi_device *spi)
 {
 	struct tcan4x5x_priv *priv = spi_get_drvdata(spi);
 
+	if (iw_tcan_prop)
+	{
+		tcan4x5x_sleep_mode( priv );
+	}
 	tcan4x5x_power_enable(priv->power, 0);
 
 	m_can_class_unregister(priv->mcan_dev);
diff -Naur A/drivers/net/phy/Kconfig B/drivers/net/phy/Kconfig
--- A/drivers/net/phy/Kconfig	2022-06-30 18:05:15.000000000 +0530
+++ B/drivers/net/phy/Kconfig	2022-08-09 13:36:04.270484049 +0530
@@ -506,6 +506,11 @@
 	  the Reduced Gigabit Media Independent Interface(RGMII) between
 	  Ethernet physical media devices and the Gigabit Ethernet controller.
 
+config TI_PHY_DP83848
+        tristate "Driver for TI DP83848KSQ/NOPB"
+        ---help---
+          This is the driver for the TI DP83848KSQ/NOPB PHYs.
+
 endif # PHYLIB
 
 config MICREL_KS8995MA
diff -Naur A/drivers/net/phy/Makefile B/drivers/net/phy/Makefile
--- A/drivers/net/phy/Makefile	2022-06-30 18:05:15.000000000 +0530
+++ B/drivers/net/phy/Makefile	2022-08-09 13:36:04.270484049 +0530
@@ -22,6 +22,7 @@
 obj-$(CONFIG_PHYLINK)		+= phylink.o
 obj-$(CONFIG_PHYLIB)		+= libphy.o
 
+obj-$(CONFIG_TI_PHY_DP83848)   += dp83848.o
 obj-$(CONFIG_MDIO_ASPEED)	+= mdio-aspeed.o
 obj-$(CONFIG_MDIO_BCM_IPROC)	+= mdio-bcm-iproc.o
 obj-$(CONFIG_MDIO_BCM_UNIMAC)	+= mdio-bcm-unimac.o
diff -Naur A/drivers/net/phy/phy_device.c B/drivers/net/phy/phy_device.c
--- A/drivers/net/phy/phy_device.c	2022-06-30 18:05:15.000000000 +0530
+++ B/drivers/net/phy/phy_device.c	2022-08-09 13:36:04.270484049 +0530
@@ -2382,10 +2382,17 @@
 EXPORT_SYMBOL(phy_drivers_unregister);
 
 static struct phy_driver genphy_driver = {
+#ifdef CONFIG_TI_PHY_DP83848
+	.phy_id		= 0x20005c90,
+	.phy_id_mask	= 0xfffffff0,
+	.name		= "DP83848 PHY",
+	.soft_reset	= genphy_soft_reset,
+#else /* CONFIG_TI_PHY_DP83848 */
 	.phy_id		= 0xffffffff,
 	.phy_id_mask	= 0xffffffff,
 	.name		= "Generic PHY",
 	.soft_reset	= genphy_no_soft_reset,
+#endif
 	.get_features	= genphy_read_abilities,
 	.aneg_done	= genphy_aneg_done,
 	.suspend	= genphy_suspend,
diff -Naur A/drivers/power/supply/bq25601.c B/drivers/power/supply/bq25601.c
--- A/drivers/power/supply/bq25601.c	1970-01-01 05:30:00.000000000 +0530
+++ B/drivers/power/supply/bq25601.c	2022-08-09 13:36:04.270484049 +0530
@@ -0,0 +1,1585 @@
+/*
+ * Driver for the TI bq25601 battery charger.
+ *
+ * Author: Mark A. Greer <mgreer@animalcreek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/of_irq.h>
+#include <linux/of_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/power_supply.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include "bq25601-platform-data.h"
+#define BQ25601_MANUFACTURER			 "Texas Instruments"
+
+#define BQ25601_REG_ISC        			0x00 /* Input Source Control */
+#define BQ25601_REG_ISC_EN_HIZ_MASK             BIT(7)
+#define BQ25601_REG_ISC_EN_HIZ_SHIFT            7
+#define BQ25601_REG_ISC_EN_ICHG_MON_MASK        (BIT(6) | BIT(5))
+#define BQ25601_REG_ISC_EN_ICHG_MON_SHIFT       5
+#define BQ25601_REG_ISC_IINDPM_MASK             (BIT(4) | BIT(3) | BIT(2) | \
+						BIT(1) | BIT(0))
+#define BQ25601_REG_ISC_IINDPM_SHIFT            0
+
+#define BQ25601_REG_POC         		0x01 /* Power-On Configuration */
+#define BQ25601_REG_POC_PFM_DIS_MASK            BIT(7)
+#define BQ25601_REG_POC_PFM_DIS_SHIFT           7
+#define BQ25601_REG_POC_WD_RST_MASK             BIT(6)
+#define BQ25601_REG_POC_WD_RST_SHIFT            6
+#define BQ25601_REG_POC_CHG_CONFIG_MASK         (BIT(5) | BIT(4))
+#define BQ25601_REG_POC_CHG_CONFIG_SHIFT        4
+#define BQ25601_REG_POC_SYS_MIN_MASK            (BIT(3) | BIT(2) | BIT(1))
+#define BQ25601_REG_POC_SYS_MIN_SHIFT           1
+#define BQ25601_REG_POC_MIN_VBAT_SEL_MASK       BIT(0)
+#define BQ25601_REG_POC_MIN_VBAT_SEL_SHIFT      0
+
+#define BQ25601_REG_CCC         		0x02 /* Charge Current Control */
+#define BQ25601_REG_CCC_BOOST_LIM_MASK              BIT(7) 
+#define BQ25601_REG_CCC_BOOST_LIM_SHIFT             7
+#define BQ25601_REG_CCC_Q1_FULLON_MASK              BIT(6) 
+#define BQ25601_REG_CCC_Q1_FULLON_SHIFT             6
+#define BQ25601_REG_CCC_ICHG_MASK               (BIT(5) | BIT(4) | BIT(3) | \
+                                                  BIT(2) | BIT(1) | BIT(0))
+#define BQ25601_REG_CCC_ICHG_SHIFT               0
+
+#define BQ25601_REG_PCTCC			0x03 /* Pre-charge/Termination Current Cntl */
+#define BQ25601_REG_PCTCC_IPRECHG_MASK	    	(BIT(7) | BIT(6) | BIT(5) | \
+                    				 BIT(4))
+#define BQ25601_REG_PCTCC_IPRECHG_SHIFT		4
+#define BQ25601_REG_PCTCC_ITERM_MASK		(BIT(3) | BIT(2) | BIT(1) | \
+					         BIT(0))
+#define BQ25601_REG_PCTCC_ITERM_SHIFT		0
+
+#define BQ25601_REG_CVC                         0x04 /* Charge Voltage Control */
+#define BQ25601_REG_CVC_VREG_MASK               (BIT(7) | BIT(6) | BIT(5) | \
+                                                 BIT(4) | BIT(3))
+#define BQ25601_REG_CVC_VREG_SHIFT              3
+#define BQ25601_REG_CVC_TOPOFF_TIMER_MASK       (BIT(2) | BIT(1))
+#define BQ25601_REG_CVC_TOPOFF_TIMER_SHIFT      1
+#define BQ25601_REG_CVC_VRECHG_MASK  	        BIT(0)
+#define BQ25601_REG_CVC_VRECHG_SHIFT	        0
+
+#define BQ25601_REG_CTTC        		0x05 /* Charge Term/Timer Control */
+#define BQ25601_REG_CTTC_EN_TERM_MASK           BIT(7)
+#define BQ25601_REG_CTTC_EN_TERM_SHIFT          7
+#define BQ25601_REG_CTTC_WATCHDOG_MASK          (BIT(5) | BIT(4))
+#define BQ25601_REG_CTTC_WATCHDOG_SHIFT         4
+#define BQ25601_REG_CTTC_EN_TIMER_MASK		BIT(3)
+#define BQ25601_REG_CTTC_EN_TIMER_SHIFT		3
+#define BQ25601_REG_CTTC_CHG_TIMER_MASK		BIT(2)
+#define BQ25601_REG_CTTC_CHG_TIMER_SHIFT	2
+#define BQ25601_REG_CTTC_TREG_MASK	        BIT(1)
+#define BQ25601_REG_CTTC_TREG_SHIFT	        1
+#define BQ25601_REG_CTTC_JEITA_ISET_MASK	BIT(0)
+#define BQ25601_REG_CTTC_JEITA_ISET_SHIFT	0
+
+#define BQ25601_REG_ICTRC                       0x06 /* IR Comp/Thermal Regulation Control */
+#define BQ25601_REG_ICTRC_OVP_MASK              (BIT(7) | BIT(6))
+#define BQ25601_REG_ICTRC_OVP_SHIFT             6
+#define BQ25601_REG_ICTRC_BOOSTV_MASK           (BIT(5) | BIT(4))
+#define BQ25601_REG_ICTRC_BOOSTV_SHIFT          4
+#define BQ25601_REG_ICTRC_VINDPM_MASK           (BIT(3) | BIT(2) | BIT(1) | \
+                                                 BIT(0))
+#define BQ25601_REG_ICTRC_VINDPM_SHIFT                0
+
+#define BQ25601_REG_MOC         		0x07 /* Misc. Operation Control */
+#define BQ25601_REG_MOC_IINDET_EN_MASK          BIT(7)
+#define BQ25601_REG_MOC_IINDET_EN_SHIFT    	7
+#define BQ25601_REG_MOC_TMR2X_EN_MASK           BIT(6)
+#define BQ25601_REG_MOC_TMR2X_EN_SHIFT          6
+#define BQ25601_REG_MOC_BATFET_DISABLE_MASK     BIT(5)
+#define BQ25601_REG_MOC_BATFET_DISABLE_SHIFT    5
+#define BQ25601_REG_MOC_JEITA_VSET_MASK         BIT(4)
+#define BQ25601_REG_MOC_JEITA_VSET_SHIFT        4
+#define BQ25601_REG_MOC_BATFET_DLY_MASK         BIT(3)
+#define BQ25601_REG_MOC_BATFET_DLY_SHIFT        3
+#define BQ25601_REG_MOC_BATFET_RST_EN_MASK      BIT(2)
+#define BQ25601_REG_MOC_BATFET_RST_EN_SHIFT     2
+#define BQ25601_REG_MOC_BAT_TRACK_MASK     (BIT(1) | BIT(0))
+#define BQ25601_REG_MOC_BAT_TRACK_SHIFT    0
+
+#define BQ25601_REG_SS          		0x08 /* System Status */
+#define BQ25601_REG_SS_VBUS_STAT_MASK           (BIT(7) | BIT(6) | BIT(5))
+#define BQ25601_REG_SS_VBUS_STAT_SHIFT          5
+#define BQ25601_REG_SS_CHRG_STAT_MASK           (BIT(4) | BIT(3))
+#define BQ25601_REG_SS_CHRG_STAT_SHIFT          3
+#define BQ25601_REG_SS_PG_STAT_MASK             BIT(2)
+#define BQ25601_REG_SS_PG_STAT_SHIFT            2
+#define BQ25601_REG_SS_THERM_STAT_MASK          BIT(1)
+#define BQ25601_REG_SS_THERM_STAT_SHIFT         1
+#define BQ25601_REG_SS_VSYS_STAT_MASK           BIT(0)
+#define BQ25601_REG_SS_VSYS_STAT_SHIFT          0
+
+#define BQ25601_REG_F                           0x09 /* Fault */
+#define BQ25601_REG_F_WATCHDOG_FAULT_MASK       BIT(7)
+#define BQ25601_REG_F_WATCHDOG_FAULT_SHIFT      7
+#define BQ25601_REG_F_BOOST_FAULT_MASK          BIT(6)
+#define BQ25601_REG_F_BOOST_FAULT_SHIFT         6
+#define BQ25601_REG_F_CHRG_FAULT_MASK           (BIT(5) | BIT(4))
+#define BQ25601_REG_F_CHRG_FAULT_SHIFT          4
+#define BQ25601_REG_F_BAT_FAULT_MASK            BIT(3)
+#define BQ25601_REG_F_BAT_FAULT_SHIFT           3
+#define BQ25601_REG_F_NTC_FAULT_MASK            (BIT(2) | BIT(1) | BIT(0))
+#define BQ25601_REG_F_NTC_FAULT_SHIFT           0
+
+#define BQ25601_REG_A	                        0x0A /* Misc  */
+#define BQ25601_REG_A_VBUS_GD_MASK              BIT(7) 
+#define BQ25601_REG_A_VBUS_GD_SHIFT             7
+#define BQ25601_REG_A_VINDPM_STAT_MASK          BIT(6)
+#define BQ25601_REG_A_VINDPM_STAT_SHIFT         6
+#define BQ25601_REG_A_IINDPM_STAT_MASK          BIT(5) 
+#define BQ25601_REG_A_IINDPM_STAT_SHIFT         5
+#define BQ25601_REG_A_TOPOFF_ACTIVE_MASK        BIT(3)
+#define BQ25601_REG_A_TOPOFF_ACTIVE_SHIFT       3
+#define BQ25601_REG_A_ACOV_STAT_MASK            BIT(2) 
+#define BQ25601_REG_A_ACOV_STAT_SHIFT           2
+#define BQ25601_REG_A_VINDPM_INT_MASK           BIT(1)
+#define BQ25601_REG_A_VINDPM_INT_SHIFT          1
+#define BQ25601_REG_A_IINDPMINT_STAT_MASK          BIT(0)
+#define BQ25601_REG_A_IINDPMINT_STAT_SHIFT         0
+
+#define BQ25601_REG_VPRS			0x0B /* Vendor/Part/Revision Status */
+#define BQ25601_REG_VPRS_REG_RESET_MASK		BIT(7) 
+#define BQ25601_REG_VPRS_REG_RESET_SHIFT	7
+#define BQ25601_REG_VPRS_PN_MASK		(BIT(6) | BIT(5) | BIT(4)| BIT(3))
+#define BQ25601_REG_VPRS_PN_SHIFT		3
+#define BQ25601_REG_VPRS_PN_25601		0x2
+#define BQ25601_REG_VPRS_DEV_RES_MASK	        (BIT(1) | BIT(0))
+#define BQ25601_REG_VPRS_DEV_RES_SHIFT	        0
+
+/*
+ * The FAULT register is latched by the bq25601 (except for NTC_FAULT)
+ * so the first read after a fault returns the latched value and subsequent
+ * reads return the current value.  In order to return the fault status
+ * to the user, have the interrupt handler save the reg's value and retrieve
+ * it in the appropriate health/status routine.  Each routine has its own
+ * flag indicating whether it should use the value stored by the last run
+ * of the interrupt handler or do an actual reg read.  That way each routine
+ * can report back whatever fault may have occured.
+ */
+struct bq25601_dev_info {
+	struct i2c_client		*client;
+	struct device			*dev;
+	struct power_supply		*charger;
+	struct power_supply		*battery;
+	char				model_name[I2C_NAME_SIZE];
+	kernel_ulong_t			model;
+	unsigned int			gpio_int;
+	unsigned int			irq;
+	struct mutex			f_reg_lock;
+	bool				first_time;
+	bool				charger_health_valid;
+	bool				battery_health_valid;
+	bool				battery_status_valid;
+	u8				f_reg;
+	u8				ss_reg;
+	u8				watchdog;
+};
+
+/*
+ * The tables below provide a 2-way mapping for the value that goes in
+ * the register field and the real-world value that it represents.
+ * The index of the array is the value that goes in the register; the
+ * number at that index in the array is the real-world value that it
+ * represents.
+ */
+/* REG02[7:2] (ICHG) in uAh */
+static const int bq25601_ccc_ichg_values[] = {
+         0,      60000,   120000,   180000,  240000,  300000,  360000,  420000,
+	480000,  540000,  600000,   660000,  720000,  780000,  840000,  900000,
+	960000,  1020000, 1080000, 1140000, 1200000, 1260000, 1320000, 1380000,
+	1440000, 1500000, 1560000, 1620000, 1680000, 1740000, 1800000, 1860000,
+	1920000, 1980000, 2040000, 2100000, 2160000, 2200000, 2260000, 2280000,
+	2340000, 2400000, 2460000, 2520000, 2580000, 2640000, 2700000, 2760000,
+	2820000, 2880000, 2940000, 3000000
+}; 
+
+/* REG04[7:2] (VREG) in uV */
+static const int bq25601_cvc_vreg_values[] = {
+        3856000, 3888000, 3920000, 3952000, 3984000, 4016000, 4048000, 4080000,
+        4112000, 4144000, 4176000, 4208000, 4240000, 4272000, 4304000, 4336000,
+        4368000, 4400000, 4432000, 4464000, 4496000, 4528000, 4560000, 4592000,
+        4624000
+};
+
+/* REG06[1:0] (TREG) in tenths of degrees Celcius */
+static const int bq25601_cttc_treg_values[] = {
+	900, 1100
+};
+
+/*
+ * Return the index in 'tbl' of greatest value that is less than or equal to
+ * 'val'.  The index range returned is 0 to 'tbl_size' - 1.  Assumes that
+ * the values in 'tbl' are sorted from smallest to largest and 'tbl_size'
+ * is less than 2^8.
+ */
+static u8 bq25601_find_idx(const int tbl[], int tbl_size, int v)
+{
+	int i;
+
+	for (i = 1; i < tbl_size; i++)
+		if (v < tbl[i])
+			break;
+
+	return i - 1;
+}
+
+/* Basic driver I/O routines */
+
+static int bq25601_read(struct bq25601_dev_info *bdi, u8 reg, u8 *data)
+{
+	int ret;
+
+	ret = i2c_smbus_read_byte_data(bdi->client, reg);
+	if (ret < 0)
+		return ret;
+
+	*data = ret;
+	return 0;
+}
+
+static int bq25601_write(struct bq25601_dev_info *bdi, u8 reg, u8 data)
+{
+	return i2c_smbus_write_byte_data(bdi->client, reg, data);
+}
+
+static int bq25601_read_mask(struct bq25601_dev_info *bdi, u8 reg,
+		u8 mask, u8 shift, u8 *data)
+{
+	u8 v;
+	int ret;
+
+	ret = bq25601_read(bdi, reg, &v);
+	if (ret < 0)
+		return ret;
+
+	v &= mask;
+	v >>= shift;
+	*data = v;
+
+	return 0;
+}
+
+static int bq25601_write_mask(struct bq25601_dev_info *bdi, u8 reg,
+		u8 mask, u8 shift, u8 data)
+{
+	u8 v;
+	int ret;
+
+	ret = bq25601_read(bdi, reg, &v);
+	if (ret < 0)
+		return ret;
+
+	v &= ~mask;
+	v |= ((data << shift) & mask);
+
+	return bq25601_write(bdi, reg, v);
+}
+
+static int bq25601_get_field_val(struct bq25601_dev_info *bdi,
+		u8 reg, u8 mask, u8 shift,
+		const int tbl[], int tbl_size,
+		int *val)
+{
+	u8 v;
+	int ret;
+
+	ret = bq25601_read_mask(bdi, reg, mask, shift, &v);
+	if (ret < 0)
+		return ret;
+
+	v = (v >= tbl_size) ? (tbl_size - 1) : v;
+	*val = tbl[v];
+
+	return 0;
+}
+
+static int bq25601_set_field_val(struct bq25601_dev_info *bdi,
+		u8 reg, u8 mask, u8 shift,
+		const int tbl[], int tbl_size,
+		int val)
+{
+	u8 idx;
+
+	idx = bq25601_find_idx(tbl, tbl_size, val);
+
+	return bq25601_write_mask(bdi, reg, mask, shift, idx);
+}
+
+#ifdef CONFIG_SYSFS
+/*
+ * There are a numerous options that are configurable on the bq25601
+ * that go well beyond what the power_supply properties provide access to.
+ * Provide sysfs access to them so they can be examined and possibly modified
+ * on the fly.  They will be provided for the charger power_supply object only
+ * and will be prefixed by 'f_' to make them easier to recognize.
+ */
+
+#define BQ25601_SYSFS_FIELD(_name, r, f, m, store)			\
+{									\
+	.attr	= __ATTR(f_##_name, m, bq25601_sysfs_show, store),	\
+	.reg	= BQ25601_REG_##r,					\
+	.mask	= BQ25601_REG_##r##_##f##_MASK,				\
+	.shift	= BQ25601_REG_##r##_##f##_SHIFT,			\
+}
+
+#define BQ25601_SYSFS_FIELD_RW(_name, r, f)				\
+		BQ25601_SYSFS_FIELD(_name, r, f, S_IWUSR | S_IRUGO,	\
+				bq25601_sysfs_store)
+
+#define BQ25601_SYSFS_FIELD_RO(_name, r, f)				\
+		BQ25601_SYSFS_FIELD(_name, r, f, S_IRUGO, NULL)
+
+static ssize_t bq25601_sysfs_show(struct device *dev,
+		struct device_attribute *attr, char *buf);
+static ssize_t bq25601_sysfs_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count);
+
+struct bq25601_sysfs_field_info {
+	struct device_attribute	attr;
+	u8	reg;
+	u8	mask;
+	u8	shift;
+};
+
+/* On i386 ptrace-abi.h defines SS that breaks the macro calls below. */
+#undef SS
+static struct bq25601_sysfs_field_info bq25601_sysfs_field_tbl[] = {
+			/*	sysfs name	reg	field in reg */
+	BQ25601_SYSFS_FIELD_RW(en_hiz,		ISC,	EN_HIZ),
+	BQ25601_SYSFS_FIELD_RW(en_ichg_mon,	ISC,	EN_ICHG_MON),
+	BQ25601_SYSFS_FIELD_RW(iindpm,		ISC,	IINDPM),
+	BQ25601_SYSFS_FIELD_RW(chg_config,	POC,	CHG_CONFIG),
+	BQ25601_SYSFS_FIELD_RW(sys_min,		POC,	SYS_MIN),
+	BQ25601_SYSFS_FIELD_RW(min_vbat_sel,	POC,	MIN_VBAT_SEL),
+	BQ25601_SYSFS_FIELD_RW(boost_lim,		CCC,	BOOST_LIM),
+	BQ25601_SYSFS_FIELD_RW(q1_fullon,	CCC,	Q1_FULLON),
+	BQ25601_SYSFS_FIELD_RW(ichg,		CCC,	ICHG),
+	BQ25601_SYSFS_FIELD_RW(iprechg,		PCTCC,	IPRECHG),
+	BQ25601_SYSFS_FIELD_RW(iterm,		PCTCC,	ITERM),
+	BQ25601_SYSFS_FIELD_RW(vreg,		CVC,	VREG),
+	BQ25601_SYSFS_FIELD_RW(topoff_timer,		CVC,	TOPOFF_TIMER),
+	BQ25601_SYSFS_FIELD_RW(vrechg,		CVC,	VRECHG),
+	BQ25601_SYSFS_FIELD_RW(en_term,		CTTC,	EN_TERM),
+	BQ25601_SYSFS_FIELD_RW(watchdog,	CTTC,	WATCHDOG),
+	BQ25601_SYSFS_FIELD_RW(en_timer,	CTTC,	EN_TIMER),
+	BQ25601_SYSFS_FIELD_RW(chg_timer,	CTTC,	CHG_TIMER),
+	BQ25601_SYSFS_FIELD_RW(treg,	CTTC,	TREG),
+	BQ25601_SYSFS_FIELD_RW(jeta_iset,	CTTC,	JEITA_ISET),
+	BQ25601_SYSFS_FIELD_RW(ovp,	ICTRC,	OVP),
+	BQ25601_SYSFS_FIELD_RW(boostv,		ICTRC,	BOOSTV),
+	BQ25601_SYSFS_FIELD_RW(vindpm,		ICTRC,	VINDPM),
+	BQ25601_SYSFS_FIELD_RW(iindet_en,		MOC,	IINDET_EN),
+	BQ25601_SYSFS_FIELD_RW(tmr2x_en,	MOC,	TMR2X_EN),
+	BQ25601_SYSFS_FIELD_RW(batfet_disable,	MOC,	BATFET_DISABLE),
+	BQ25601_SYSFS_FIELD_RW(jeita_vset,	MOC,	JEITA_VSET),
+	BQ25601_SYSFS_FIELD_RW(batfet_dly,	MOC,	BATFET_DLY),
+	BQ25601_SYSFS_FIELD_RW(batfet_rst_en,	MOC,	BATFET_RST_EN),
+	BQ25601_SYSFS_FIELD_RW(bat_track,	MOC,	BAT_TRACK),
+	BQ25601_SYSFS_FIELD_RO(vbus_stat,	SS,	VBUS_STAT),
+	BQ25601_SYSFS_FIELD_RO(chrg_stat,	SS,	CHRG_STAT),
+	BQ25601_SYSFS_FIELD_RO(pg_stat,		SS,	PG_STAT),
+	BQ25601_SYSFS_FIELD_RO(therm_stat,	SS,	THERM_STAT),
+	BQ25601_SYSFS_FIELD_RO(vsys_stat,	SS,	VSYS_STAT),
+	BQ25601_SYSFS_FIELD_RO(watchdog_fault,	F,	WATCHDOG_FAULT),
+	BQ25601_SYSFS_FIELD_RO(boost_fault,	F,	BOOST_FAULT),
+	BQ25601_SYSFS_FIELD_RO(chrg_fault,	F,	CHRG_FAULT),
+	BQ25601_SYSFS_FIELD_RO(bat_fault,	F,	BAT_FAULT),
+	BQ25601_SYSFS_FIELD_RO(ntc_fault,	F,	NTC_FAULT),
+	BQ25601_SYSFS_FIELD_RO(vbus_gd,	A,	VBUS_GD),
+	BQ25601_SYSFS_FIELD_RO(vindpm_stat,	A,	VINDPM_STAT),
+	BQ25601_SYSFS_FIELD_RO(iindpm_stat,	A,	IINDPM_STAT),
+	BQ25601_SYSFS_FIELD_RO(topoff_active,	A,	TOPOFF_ACTIVE),
+	BQ25601_SYSFS_FIELD_RO(acov_stat,	A,	ACOV_STAT),
+	BQ25601_SYSFS_FIELD_RO(vindpm_int,	A,	VINDPM_INT),
+	BQ25601_SYSFS_FIELD_RO(iindpmint_stat,	A,	IINDPMINT_STAT),
+	BQ25601_SYSFS_FIELD_RO(reg_reset,	VPRS,	REG_RESET),
+	BQ25601_SYSFS_FIELD_RO(pn,		VPRS,	PN),
+	BQ25601_SYSFS_FIELD_RO(dev_res,		VPRS,	DEV_RES),
+};
+
+static struct attribute *
+	bq25601_sysfs_attrs[ARRAY_SIZE(bq25601_sysfs_field_tbl) + 1];
+
+static const struct attribute_group bq25601_sysfs_attr_group = {
+	.attrs = bq25601_sysfs_attrs,
+};
+
+static void bq25601_sysfs_init_attrs(void)
+{
+	int i, limit = ARRAY_SIZE(bq25601_sysfs_field_tbl);
+
+	for (i = 0; i < limit; i++)
+		bq25601_sysfs_attrs[i] = &bq25601_sysfs_field_tbl[i].attr.attr;
+
+	bq25601_sysfs_attrs[limit] = NULL; /* Has additional entry for this */
+}
+
+static struct bq25601_sysfs_field_info *bq25601_sysfs_field_lookup(
+		const char *name)
+{
+	int i, limit = ARRAY_SIZE(bq25601_sysfs_field_tbl);
+
+	for (i = 0; i < limit; i++)
+		if (!strcmp(name, bq25601_sysfs_field_tbl[i].attr.attr.name))
+			break;
+
+	if (i >= limit)
+		return NULL;
+
+	return &bq25601_sysfs_field_tbl[i];
+}
+
+static ssize_t bq25601_sysfs_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	//struct bq25601_dev_info *bdi =
+	//		container_of(psy, struct bq25601_dev_info, charger);
+	struct bq25601_dev_info *bdi = power_supply_get_drvdata(psy);
+	struct bq25601_sysfs_field_info *info;
+	int ret;
+	u8 v;
+
+	info = bq25601_sysfs_field_lookup(attr->attr.name);
+	if (!info)
+		return -EINVAL;
+
+	ret = bq25601_read_mask(bdi, info->reg, info->mask, info->shift, &v);
+	if (ret)
+		return ret;
+
+	return scnprintf(buf, PAGE_SIZE, "%hhx\n", v);
+}
+
+static ssize_t bq25601_sysfs_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	//struct bq25601_dev_info *bdi =
+	//		container_of(psy, struct bq25601_dev_info, charger);
+	struct bq25601_dev_info *bdi = power_supply_get_drvdata(psy);
+	struct bq25601_sysfs_field_info *info;
+	int ret;
+	u8 v;
+
+	info = bq25601_sysfs_field_lookup(attr->attr.name);
+	if (!info)
+		return -EINVAL;
+
+	ret = kstrtou8(buf, 0, &v);
+	if (ret < 0)
+		return ret;
+
+	ret = bq25601_write_mask(bdi, info->reg, info->mask, info->shift, v);
+	if (ret)
+		return ret;
+
+	return count;
+}
+
+static int bq25601_sysfs_create_group(struct bq25601_dev_info *bdi)
+{
+	bq25601_sysfs_init_attrs();
+
+	//return sysfs_create_group(&bdi->dev->kobj,
+	//		&bq25601_sysfs_attr_group);
+		return sysfs_create_group(&bdi->charger->dev.kobj,
+			&bq25601_sysfs_attr_group);
+}
+
+static void bq25601_sysfs_remove_group(struct bq25601_dev_info *bdi)
+{
+	//sysfs_remove_group(&bdi->dev->kobj, &bq25601_sysfs_attr_group);
+	sysfs_remove_group(&bdi->charger->dev.kobj, &bq25601_sysfs_attr_group);
+}
+#else
+static int bq25601_sysfs_create_group(struct bq25601_dev_info *bdi)
+{
+	return 0;
+}
+
+static inline void bq25601_sysfs_remove_group(struct bq25601_dev_info *bdi) {}
+#endif
+
+/*
+ * According to the "Host Mode and default Mode" section of the
+ * manual, a write to any register causes the bq25601 to switch
+ * from default mode to host mode.  It will switch back to default
+ * mode after a WDT timeout unless the WDT is turned off as well.
+ * So, by simply turning off the WDT, we accomplish both with the
+ * same write.
+ */
+static int bq25601_set_mode_host(struct bq25601_dev_info *bdi)
+{
+	int ret;
+	u8 v;
+
+	ret = bq25601_read(bdi, BQ25601_REG_CTTC, &v);
+	if (ret < 0)
+		return ret;
+
+	bdi->watchdog = ((v & BQ25601_REG_CTTC_WATCHDOG_MASK) >>
+					BQ25601_REG_CTTC_WATCHDOG_SHIFT);
+	v &= ~BQ25601_REG_CTTC_WATCHDOG_MASK;
+
+	return bq25601_write(bdi, BQ25601_REG_CTTC, v);
+}
+
+static int bq25601_register_reset(struct bq25601_dev_info *bdi)
+{
+	int ret, limit = 100;
+	u8 v;
+
+	/* Reset the registers */
+	ret = bq25601_write_mask(bdi, BQ25601_REG_VPRS,
+			BQ25601_REG_VPRS_REG_RESET_MASK,
+			BQ25601_REG_VPRS_REG_RESET_SHIFT,
+			0x1);
+	if (ret < 0)
+		return ret;
+
+	/* Reset bit will be cleared by hardware so poll until it is */
+	do {
+		ret = bq25601_read_mask(bdi, BQ25601_REG_VPRS,
+				BQ25601_REG_VPRS_REG_RESET_MASK,
+				BQ25601_REG_VPRS_REG_RESET_SHIFT,
+				&v);
+		if (ret < 0)
+			return ret;
+
+		if (!v)
+			break;
+
+		udelay(10);
+	} while (--limit);
+
+	if (!limit)
+		return -EIO;
+
+	return 0;
+}
+
+/* Charger power supply property routines */
+
+static int bq25601_charger_get_charge_type(struct bq25601_dev_info *bdi,
+		union power_supply_propval *val)
+{
+	u8 v;
+	int type, ret;
+
+	ret = bq25601_read_mask(bdi, BQ25601_REG_POC,
+			BQ25601_REG_POC_CHG_CONFIG_MASK,
+			BQ25601_REG_POC_CHG_CONFIG_SHIFT,
+			&v);
+	if (ret < 0)
+		return ret;
+
+	/* If POC[CHG_CONFIG] (REG01[5:4]) == 0, charge is disabled */
+	if (!v) {
+		type = POWER_SUPPLY_CHARGE_TYPE_NONE;
+	} else {
+/*		ret = bq25601_read_mask(bdi, BQ25601_REG_CCC,
+				BQ25601_REG_CCC_FORCE_20PCT_MASK,
+				BQ25601_REG_CCC_FORCE_20PCT_SHIFT,
+				&v);
+		if (ret < 0)
+			return ret;*/
+
+		type = (v) ? POWER_SUPPLY_CHARGE_TYPE_TRICKLE :
+			     POWER_SUPPLY_CHARGE_TYPE_FAST;
+	}
+
+	val->intval = type;
+
+	return 0;
+}
+
+static int bq25601_charger_set_charge_type(struct bq25601_dev_info *bdi,
+		const union power_supply_propval *val)
+{
+	u8 chg_config, en_term;
+	int ret;
+
+	/*
+	 * According to the "Termination when REG02[0] = 1" section of
+	 * the bq25601 manual, the trickle charge could be less than the
+	 * termination current so it recommends turning off the termination
+	 * function.
+	 *
+	 * Note: AFAICT from the datasheet, the user will have to manually
+	 * turn off the charging when in 20% mode.  If its not turned off,
+	 * there could be battery damage.  So, use this mode at your own risk.
+	 */
+	switch (val->intval) {
+	case POWER_SUPPLY_CHARGE_TYPE_NONE:
+		chg_config = 0x0;
+		break;
+	case POWER_SUPPLY_CHARGE_TYPE_TRICKLE:
+		chg_config = 0x1;
+		//force_20pct = 0x1;
+		en_term = 0x0;
+		break;
+	case POWER_SUPPLY_CHARGE_TYPE_FAST:
+		chg_config = 0x1;
+		//force_20pct = 0x0;
+		en_term = 0x1;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (chg_config) { /* Enabling the charger */
+/*		ret = bq25601_write_mask(bdi, BQ25601_REG_CCC,
+				BQ25601_REG_CCC_FORCE_20PCT_MASK,
+				BQ25601_REG_CCC_FORCE_20PCT_SHIFT,
+				force_20pct);
+		if (ret < 0)
+			return ret;*/
+
+		ret = bq25601_write_mask(bdi, BQ25601_REG_CTTC,
+				BQ25601_REG_CTTC_EN_TERM_MASK,
+				BQ25601_REG_CTTC_EN_TERM_SHIFT,
+				en_term);
+		if (ret < 0)
+			return ret;
+	}
+
+	return bq25601_write_mask(bdi, BQ25601_REG_POC,
+			BQ25601_REG_POC_CHG_CONFIG_MASK,
+			BQ25601_REG_POC_CHG_CONFIG_SHIFT, chg_config);
+}
+
+static int bq25601_charger_get_health(struct bq25601_dev_info *bdi,
+		union power_supply_propval *val)
+{
+	u8 v;
+	int health, ret;
+
+	mutex_lock(&bdi->f_reg_lock);
+
+	if (bdi->charger_health_valid) {
+		v = bdi->f_reg;
+		bdi->charger_health_valid = false;
+		mutex_unlock(&bdi->f_reg_lock);
+	} else {
+		mutex_unlock(&bdi->f_reg_lock);
+
+		ret = bq25601_read(bdi, BQ25601_REG_F, &v);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (v & BQ25601_REG_F_BOOST_FAULT_MASK) {
+		/*
+		 * This could be over-current or over-voltage but there's
+		 * no way to tell which.  Return 'OVERVOLTAGE' since there
+		 * isn't an 'OVERCURRENT' value defined that we can return
+		 * even if it was over-current.
+		 */
+		health = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+	} else {
+		v &= BQ25601_REG_F_CHRG_FAULT_MASK;
+		v >>= BQ25601_REG_F_CHRG_FAULT_SHIFT;
+
+		switch (v) {
+		case 0x0: /* Normal */
+			health = POWER_SUPPLY_HEALTH_GOOD;
+			break;
+		case 0x1: /* Input Fault (VBUS OVP or VBAT<VBUS<3.8V) */
+			/*
+			 * This could be over-voltage or under-voltage
+			 * and there's no way to tell which.  Instead
+			 * of looking foolish and returning 'OVERVOLTAGE'
+			 * when its really under-voltage, just return
+			 * 'UNSPEC_FAILURE'.
+			 */
+			health = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;
+			break;
+		case 0x2: /* Thermal Shutdown */
+			health = POWER_SUPPLY_HEALTH_OVERHEAT;
+			break;
+		case 0x3: /* Charge Safety Timer Expiration */
+			health = POWER_SUPPLY_HEALTH_SAFETY_TIMER_EXPIRE;
+			break;
+		default:
+			health = POWER_SUPPLY_HEALTH_UNKNOWN;
+		}
+	}
+
+	val->intval = health;
+
+	return 0;
+}
+
+static int bq25601_charger_get_online(struct bq25601_dev_info *bdi,
+		union power_supply_propval *val)
+{
+	u8 v;
+	int ret;
+
+	ret = bq25601_read_mask(bdi, BQ25601_REG_SS,
+			BQ25601_REG_SS_PG_STAT_MASK,
+			BQ25601_REG_SS_PG_STAT_SHIFT, &v);
+	if (ret < 0)
+		return ret;
+
+	val->intval = v;
+	return 0;
+}
+
+static int bq25601_charger_get_current(struct bq25601_dev_info *bdi,
+		union power_supply_propval *val)
+{
+	//u8 v;
+	int curr, ret;
+
+	ret = bq25601_get_field_val(bdi, BQ25601_REG_CCC,
+			BQ25601_REG_CCC_ICHG_MASK, BQ25601_REG_CCC_ICHG_SHIFT,
+			bq25601_ccc_ichg_values,
+			ARRAY_SIZE(bq25601_ccc_ichg_values), &curr);
+	if (ret < 0)
+		return ret;
+
+/*	ret = bq25601_read_mask(bdi, BQ25601_REG_CCC,
+			BQ25601_REG_CCC_FORCE_20PCT_MASK,
+			BQ25601_REG_CCC_FORCE_20PCT_SHIFT, &v);
+	if (ret < 0)
+		return ret;*/
+
+	/* If FORCE_20PCT is enabled, then current is 20% of ICHG value */
+	/*if (v)
+		curr /= 5;*/
+
+	val->intval = curr;
+	return 0;
+}
+
+static int bq25601_charger_get_current_max(struct bq25601_dev_info *bdi,
+		union power_supply_propval *val)
+{
+	int idx = ARRAY_SIZE(bq25601_ccc_ichg_values) - 1;
+
+	val->intval = bq25601_ccc_ichg_values[idx];
+	return 0;
+}
+
+static int bq25601_charger_set_current(struct bq25601_dev_info *bdi,
+		const union power_supply_propval *val)
+{
+//	u8 v;
+//	int ret;
+        int  curr = val->intval;
+
+/*	ret = bq25601_read_mask(bdi, BQ25601_REG_CCC,
+			BQ25601_REG_CCC_FORCE_20PCT_MASK,
+			BQ25601_REG_CCC_FORCE_20PCT_SHIFT, &v);
+	if (ret < 0)
+		return ret;*/
+
+	/* If FORCE_20PCT is enabled, have to multiply value passed in by 5 */
+	/*if (v)
+		curr *= 5;*/
+
+	return bq25601_set_field_val(bdi, BQ25601_REG_CCC,
+			BQ25601_REG_CCC_ICHG_MASK, BQ25601_REG_CCC_ICHG_SHIFT,
+			bq25601_ccc_ichg_values,
+			ARRAY_SIZE(bq25601_ccc_ichg_values), curr);
+}
+
+static int bq25601_charger_get_voltage(struct bq25601_dev_info *bdi,
+		union power_supply_propval *val)
+{
+	int voltage, ret;
+
+	ret = bq25601_get_field_val(bdi, BQ25601_REG_CVC,
+			BQ25601_REG_CVC_VREG_MASK, BQ25601_REG_CVC_VREG_SHIFT,
+			bq25601_cvc_vreg_values,
+			ARRAY_SIZE(bq25601_cvc_vreg_values), &voltage);
+	if (ret < 0)
+		return ret;
+
+	val->intval = voltage;
+	return 0;
+}
+
+static int bq25601_charger_get_voltage_max(struct bq25601_dev_info *bdi,
+		union power_supply_propval *val)
+{
+	int idx = ARRAY_SIZE(bq25601_cvc_vreg_values) - 1;
+
+	val->intval = bq25601_cvc_vreg_values[idx];
+	return 0;
+}
+
+static int bq25601_charger_set_voltage(struct bq25601_dev_info *bdi,
+		const union power_supply_propval *val)
+{
+	return bq25601_set_field_val(bdi, BQ25601_REG_CVC,
+			BQ25601_REG_CVC_VREG_MASK, BQ25601_REG_CVC_VREG_SHIFT,
+			bq25601_cvc_vreg_values,
+			ARRAY_SIZE(bq25601_cvc_vreg_values), val->intval);
+}
+
+static int bq25601_charger_get_property(struct power_supply *psy,
+		enum power_supply_property psp, union power_supply_propval *val)
+{
+	struct bq25601_dev_info *bdi = power_supply_get_drvdata(psy);
+	//		container_of(psy, struct bq25601_dev_info, charger);
+	int ret;
+
+	dev_dbg(bdi->dev, "prop: %d\n", psp);
+
+	pm_runtime_get_sync(bdi->dev);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_CHARGE_TYPE:
+		ret = bq25601_charger_get_charge_type(bdi, val);
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		ret = bq25601_charger_get_health(bdi, val);
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		ret = bq25601_charger_get_online(bdi, val);
+		break;
+	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:
+		ret = bq25601_charger_get_current(bdi, val);
+		break;
+	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX:
+		ret = bq25601_charger_get_current_max(bdi, val);
+		break;
+	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:
+		ret = bq25601_charger_get_voltage(bdi, val);
+		break;
+	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX:
+		ret = bq25601_charger_get_voltage_max(bdi, val);
+		break;
+	case POWER_SUPPLY_PROP_SCOPE:
+		val->intval = POWER_SUPPLY_SCOPE_SYSTEM;
+		ret = 0;
+		break;
+	case POWER_SUPPLY_PROP_MODEL_NAME:
+		val->strval = bdi->model_name;
+		ret = 0;
+		break;
+	case POWER_SUPPLY_PROP_MANUFACTURER:
+		val->strval = BQ25601_MANUFACTURER;
+		ret = 0;
+		break;
+	default:
+		ret = -ENODATA;
+	}
+
+	pm_runtime_put_sync(bdi->dev);
+	return ret;
+}
+
+static int bq25601_charger_set_property(struct power_supply *psy,
+		enum power_supply_property psp,
+		const union power_supply_propval *val)
+{
+	struct bq25601_dev_info *bdi = power_supply_get_drvdata(psy);
+			//container_of(psy, struct bq25601_dev_info, charger);
+	int ret;
+
+	dev_dbg(bdi->dev, "prop: %d\n", psp);
+
+	pm_runtime_get_sync(bdi->dev);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_CHARGE_TYPE:
+		ret = bq25601_charger_set_charge_type(bdi, val);
+		break;
+	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:
+		ret = bq25601_charger_set_current(bdi, val);
+		break;
+	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:
+		ret = bq25601_charger_set_voltage(bdi, val);
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	pm_runtime_put_sync(bdi->dev);
+	return ret;
+}
+
+static int bq25601_charger_property_is_writeable(struct power_supply *psy,
+		enum power_supply_property psp)
+{
+	int ret;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_CHARGE_TYPE:
+	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:
+	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:
+		ret = 1;
+		break;
+	default:
+		ret = 0;
+	}
+
+	return ret;
+}
+
+static enum power_supply_property bq25601_charger_properties[] = {
+	POWER_SUPPLY_PROP_TYPE,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT,
+	POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX,
+	POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE,
+	POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX,
+	POWER_SUPPLY_PROP_SCOPE,
+	POWER_SUPPLY_PROP_MODEL_NAME,
+	POWER_SUPPLY_PROP_MANUFACTURER,
+};
+
+static char *bq25601_charger_supplied_to[] = {
+	"main-battery",
+};
+
+static const struct power_supply_desc bq25601_charger_desc = {
+	.name			= "bq25601-charger",
+	.type			= POWER_SUPPLY_TYPE_USB,
+	.properties		= bq25601_charger_properties,
+	.num_properties		= ARRAY_SIZE(bq25601_charger_properties),
+	.get_property		= bq25601_charger_get_property,
+	.set_property		= bq25601_charger_set_property,
+	.property_is_writeable	= bq25601_charger_property_is_writeable,
+};
+
+/* Battery power supply property routines */
+static int bq25601_battery_get_status(struct bq25601_dev_info *bdi,
+		union power_supply_propval *val)
+{
+	u8 ss_reg, chrg_fault;
+	int status, ret;
+
+	mutex_lock(&bdi->f_reg_lock);
+
+	if (bdi->battery_status_valid) {
+		chrg_fault = bdi->f_reg;
+		bdi->battery_status_valid = false;
+		mutex_unlock(&bdi->f_reg_lock);
+	} else {
+		mutex_unlock(&bdi->f_reg_lock);
+
+		ret = bq25601_read(bdi, BQ25601_REG_F, &chrg_fault);
+		if (ret < 0)
+			return ret;
+	}
+
+	chrg_fault &= BQ25601_REG_F_CHRG_FAULT_MASK;
+	chrg_fault >>= BQ25601_REG_F_CHRG_FAULT_SHIFT;
+
+	ret = bq25601_read(bdi, BQ25601_REG_SS, &ss_reg);
+	if (ret < 0)
+		return ret;
+
+	/*
+	 * The battery must be discharging when any of these are true:
+	 * - there is no good power source;
+	 * - there is a charge fault.
+	 * Could also be discharging when in "supplement mode" but
+	 * there is no way to tell when its in that mode.
+	 */
+	if (!(ss_reg & BQ25601_REG_SS_PG_STAT_MASK) || chrg_fault) {
+		status = POWER_SUPPLY_STATUS_DISCHARGING;
+	} else {
+		ss_reg &= BQ25601_REG_SS_CHRG_STAT_MASK;
+		ss_reg >>= BQ25601_REG_SS_CHRG_STAT_SHIFT;
+
+		switch (ss_reg) {
+		case 0x0: /* Not Charging */
+			status = POWER_SUPPLY_STATUS_NOT_CHARGING;
+			break;
+		case 0x1: /* Pre-charge */
+		case 0x2: /* Fast Charging */
+			status = POWER_SUPPLY_STATUS_CHARGING;
+			break;
+		case 0x3: /* Charge Termination Done */
+			status = POWER_SUPPLY_STATUS_FULL;
+			break;
+		default:
+			ret = -EIO;
+		}
+	}
+
+	if (!ret)
+		val->intval = status;
+
+	return ret;
+}
+
+static int bq25601_battery_get_health(struct bq25601_dev_info *bdi,
+		union power_supply_propval *val)
+{
+	u8 v;
+	int health, ret;
+
+	mutex_lock(&bdi->f_reg_lock);
+
+	if (bdi->battery_health_valid) {
+		v = bdi->f_reg;
+		bdi->battery_health_valid = false;
+		mutex_unlock(&bdi->f_reg_lock);
+	} else {
+		mutex_unlock(&bdi->f_reg_lock);
+
+		ret = bq25601_read(bdi, BQ25601_REG_F, &v);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (v & BQ25601_REG_F_BAT_FAULT_MASK) {
+		health = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+	} else {
+		v &= BQ25601_REG_F_NTC_FAULT_MASK;
+		v >>= BQ25601_REG_F_NTC_FAULT_SHIFT;
+
+		switch (v) {
+		case 0x0: /* Normal */
+			health = POWER_SUPPLY_HEALTH_GOOD;
+			break;
+		case 0x1: /* TS1 Cold */
+		case 0x3: /* TS2 Cold */
+		case 0x5: /* Both Cold */
+			health = POWER_SUPPLY_HEALTH_COLD;
+			break;
+		case 0x2: /* TS1 Hot */
+		case 0x4: /* TS2 Hot */
+		case 0x6: /* Both Hot */
+			health = POWER_SUPPLY_HEALTH_OVERHEAT;
+			break;
+		default:
+			health = POWER_SUPPLY_HEALTH_UNKNOWN;
+		}
+	}
+
+	val->intval = health;
+	return 0;
+}
+
+static int bq25601_battery_get_online(struct bq25601_dev_info *bdi,
+		union power_supply_propval *val)
+{
+	u8 batfet_disable;
+	int ret;
+
+	ret = bq25601_read_mask(bdi, BQ25601_REG_MOC,
+			BQ25601_REG_MOC_BATFET_DISABLE_MASK,
+			BQ25601_REG_MOC_BATFET_DISABLE_SHIFT, &batfet_disable);
+	if (ret < 0)
+		return ret;
+
+	val->intval = !batfet_disable;
+	return 0;
+}
+
+static int bq25601_battery_set_online(struct bq25601_dev_info *bdi,
+		const union power_supply_propval *val)
+{
+	return bq25601_write_mask(bdi, BQ25601_REG_MOC,
+			BQ25601_REG_MOC_BATFET_DISABLE_MASK,
+			BQ25601_REG_MOC_BATFET_DISABLE_SHIFT, !val->intval);
+}
+
+static int bq25601_battery_get_temp_alert_max(struct bq25601_dev_info *bdi,
+		union power_supply_propval *val)
+{
+	int temp, ret;
+
+	ret = bq25601_get_field_val(bdi, BQ25601_REG_CTTC,
+			BQ25601_REG_CTTC_TREG_MASK,
+			BQ25601_REG_CTTC_TREG_SHIFT,
+			bq25601_cttc_treg_values,
+			ARRAY_SIZE(bq25601_cttc_treg_values), &temp);
+	if (ret < 0)
+		return ret;
+
+	val->intval = temp;
+	return 0;
+}
+
+static int bq25601_battery_set_temp_alert_max(struct bq25601_dev_info *bdi,
+		const union power_supply_propval *val)
+{
+	return bq25601_set_field_val(bdi, BQ25601_REG_CTTC,
+			BQ25601_REG_CTTC_TREG_MASK,
+			BQ25601_REG_CTTC_TREG_SHIFT,
+			bq25601_cttc_treg_values,
+			ARRAY_SIZE(bq25601_cttc_treg_values), val->intval);
+}
+
+static int bq25601_battery_get_property(struct power_supply *psy,
+		enum power_supply_property psp, union power_supply_propval *val)
+{
+	struct bq25601_dev_info *bdi = power_supply_get_drvdata(psy);
+	//		container_of(psy, struct bq25601_dev_info, battery);
+	int ret;
+
+	dev_dbg(bdi->dev, "prop: %d\n", psp);
+
+	pm_runtime_get_sync(bdi->dev);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		ret = bq25601_battery_get_status(bdi, val);
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		ret = bq25601_battery_get_health(bdi, val);
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		ret = bq25601_battery_get_online(bdi, val);
+		break;
+	case POWER_SUPPLY_PROP_TECHNOLOGY:
+		/* Could be Li-on or Li-polymer but no way to tell which */
+		val->intval = POWER_SUPPLY_TECHNOLOGY_UNKNOWN;
+		ret = 0;
+		break;
+	case POWER_SUPPLY_PROP_TEMP_ALERT_MAX:
+		ret = bq25601_battery_get_temp_alert_max(bdi, val);
+		break;
+	case POWER_SUPPLY_PROP_SCOPE:
+		val->intval = POWER_SUPPLY_SCOPE_SYSTEM;
+		ret = 0;
+		break;
+	default:
+		ret = -ENODATA;
+	}
+
+	pm_runtime_put_sync(bdi->dev);
+	return ret;
+}
+
+static int bq25601_battery_set_property(struct power_supply *psy,
+		enum power_supply_property psp,
+		const union power_supply_propval *val)
+{
+	struct bq25601_dev_info *bdi = power_supply_get_drvdata(psy);
+			//container_of(psy, struct bq25601_dev_info, battery);
+	int ret;
+
+	dev_dbg(bdi->dev, "prop: %d\n", psp);
+
+	pm_runtime_put_sync(bdi->dev);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		ret = bq25601_battery_set_online(bdi, val);
+		break;
+	case POWER_SUPPLY_PROP_TEMP_ALERT_MAX:
+		ret = bq25601_battery_set_temp_alert_max(bdi, val);
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	pm_runtime_put_sync(bdi->dev);
+	return ret;
+}
+
+static int bq25601_battery_property_is_writeable(struct power_supply *psy,
+		enum power_supply_property psp)
+{
+	int ret;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+	case POWER_SUPPLY_PROP_TEMP_ALERT_MAX:
+		ret = 1;
+		break;
+	default:
+		ret = 0;
+	}
+
+	return ret;
+}
+
+static enum power_supply_property bq25601_battery_properties[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_TECHNOLOGY,
+	POWER_SUPPLY_PROP_TEMP_ALERT_MAX,
+	POWER_SUPPLY_PROP_SCOPE,
+};
+
+static const struct power_supply_desc bq25601_battery_desc = {
+	.name			= "bq25601-battery",
+	.type			= POWER_SUPPLY_TYPE_BATTERY,
+	.properties		= bq25601_battery_properties,
+	.num_properties		= ARRAY_SIZE(bq25601_battery_properties),
+	.get_property		= bq25601_battery_get_property,
+	.set_property		= bq25601_battery_set_property,
+	.property_is_writeable	= bq25601_battery_property_is_writeable,
+};
+
+static irqreturn_t bq25601_irq_handler_thread(int irq, void *data)
+{
+	struct bq25601_dev_info *bdi = data;
+	bool alert_userspace = false;
+	u8 ss_reg, f_reg;
+	int ret;
+
+	printk("%s 1\r\n",__func__);
+
+	pm_runtime_get_sync(bdi->dev);
+
+	ret = bq25601_read(bdi, BQ25601_REG_SS, &ss_reg);
+	if (ret < 0) {
+		dev_err(bdi->dev, "Can't read SS reg: %d\n", ret);
+		goto out;
+	}
+
+	if (ss_reg != bdi->ss_reg) {
+		/*
+		 * The device is in host mode so when PG_STAT goes from 1->0
+		 * (i.e., power removed) HIZ needs to be disabled.
+		 */
+		if ((bdi->ss_reg & BQ25601_REG_SS_PG_STAT_MASK) &&
+				!(ss_reg & BQ25601_REG_SS_PG_STAT_MASK)) {
+			ret = bq25601_write_mask(bdi, BQ25601_REG_ISC,
+					BQ25601_REG_ISC_EN_HIZ_MASK,
+					BQ25601_REG_ISC_EN_HIZ_SHIFT,
+					0);
+			if (ret < 0)
+				dev_err(bdi->dev, "Can't access ISC reg: %d\n",
+					ret);
+		}
+
+		bdi->ss_reg = ss_reg;
+		alert_userspace = true;
+	}
+
+	mutex_lock(&bdi->f_reg_lock);
+
+	ret = bq25601_read(bdi, BQ25601_REG_F, &f_reg);
+	if (ret < 0) {
+		mutex_unlock(&bdi->f_reg_lock);
+		dev_err(bdi->dev, "Can't read F reg: %d\n", ret);
+		goto out;
+	}
+
+	if (f_reg != bdi->f_reg) {
+		bdi->f_reg = f_reg;
+		bdi->charger_health_valid = true;
+		bdi->battery_health_valid = true;
+		bdi->battery_status_valid = true;
+
+		alert_userspace = true;
+	}
+
+	mutex_unlock(&bdi->f_reg_lock);
+
+	/*
+	 * Sometimes bq25601 gives a steady trickle of interrupts even
+	 * though the watchdog timer is turned off and neither the STATUS
+	 * nor FAULT registers have changed.  Weed out these sprurious
+	 * interrupts so userspace isn't alerted for no reason.
+	 * In addition, the chip always generates an interrupt after
+	 * register reset so we should ignore that one (the very first
+	 * interrupt received).
+	 */
+	if (alert_userspace && !bdi->first_time) {
+		power_supply_changed(bdi->charger);
+		power_supply_changed(bdi->battery);
+		//power_supply_changed(&bdi->charger);
+		//power_supply_changed(&bdi->battery);
+		bdi->first_time = false;
+	}
+
+out:
+	pm_runtime_put_sync(bdi->dev);
+
+	dev_dbg(bdi->dev, "ss_reg: 0x%02x, f_reg: 0x%02x\n", ss_reg, f_reg);
+
+	return IRQ_HANDLED;
+}
+
+static int bq25601_hw_init(struct bq25601_dev_info *bdi)
+{
+	u8 v;
+	int ret;
+
+	pm_runtime_get_sync(bdi->dev);
+
+	/* First check that the device really is what its supposed to be */
+	ret = bq25601_read_mask(bdi, BQ25601_REG_VPRS,
+			BQ25601_REG_VPRS_PN_MASK,
+			BQ25601_REG_VPRS_PN_SHIFT,
+			&v);
+	if (ret < 0)
+		goto out;
+
+	if (v != bdi->model) {
+		ret = -ENODEV;
+		goto out;
+	}
+
+	ret = bq25601_register_reset(bdi);
+	if (ret < 0)
+		goto out;
+
+	ret = bq25601_set_mode_host(bdi);
+	ret = bq25601_write(bdi, BQ25601_REG_ISC, 0x17);
+        if (ret < 0)
+                goto out;
+        ret = bq25601_write(bdi, BQ25601_REG_PCTCC, 0x11);
+        if (ret < 0)
+                goto out;
+out:
+	pm_runtime_put_sync(bdi->dev);
+	return ret;
+}
+
+#ifdef CONFIG_OF
+static int bq25601_setup_dt(struct bq25601_dev_info *bdi)
+{
+	bdi->irq = irq_of_parse_and_map(bdi->dev->of_node, 0);
+	if (bdi->irq <= 0)
+		return -1;
+
+	return 0;
+}
+#else
+static int bq25601_setup_dt(struct bq25601_dev_info *bdi)
+{
+	return -1;
+}
+#endif
+
+static int bq25601_setup_pdata(struct bq25601_dev_info *bdi,
+		struct bq25601_platform_data *pdata)
+{
+	int ret;
+
+	if (!gpio_is_valid(pdata->gpio_int))
+		return -1;
+
+	ret = gpio_request(pdata->gpio_int, dev_name(bdi->dev));
+	if (ret < 0)
+		return -1;
+
+	ret = gpio_direction_input(pdata->gpio_int);
+	if (ret < 0)
+		goto out;
+
+	bdi->irq = gpio_to_irq(pdata->gpio_int);
+	if (!bdi->irq)
+		goto out;
+
+	bdi->gpio_int = pdata->gpio_int;
+	return 0;
+
+out:
+	gpio_free(pdata->gpio_int);
+	return -1;
+}
+
+static int bq25601_probe(struct i2c_client *client,
+		const struct i2c_device_id *id)
+{
+	struct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);
+	struct device *dev = &client->dev;
+	struct bq25601_platform_data *pdata = client->dev.platform_data;
+	struct bq25601_dev_info *bdi;
+	struct power_supply_config charger_cfg = {}, battery_cfg = {};
+	int ret;
+	
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {
+		dev_err(dev, "No support for SMBUS_BYTE_DATA\n");
+		return -ENODEV;
+	}
+	bdi = devm_kzalloc(dev, sizeof(*bdi), GFP_KERNEL);
+	if (!bdi) {
+		dev_err(dev, "Can't alloc bdi struct\n");
+		return -ENOMEM;
+	}
+	bdi->client = client;
+	bdi->dev = dev;
+	bdi->model = id->driver_data;
+	strncpy(bdi->model_name, id->name, I2C_NAME_SIZE);
+	mutex_init(&bdi->f_reg_lock);
+	bdi->first_time = true;
+	bdi->charger_health_valid = false;
+	bdi->battery_health_valid = false;
+	bdi->battery_status_valid = false;
+	i2c_set_clientdata(client, bdi);
+
+	if (dev->of_node)
+		ret = bq25601_setup_dt(bdi);
+	else if (pdata)
+		ret = bq25601_setup_pdata(bdi, pdata);
+	else
+		goto no_irq;
+
+	goto no_irq;
+	if (ret) {
+		dev_err(&client->dev, "Can't get irq info\n");
+		return -EINVAL;
+	}
+
+	ret = devm_request_threaded_irq(dev, bdi->irq, NULL,
+			bq25601_irq_handler_thread,
+			IRQF_TRIGGER_RISING | IRQF_ONESHOT,
+			"bq25601-charger", bdi);
+	if (ret < 0) {
+		dev_err(dev, "Can't set up irq handler\n");
+		goto out1;
+	}
+
+no_irq:
+	pm_runtime_enable(dev);
+	pm_runtime_resume(dev);
+
+	ret = bq25601_hw_init(bdi);
+	if (ret < 0) {
+		dev_err(dev, "Hardware init failed\n");
+		goto out2;
+	}
+
+	charger_cfg.drv_data = bdi;
+	charger_cfg.supplied_to = bq25601_charger_supplied_to;
+	charger_cfg.num_supplicants = ARRAY_SIZE(bq25601_charger_supplied_to),
+	bdi->charger = power_supply_register(dev, &bq25601_charger_desc,
+						&charger_cfg);
+	if (IS_ERR(bdi->charger)) {
+		dev_err(dev, "Can't register charger\n");
+		goto out2;
+	}
+
+	//bq25601_battery_init(&bdi->battery);
+
+	battery_cfg.drv_data = bdi;
+	bdi->battery = power_supply_register(dev, &bq25601_battery_desc,
+						&battery_cfg);
+	if (IS_ERR(bdi->battery)) {
+		dev_err(dev, "Can't register battery\n");
+		goto out3;
+	}
+	ret = bq25601_sysfs_create_group(bdi);
+	if (ret) {
+		dev_err(dev, "Can't create sysfs entries\n");
+		goto out4;
+	}
+
+	return 0;
+
+out4:
+	power_supply_unregister(bdi->battery);
+out3:
+	power_supply_unregister(bdi->charger);
+out2:
+	pm_runtime_disable(dev);
+out1:
+	if (bdi->gpio_int)
+		gpio_free(bdi->gpio_int);
+
+	return ret;
+}
+
+static int bq25601_remove(struct i2c_client *client)
+{
+	struct bq25601_dev_info *bdi = i2c_get_clientdata(client);
+
+	pm_runtime_get_sync(bdi->dev);
+	bq25601_register_reset(bdi);
+	pm_runtime_put_sync(bdi->dev);
+
+	bq25601_sysfs_remove_group(bdi);
+	power_supply_unregister(bdi->battery);
+	power_supply_unregister(bdi->charger);
+	pm_runtime_disable(bdi->dev);
+
+	if (bdi->gpio_int)
+		gpio_free(bdi->gpio_int);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int bq25601_pm_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bq25601_dev_info *bdi = i2c_get_clientdata(client);
+
+	pm_runtime_get_sync(bdi->dev);
+	bq25601_register_reset(bdi);
+	pm_runtime_put_sync(bdi->dev);
+
+	return 0;
+}
+
+static int bq25601_pm_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bq25601_dev_info *bdi = i2c_get_clientdata(client);
+
+	bdi->charger_health_valid = false;
+	bdi->battery_health_valid = false;
+	bdi->battery_status_valid = false;
+
+	pm_runtime_get_sync(bdi->dev);
+	bq25601_register_reset(bdi);
+	pm_runtime_put_sync(bdi->dev);
+
+	/* Things may have changed while suspended so alert upper layer */
+	power_supply_changed(bdi->charger);
+	power_supply_changed(bdi->battery);
+
+	return 0;
+}
+#endif
+
+static SIMPLE_DEV_PM_OPS(bq25601_pm_ops, bq25601_pm_suspend, bq25601_pm_resume);
+
+/*
+ * Only support the bq25601 right now.  The bq24192, bq24192i, and bq24193
+ * are similar but not identical so the driver needs to be extended to
+ * support them.
+ */
+static const struct i2c_device_id bq25601_i2c_ids[] = {
+	{ "bq25601", BQ25601_REG_VPRS_PN_25601 },
+	{ },
+};
+
+#ifdef CONFIG_OF
+static const struct of_device_id bq25601_of_match[] = {
+	{ .compatible = "ti,bq25601", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, bq25601_of_match);
+#else
+static const struct of_device_id bq25601_of_match[] = {
+	{ },
+};
+#endif
+
+static struct i2c_driver bq25601_driver = {
+	.probe		= bq25601_probe,
+	.remove		= bq25601_remove,
+	.id_table	= bq25601_i2c_ids,
+	.driver = {
+		.name		= "bq25601-charger",
+		.owner		= THIS_MODULE,
+		.pm		= &bq25601_pm_ops,
+		.of_match_table	= of_match_ptr(bq25601_of_match),
+	},
+};
+module_i2c_driver(bq25601_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Mark A. Greer <mgreer@animalcreek.com>");
+MODULE_ALIAS("i2c:bq25601-charger");
+MODULE_DESCRIPTION("TI BQ25601 Charger Driver");
diff -Naur A/drivers/power/supply/bq25601-platform-data.h B/drivers/power/supply/bq25601-platform-data.h
--- A/drivers/power/supply/bq25601-platform-data.h	1970-01-01 05:30:00.000000000 +0530
+++ B/drivers/power/supply/bq25601-platform-data.h	2022-08-09 13:36:04.270484049 +0530
@@ -0,0 +1,16 @@
+/*
+ * Platform data for the TI bq25601 battery charger driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef BQ25601_PLATFORM_DATA_H_
+#define BQ25601_PLATFORM_DATA_H_
+
+struct bq25601_platform_data {
+	int	gpio_int;	/* GPIO pin that's connected to INT# */
+};
+
+#endif
diff -Naur A/drivers/power/supply/Kconfig B/drivers/power/supply/Kconfig
--- A/drivers/power/supply/Kconfig	2022-06-30 18:05:15.000000000 +0530
+++ B/drivers/power/supply/Kconfig	2022-08-09 13:36:04.270484049 +0530
@@ -249,6 +249,13 @@
 	  Say Y here to enable support for batteries with BQ27xxx chips
 	  connected over an I2C bus.
 
+config CHARGER_BQ2560X
+	tristate "TI BQ2560x battery charger driver"
+	depends on I2C
+	default y
+	help
+	  Say Y to enable support for the TI BQ2560x battery charger.
+
 config BATTERY_BQ27XXX_HDQ
 	tristate "BQ27xxx HDQ support"
 	depends on BATTERY_BQ27XXX
diff -Naur A/drivers/power/supply/Makefile B/drivers/power/supply/Makefile
--- A/drivers/power/supply/Makefile	2022-06-30 18:05:15.000000000 +0530
+++ B/drivers/power/supply/Makefile	2022-08-09 13:36:04.270484049 +0530
@@ -93,3 +93,4 @@
 obj-$(CONFIG_CHARGER_UCS1002)	+= ucs1002_power.o
 obj-$(CONFIG_CHARGER_BD70528)	+= bd70528-charger.o
 obj-$(CONFIG_CHARGER_WILCO)	+= wilco-charger.o
+obj-$(CONFIG_CHARGER_BQ2560X)	+= bq25601.o
diff -Naur A/drivers/usb/serial/option.c B/drivers/usb/serial/option.c
--- A/drivers/usb/serial/option.c	2022-06-30 18:05:15.000000000 +0530
+++ B/drivers/usb/serial/option.c	2022-08-09 13:36:04.270484049 +0530
@@ -1100,12 +1100,19 @@
 	{ USB_DEVICE_AND_INTERFACE_INFO(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_EC25, 0xff, 0xff, 0xff),
 	  .driver_info = NUMEP2 },
 	{ USB_DEVICE_AND_INTERFACE_INFO(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_EC25, 0xff, 0, 0) },
+#ifdef CONFIG_MX6ULL_IWG26I
+	{ USB_DEVICE(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_EG95),
+          .driver_info = RSVD(4) },
+	{ USB_DEVICE(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_BG96),
+#else /* CONFIG_MX6ULL_IWG26I */
 	{ USB_DEVICE_AND_INTERFACE_INFO(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_EG95, 0xff, 0xff, 0xff),
 	  .driver_info = NUMEP2 },
 	{ USB_DEVICE_AND_INTERFACE_INFO(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_EG95, 0xff, 0, 0) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_BG96, 0xff, 0xff, 0xff),
 	  .driver_info = NUMEP2 },
 	{ USB_DEVICE_AND_INTERFACE_INFO(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_BG96, 0xff, 0, 0) },
+#endif /* CONFIG_MX6ULL_IWG26I */
+	  .driver_info = RSVD(4) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_EP06, 0xff, 0xff, 0xff),
 	  .driver_info = RSVD(1) | RSVD(2) | RSVD(3) | RSVD(4) | NUMEP2 },
 	{ USB_DEVICE_AND_INTERFACE_INFO(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_EP06, 0xff, 0, 0) },
diff -Naur A/drivers/watchdog/imx2_wdt.c B/drivers/watchdog/imx2_wdt.c
--- A/drivers/watchdog/imx2_wdt.c	2022-06-30 18:05:15.000000000 +0530
+++ B/drivers/watchdog/imx2_wdt.c	2022-08-09 13:36:04.270484049 +0530
@@ -55,8 +55,15 @@
 
 #define IMX2_WDT_WMCR		0x08		/* Misc Register */
 
+#ifdef CONFIG_MX6ULL_IWG26I
+#define IMX2_WDT_MAX_TIME	10U
+#define IMX2_WDT_DEFAULT_TIME	10		/* in seconds */
+#else /* CONFIG_MX6ULL_IWG26I */
 #define IMX2_WDT_MAX_TIME	128U
 #define IMX2_WDT_DEFAULT_TIME	60		/* in seconds */
+#endif /* CONFIG_MX6ULL_IWG26I */
+
+bool iw_wdog_prop = false; /* Flag added for Rugged Telematics Device */
 
 #define WDOG_SEC_TO_COUNT(s)	((s * 2 - 1) << 8)
 
@@ -89,6 +96,9 @@
 		   WDIOF_PRETIMEOUT,
 };
 
+static int imx2_wdt_ping(struct watchdog_device *wdog);
+static inline bool imx2_wdt_is_running(struct imx2_wdt_device *wdev);
+
 static int imx2_wdt_restart(struct watchdog_device *wdog, unsigned long action,
 			    void *data)
 {
@@ -103,6 +113,15 @@
 
 	/* Assert SRS signal */
 	regmap_write(wdev->regmap, IMX2_WDT_WCR, wcr_enable);
+
+	if (iw_wdog_prop)
+	{
+		if (imx2_wdt_is_running(wdev))
+		{
+			imx2_wdt_ping(wdog);
+		}
+	}
+
 	/*
 	 * Due to imx6q errata ERR004346 (WDOG: WDOG SRS bit requires to be
 	 * written twice), we add another two writes to ensure there must be at
@@ -274,6 +293,11 @@
 		return PTR_ERR(wdev->clk);
 	}
 
+	if (of_get_property(pdev->dev.of_node, "iw-wdog-prop", NULL))
+	{
+		iw_wdog_prop = true;
+	}
+
 	wdog			= &wdev->wdog;
 	wdog->info		= &imx2_wdt_info;
 	wdog->ops		= &imx2_wdt_ops;
diff -Naur A/firmware/imx/sdma/sdma-imx6q.bin B/firmware/imx/sdma/sdma-imx6q.bin
--- A/firmware/imx/sdma/sdma-imx6q.bin	1970-01-01 05:30:00.000000000 +0530
+++ B/firmware/imx/sdma/sdma-imx6q.bin	2022-08-09 13:36:04.270484049 +0530
@@ -0,0 +1,33 @@
+SDMA         -      	    M    ;        {  L  n         X         [  u  1    WRjRjRjb:0?| ?  } ]x}y} |y|V`}	e3~
+b1~)
+b.~	e,~j'  H|Ax	bj@ x
+bj@  xbj|m	}Rjjb*jRj  U M}W hh
+WRj  \ } ]Vx}y-}8|y|pS`}	ec~
+ba~
+b^~	e\~ZW'  O|pS H|	bZ'  O| H| 
+bZ'  O| H|  bZ'  O| H|(|Ww|?pp\  TWU M}W`VW?<  h
+]W_WR!j  } ]Vx}y*}1|y |pS `}	e7~
+b5~
+b2~	e0~`}Z&Z'  H|pS/ x	bZ	b&Z.  x
+bZ
+b&Z.   xbZb&Z|  U M}W h
+pSl|^k|^YX9 <+}Z[N'|\> M}p ~	}}}(RfRT	||}(RoRT	} ] RSY} M } } ]:|>}>^U M|]RTj8}l}k}|i}h}X } U]m}n}xU] xU]"U] xU]U$]| N|i}U~]P H}\ xU]OU$]/|\ o| U  cui}h}X } U]m}n}lxUm lxUm"Um xlUmUm| N|i}U	~mP H}\Vi}h}.X } U]m}n}jxe]F xje]e]F jxe]e$]| N|i}e	~P]P H}&\U  lcu  TU M|u]TU
+|p T WRj\   } Vx}y-}|y6|pSRd~`}	j^	j[	jX'  O|pS H|  Rj ' O| H| R
+j ' O| H|R	j ' O| H|)|(j'Ww|?pp\  TW M}WzVW?< wT
+wWRj  } Vx}y)}|y.|]pU `}R&R3~`}	j-	j*	j'  H|U@   xRj&Rj?  xR
+j&R
+j? xR	j&R	j	|(j  W M}WwT
+WRjVjbi&}nnb
+j&nb&n`}nbl}&n
+nj&nbx	j% M}`n } b	j% |W M}(j  WQ bj(jbzXT   |(jbz
+NWRjVRi}RHZ&RLZ&R`
+|&Rn#}	j% M$}(jbz } Rn}	j
+ |(j   M}W bj(jbzXT(j
+7WRji  } x}y}|y|Vb(~`}	j"	j	j  H|&  xbj% xb
+j%xb	j	|(j M}RX wTRXOpS_
+X ^<}Z[N|] M}N_
+ RSY} ?na/~b-~c+~|j Boo  hg~kxo|g~xo
+|oioo d hh dWRjRj  } x}y}|y|Vb(~`}	j"	j	j  H|  xbj xb
+jxb	j	|(j M}RX wTRXpS_
+X ^<}Z[N|] M}_
+ RSY} 
\ No newline at end of file
diff -Naur A/include/uapi/linux/iio/types.h B/include/uapi/linux/iio/types.h
--- A/include/uapi/linux/iio/types.h	2022-06-30 18:05:15.000000000 +0530
+++ B/include/uapi/linux/iio/types.h	2022-08-09 13:36:04.270484049 +0530
@@ -44,6 +44,16 @@
 	IIO_COUNT,
 	IIO_INDEX,
 	IIO_GRAVITY,
+#ifdef CONFIG_MX6ULL_IWG26I
+	IIO_SIGN_MOTION,
+	IIO_STEP_DETECTOR,
+	IIO_STEP_COUNTER,
+	IIO_TILT,
+	IIO_TAP,
+	IIO_TAP_TAP,
+	IIO_WRIST_TILT_GESTURE,
+	IIO_GESTURE,
+#endif /* CONFIG_MX6ULL_IWG26I */
 	IIO_POSITIONRELATIVE,
 	IIO_PHASE,
 	IIO_MASSCONCENTRATION,
@@ -103,6 +113,9 @@
 	IIO_EV_TYPE_THRESH_ADAPTIVE,
 	IIO_EV_TYPE_MAG_ADAPTIVE,
 	IIO_EV_TYPE_CHANGE,
+#ifdef CONFIG_MX6ULL_IWG26I
+	IIO_EV_TYPE_FIFO_FLUSH,
+#endif /* CONFIG_MX6ULL_IWG26I */
 };
 
 enum iio_event_direction {
@@ -110,6 +123,10 @@
 	IIO_EV_DIR_RISING,
 	IIO_EV_DIR_FALLING,
 	IIO_EV_DIR_NONE,
+#ifdef CONFIG_MX6ULL_IWG26I
+	IIO_EV_DIR_FIFO_EMPTY,
+	IIO_EV_DIR_FIFO_DATA,
+#endif /* CONFIG_MX6ULL_IWG26I */
 };
 
 #endif /* _UAPI_IIO_TYPES_H_ */
diff -Naur A/net/bluetooth/hci_sysfs.c B/net/bluetooth/hci_sysfs.c
--- A/net/bluetooth/hci_sysfs.c	2022-06-30 18:05:15.000000000 +0530
+++ B/net/bluetooth/hci_sysfs.c	2022-08-09 13:36:04.270484049 +0530
@@ -8,6 +8,53 @@
 
 static struct class *bt_class;
 
+#ifdef CONFIG_MX6ULL_IWG26I
+#define HCI_BREDR       0x00
+static inline char *link_typetostr(int type)
+{
+	switch (type) {
+	case ACL_LINK:
+		return "ACL";
+	case SCO_LINK:
+		return "SCO";
+	case ESCO_LINK:
+		return "eSCO";
+	case LE_LINK:
+		return "LE";
+	default:
+		return "UNKNOWN";
+	}
+}
+
+static ssize_t show_link_type(struct device *dev,
+			      struct device_attribute *attr, char *buf)
+{
+	struct hci_conn *conn = to_hci_conn(dev);
+	return sprintf(buf, "%s\n", link_typetostr(conn->type));
+}
+
+static ssize_t show_link_address(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct hci_conn *conn = to_hci_conn(dev);
+	return sprintf(buf, "%pMR\n", &conn->dst);
+}
+
+#define LINK_ATTR(_name, _mode, _show, _store) \
+struct device_attribute link_attr_##_name = __ATTR(_name, _mode, _show, _store)
+
+static LINK_ATTR(type, S_IRUGO, show_link_type, NULL);
+static LINK_ATTR(address, S_IRUGO, show_link_address, NULL);
+
+static struct attribute *bt_link_attrs[] = {
+	&link_attr_type.attr,
+	&link_attr_address.attr,
+	NULL
+};
+
+ATTRIBUTE_GROUPS(bt_link);
+#endif /* CONFIG_MX6ULL_IWG26I */
+
 static void bt_link_release(struct device *dev)
 {
 	struct hci_conn *conn = to_hci_conn(dev);
@@ -16,6 +63,9 @@
 
 static const struct device_type bt_link = {
 	.name    = "link",
+#ifdef CONFIG_MX6ULL_IWG26I
+	.groups  = bt_link_groups,
+#endif /* CONFIG_MX6ULL_IWG26I */
 	.release = bt_link_release,
 };
 
@@ -80,6 +130,61 @@
 	hci_dev_put(hdev);
 }
 
+#ifdef CONFIG_MX6ULL_IWG26I
+static inline char *host_typetostr(int type)
+{
+	switch (type) {
+	case HCI_BREDR:
+		return "BR/EDR";
+	case HCI_AMP:
+		return "AMP";
+	default:
+		return "UNKNOWN";
+	}
+}
+
+static ssize_t show_type(struct device *dev,
+			 struct device_attribute *attr, char *buf)
+{
+	struct hci_dev *hdev = to_hci_dev(dev);
+	return sprintf(buf, "%s\n", host_typetostr(hdev->dev_type));
+}
+
+static ssize_t show_name(struct device *dev,
+			 struct device_attribute *attr, char *buf)
+{
+	struct hci_dev *hdev = to_hci_dev(dev);
+	char name[HCI_MAX_NAME_LENGTH + 1];
+	int i;
+
+	for (i = 0; i < HCI_MAX_NAME_LENGTH; i++)
+		name[i] = hdev->dev_name[i];
+
+	name[HCI_MAX_NAME_LENGTH] = '\0';
+	return sprintf(buf, "%s\n", name);
+}
+
+static ssize_t show_address(struct device *dev,
+			    struct device_attribute *attr, char *buf)
+{
+	struct hci_dev *hdev = to_hci_dev(dev);
+	return sprintf(buf, "%pMR\n", &hdev->bdaddr);
+}
+
+static DEVICE_ATTR(type, S_IRUGO, show_type, NULL);
+static DEVICE_ATTR(name, S_IRUGO, show_name, NULL);
+static DEVICE_ATTR(address, S_IRUGO, show_address, NULL);
+
+static struct attribute *bt_host_attrs[] = {
+	&dev_attr_type.attr,
+	&dev_attr_name.attr,
+	&dev_attr_address.attr,
+	NULL
+};
+
+ATTRIBUTE_GROUPS(bt_host);
+#endif /* CONFIG_MX6ULL_IWG26I */
+
 static void bt_host_release(struct device *dev)
 {
 	struct hci_dev *hdev = to_hci_dev(dev);
@@ -89,6 +194,9 @@
 
 static const struct device_type bt_host = {
 	.name    = "host",
+#ifdef CONFIG_MX6ULL_IWG26I
+	.groups  = bt_host_groups,
+#endif /* CONFIG_MX6ULL_IWG26I */
 	.release = bt_host_release,
 };
 
diff -Naur A/net/can/j1939/transport.c B/net/can/j1939/transport.c
--- A/net/can/j1939/transport.c	2022-06-30 18:05:15.000000000 +0530
+++ B/net/can/j1939/transport.c	2022-08-09 13:36:04.270484049 +0530
@@ -16,8 +16,13 @@
 
 #define J1939_ETP_PGN_CTL 0xc800
 #define J1939_ETP_PGN_DAT 0xc700
+#ifdef CONFIG_MX6ULL_IWG26I
+#define J1939_TP_PGN_CTL 0xecff
+#define J1939_TP_PGN_DAT 0xebff
+#else /* CONFIG_MX6ULL_IWG26I */
 #define J1939_TP_PGN_CTL 0xec00
 #define J1939_TP_PGN_DAT 0xeb00
+#endif /* CONFIG_MX6ULL_IWG26I */
 
 #define J1939_TP_CMD_RTS 0x10
 #define J1939_TP_CMD_CTS 0x11
